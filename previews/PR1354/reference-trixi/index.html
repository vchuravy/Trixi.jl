<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Trixi.jl · Trixi.jl</title><meta name="title" content="Trixi.jl · Trixi.jl"/><meta property="og:title" content="Trixi.jl · Trixi.jl"/><meta property="twitter:title" content="Trixi.jl · Trixi.jl"/><meta name="description" content="Documentation for Trixi.jl."/><meta property="og:description" content="Documentation for Trixi.jl."/><meta property="twitter:description" content="Documentation for Trixi.jl."/><meta property="og:url" content="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/"/><meta property="twitter:url" content="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/"/><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Trixi.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li><li><a class="tocitem" href="../restart/">Restart simulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">1 First steps in Trixi.jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/first_steps/getting_started/">1.1 Getting started</a></li><li><a class="tocitem" href="../tutorials/first_steps/create_first_setup/">1.2 Create your first setup</a></li><li><a class="tocitem" href="../tutorials/first_steps/changing_trixi/">1.3 Changing Trixi.jl itself</a></li></ul></li><li><a class="tocitem" href="../tutorials/behind_the_scenes_simulation_setup/">2 Behind the scenes of a simulation setup</a></li><li><a class="tocitem" href="../tutorials/scalar_linear_advection_1d/">3 Introduction to DG methods</a></li><li><a class="tocitem" href="../tutorials/DGSEM_FluxDiff/">4 DGSEM with flux differencing</a></li><li><a class="tocitem" href="../tutorials/shock_capturing/">5 Shock capturing with flux differencing and stage limiter</a></li><li><a class="tocitem" href="../tutorials/subcell_shock_capturing/">6 Subcell limiting with the IDP Limiter</a></li><li><a class="tocitem" href="../tutorials/non_periodic_boundaries/">7 Non-periodic boundaries</a></li><li><a class="tocitem" href="../tutorials/DGMulti_1/">8 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../tutorials/DGMulti_2/">9 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../tutorials/upwind_fdsbp/">10 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="../tutorials/adding_new_scalar_equations/">11 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="../tutorials/adding_nonconservative_equation/">12 Adding a non-conservative equation</a></li><li><a class="tocitem" href="../tutorials/parabolic_terms/">13 Parabolic terms</a></li><li><a class="tocitem" href="../tutorials/adding_new_parabolic_terms/">14 Adding new parabolic terms</a></li><li><a class="tocitem" href="../tutorials/adaptive_mesh_refinement/">15 Adaptive mesh refinement</a></li><li><a class="tocitem" href="../tutorials/structured_mesh_mapping/">16 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="../tutorials/hohqmesh_tutorial/">17 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="../tutorials/p4est_from_gmsh/">18 P4est mesh from gmsh</a></li><li><a class="tocitem" href="../tutorials/time_stepping/">19 Explicit time stepping</a></li><li><a class="tocitem" href="../tutorials/differentiable_programming/">20 Differentiable programming</a></li><li><a class="tocitem" href="../tutorials/custom_semidiscretization/">21 Custom semidiscretizations</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../meshes/tree_mesh/">Tree mesh</a></li><li><a class="tocitem" href="../meshes/structured_mesh/">Structured mesh</a></li><li><a class="tocitem" href="../meshes/unstructured_quad_mesh/">Unstructured mesh</a></li><li><a class="tocitem" href="../meshes/p4est_mesh/">P4est-based mesh</a></li><li><a class="tocitem" href="../meshes/dgmulti_mesh/">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="../time_integration/">Time integration</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../multi-physics_coupling/">Coupling</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../github-git/">GitHub &amp; Git</a></li><li><a class="tocitem" href="../styleguide/">Style guide</a></li><li><a class="tocitem" href="../testing/">Testing</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../parallelization/">Parallelization</a></li></ul></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Trixi.jl</a></li><li><a class="tocitem" href="../reference-trixibase/">TrixiBase.jl</a></li><li><a class="tocitem" href="../reference-trixi2vtk/">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Trixi.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Trixi.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl/blob/main/docs/src/reference-trixi.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Trixi.jl-API"><a class="docs-heading-anchor" href="#Trixi.jl-API">Trixi.jl API</a><a id="Trixi.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#Trixi.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.Trixi" href="#Trixi.Trixi"><code>Trixi.Trixi</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Trixi</code></pre><p><strong>Trixi.jl</strong> is a numerical simulation framework for hyperbolic conservation laws. A key objective for the framework is to be useful to both scientists and students. Therefore, next to having an extensible design with a fast implementation, Trixi.jl is focused on being easy to use for new or inexperienced users, including the installation and postprocessing procedures.</p><p>To get started, run your first simulation with Trixi.jl using</p><pre><code class="nohighlight hljs">trixi_include(default_example())</code></pre><p>See also: <a href="https://github.com/trixi-framework/Trixi.jl">trixi-framework/Trixi.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/Trixi.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_do_nothing" href="#Trixi.boundary_condition_do_nothing"><code>Trixi.boundary_condition_do_nothing</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_do_nothing = Trixi.BoundaryConditionDoNothing()</code></pre><p>Imposing no boundary condition just evaluates the flux at the inner state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/basic_types.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_periodic" href="#Trixi.boundary_condition_periodic"><code>Trixi.boundary_condition_periodic</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_periodic = Trixi.BoundaryConditionPeriodic()</code></pre><p>A singleton struct indicating periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/basic_types.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hll" href="#Trixi.flux_hll"><code>Trixi.flux_hll</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">flux_hll</code></pre><p>See <a href="#Trixi.FluxHLL"><code>FluxHLL</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hlle" href="#Trixi.flux_hlle"><code>Trixi.flux_hlle</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">flux_hlle</code></pre><p>See <a href="#Trixi.min_max_speed_einfeldt"><code>min_max_speed_einfeldt</code></a>. This is a <a href="#Trixi.FluxHLL"><code>FluxHLL</code></a>-type two-wave solver with special estimates of the wave speeds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L331-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_lax_friedrichs" href="#Trixi.flux_lax_friedrichs"><code>Trixi.flux_lax_friedrichs</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">flux_lax_friedrichs</code></pre><p>See <a href="#Trixi.FluxLaxFriedrichs"><code>FluxLaxFriedrichs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AMRCallback" href="#Trixi.AMRCallback"><code>Trixi.AMRCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AMRCallback(semi, controller [,adaptor=AdaptorAMR(semi)];
            interval,
            adapt_initial_condition=true,
            adapt_initial_condition_only_refine=true,
            dynamic_load_balancing=true)</code></pre><p>Performs adaptive mesh refinement (AMR) every <code>interval</code> time steps for a given semidiscretization <code>semi</code> using the chosen <code>controller</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/amr.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AbstractEquations" href="#Trixi.AbstractEquations"><code>Trixi.AbstractEquations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEquations{NDIMS, NVARS}</code></pre><p>An abstract supertype of specific equations such as the compressible Euler equations. The type parameters encode the number of spatial dimensions (<code>NDIMS</code>) and the number of primary variables (<code>NVARS</code>) of the physics model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/basic_types.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AbstractMesh" href="#Trixi.AbstractMesh"><code>Trixi.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMesh{NDIMS}</code></pre><p>An abstract supertype of specific mesh types such as <code>TreeMesh</code> or <code>StructuredMesh</code>. The type parameters encode the number of spatial dimensions (<code>NDIMS</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/basic_types.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AcousticPerturbationEquations2D" href="#Trixi.AcousticPerturbationEquations2D"><code>Trixi.AcousticPerturbationEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AcousticPerturbationEquations2D(v_mean_global, c_mean_global, rho_mean_global)</code></pre><p>Acoustic perturbation equations (APE) in two space dimensions. The equations are given by</p><p class="math-container">\[\begin{aligned}
  \frac{\partial\mathbf{v&#39;}}{\partial t} + \nabla (\bar{\mathbf{v}}\cdot\mathbf{v&#39;})
    + \nabla\left( \frac{\bar{c}^2 \tilde{p}&#39;}{\bar{\rho}} \right) &amp;= 0 \\
  \frac{\partial \tilde{p}&#39;}{\partial t} +
    \nabla\cdot (\bar{\rho} \mathbf{v&#39;} + \bar{\mathbf{v}} \tilde{p}&#39;) &amp;= 0.
\end{aligned}\]</p><p>The bar <span>$\bar{(\cdot)}$</span> indicates time-averaged quantities. The unknowns of the APE are the perturbed velocities <span>$\mathbf{v&#39;} = (v_1&#39;, v_2&#39;)^T$</span> and the scaled perturbed pressure <span>$\tilde{p}&#39; = \frac{p&#39;}{\bar{c}^2}$</span>, where <span>$p&#39;$</span> denotes the perturbed pressure and the perturbed variables are defined by <span>$\phi&#39; = \phi - \bar{\phi}$</span>.</p><p>In addition to the unknowns, Trixi.jl currently stores the mean values in the state vector, i.e. the state vector used internally is given by</p><p class="math-container">\[\mathbf{u} =
  \begin{pmatrix}
    v_1&#39; \\ v_2&#39; \\ \tilde{p}&#39; \\ \bar{v}_1 \\ \bar{v}_2 \\ \bar{c} \\ \bar{\rho}
  \end{pmatrix}.\]</p><p>This affects the implementation and use of these equations in various ways:</p><ul><li>The flux values corresponding to the mean values must be zero.</li><li>The mean values have to be considered when defining initial conditions, boundary conditions or source terms.</li><li><a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> analyzes these variables too.</li><li>Trixi.jl&#39;s visualization tools will visualize the mean values by default.</li></ul><p>The constructor accepts a 2-tuple <code>v_mean_global</code> and scalars <code>c_mean_global</code> and <code>rho_mean_global</code> which can be used to make the definition of initial conditions for problems with constant mean flow more flexible. These values are ignored if the mean values are defined internally in an initial condition.</p><p>The equations are based on the APE-4 system introduced in the following paper:</p><ul><li>Roland Ewert and Wolfgang Schröder (2003) Acoustic perturbation equations based on flow decomposition via source filtering <a href="https://doi.org/10.1016/S0021-9991(03)00168-2">DOI: 10.1016/S0021-9991(03)00168-2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L8-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.Adiabatic" href="#Trixi.Adiabatic"><code>Trixi.Adiabatic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Adiabatic</code></pre><p>Used to create a no-slip boundary condition with <a href="#Trixi.BoundaryConditionNavierStokesWall"><code>BoundaryConditionNavierStokesWall</code></a>. The field <code>boundary_value_normal_flux_function</code> should be a function with signature <code>boundary_value_normal_flux_function(x, t, equations)</code> and return a scalar value for the normal heat flux at point <code>x</code> and time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes.jl#L39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AliveCallback" href="#Trixi.AliveCallback"><code>Trixi.AliveCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AliveCallback(analysis_interval=0, alive_interval=analysis_interval÷10)</code></pre><p>Inexpensive callback showing that a simulation is still running by printing some information such as the current time to the screen every <code>alive_interval</code> time steps. If <code>analysis_interval ≂̸ 0</code>, the output is omitted every <code>analysis_interval</code> time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/alive.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AnalysisCallback" href="#Trixi.AnalysisCallback"><code>Trixi.AnalysisCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnalysisCallback(semi; interval=0,
                        save_analysis=false,
                        output_directory=&quot;out&quot;,
                        analysis_filename=&quot;analysis.dat&quot;,
                        extra_analysis_errors=Symbol[],
                        extra_analysis_integrals=())</code></pre><p>Analyze a numerical solution every <code>interval</code> time steps and print the results to the screen. If <code>save_analysis</code>, the results are also saved in <code>joinpath(output_directory, analysis_filename)</code>.</p><p>Additional errors can be computed, e.g. by passing <code>extra_analysis_errors = (:l2_error_primitive, :linf_error_primitive)</code> or <code>extra_analysis_errors = (:conservation_error,)</code>.</p><p>If you want to omit the computation (to safe compute-time) of the <a href="#Trixi.default_analysis_errors-Tuple{Trixi.AbstractEquations}"><code>default_analysis_errors</code></a>, specify <code>analysis_errors = Symbol[]</code>. Note: <code>default_analysis_errors</code> are <code>:l2_error</code> and <code>:linf_error</code> for all equations. If you want to compute <code>extra_analysis_errors</code> such as <code>:conservation_error</code> solely, i.e.,  without <code>:l2_error, :linf_error</code> you need to specify  <code>analysis_errors = [:conservation_error]</code> instead of <code>extra_analysis_errors = [:conservation_error]</code>.</p><p>Further scalar functions <code>func</code> in <code>extra_analysis_integrals</code> are applied to the numerical solution and integrated over the computational domain. Some examples for this are <a href="#Trixi.entropy"><code>entropy</code></a>, <a href="#Trixi.energy_kinetic"><code>energy_kinetic</code></a>, <a href="#Trixi.energy_internal"><code>energy_internal</code></a>, and <a href="#Trixi.energy_total"><code>energy_total</code></a>. You can also write your own function with the same signature as the examples listed above and pass it via <code>extra_analysis_integrals</code>. See the developer comments about <code>Trixi.analyze</code>, <code>Trixi.pretty_form_utf</code>, and <code>Trixi.pretty_form_ascii</code> for further information on how to create custom analysis quantities.</p><p>In addition, the analysis callback records and outputs a number of quantities that are useful for evaluating the computational performance, such as the total runtime, the performance index (time/DOF/rhs!), the time spent in garbage collection (GC), or the current memory usage (alloc&#39;d memory).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/analysis.jl#L10-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AnalysisCallbackCoupled" href="#Trixi.AnalysisCallbackCoupled"><code>Trixi.AnalysisCallbackCoupled</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnalysisCallbackCoupled(semi, callbacks...)</code></pre><p>Combine multiple analysis callbacks for coupled simulations with a <a href="#Trixi.SemidiscretizationCoupled"><code>SemidiscretizationCoupled</code></a>. For each coupled system, an indididual <a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> <strong>must</strong> be created and passed to the <code>AnalysisCallbackCoupled</code> <strong>in order</strong>, i.e., in the same sequence as the indidvidual semidiscretizations are stored in the <code>SemidiscretizationCoupled</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This is an experimental feature and can change any time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_coupled.jl#L189-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AnalysisSurfaceIntegral" href="#Trixi.AnalysisSurfaceIntegral"><code>Trixi.AnalysisSurfaceIntegral</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnalysisSurfaceIntegral{Semidiscretization, Variable}(semi,
                                                      boundary_symbol_or_boundary_symbols,
                                                      variable)</code></pre><p>This struct is used to compute the surface integral of a quantity of interest <code>variable</code> alongside the boundary/boundaries associated with particular name(s) given in <code>boundary_symbol</code> or <code>boundary_symbols</code>. For instance, this can be used to compute the lift <a href="#Trixi.LiftCoefficientPressure-NTuple{4, Any}"><code>LiftCoefficientPressure</code></a> or drag coefficient <a href="#Trixi.DragCoefficientPressure-NTuple{4, Any}"><code>DragCoefficientPressure</code></a> of e.g. an airfoil with the boundary name <code>:Airfoil</code> in 2D.</p><ul><li><code>semi::Semidiscretization</code>: Passed in to retrieve boundary condition information</li><li><code>boundary_symbol_or_boundary_symbols::Symbol|Vector{Symbol}</code>: Name(s) of the boundary/boundaries where the quantity of interest is computed</li><li><code>variable::Variable</code>: Quantity of interest, like lift or drag</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/analysis_surface_integral_2d.jl#L11-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.AveragingCallback" href="#Trixi.AveragingCallback"><code>Trixi.AveragingCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AveragingCallback(semi::SemidiscretizationHyperbolic, tspan; output_directory=&quot;out&quot;,
                  filename=&quot;averaging.h5&quot;)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This callback is experimental and may change in any future release.</p></div></div><p>A callback that averages the flow field described by <code>semi</code> which must be a semidiscretization of the compressible Euler equations in two dimensions. The callback records the mean velocity, mean speed of sound, mean density, and mean vorticity for each node over the time interval given by <code>tspan</code> and stores the results in an HDF5 file <code>filename</code> in the directory <code>output_directory</code>. Note that this callback does not support adaptive mesh refinement (<a href="#Trixi.AMRCallback"><code>AMRCallback</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/averaging.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.BoundaryConditionCoupled" href="#Trixi.BoundaryConditionCoupled"><code>Trixi.BoundaryConditionCoupled</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryConditionCoupled(other_semi_index, indices, uEltype, coupling_converter)</code></pre><p>Boundary condition to glue two meshes together. Solution values at the boundary of another mesh will be used as boundary values. This requires the use of <a href="#Trixi.SemidiscretizationCoupled"><code>SemidiscretizationCoupled</code></a>. The other mesh is specified by <code>other_semi_index</code>, which is the index of the mesh in the tuple of semidiscretizations.</p><p>Note that the elements and nodes of the two meshes at the coupled boundary must coincide. This is currently only implemented for <a href="#Trixi.StructuredMesh"><code>StructuredMesh</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>other_semi_index</code>: the index in <code>SemidiscretizationCoupled</code> of the semidiscretization                     from which the values are copied</li><li><code>indices::Tuple</code>: node/cell indices at the boundary of the mesh in the other                   semidiscretization. See examples below.</li><li><code>uEltype::Type</code>: element type of solution</li><li><code>coupling_converter::CouplingConverter</code>: function to call for converting the solution                                          state of one system to the other system</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Connect the left boundary of mesh 2 to our boundary such that our positive
# boundary direction will match the positive y direction of the other boundary
BoundaryConditionCoupled(2, (:begin, :i), Float64, fun)

# Connect the same two boundaries oppositely oriented
BoundaryConditionCoupled(2, (:begin, :i_backwards), Float64, fun)

# Using this as y_neg boundary will connect `our_cells[i, 1, j]` to `other_cells[j, end-i, end]`
BoundaryConditionCoupled(2, (:j, :i_backwards, :end), Float64, fun)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This is an experimental feature and can change any time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_coupled.jl#L386-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.BoundaryConditionDirichlet" href="#Trixi.BoundaryConditionDirichlet"><code>Trixi.BoundaryConditionDirichlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryConditionDirichlet(boundary_value_function)</code></pre><p>Create a Dirichlet boundary condition that uses the function <code>boundary_value_function</code> to specify the values at the boundary. This can be used to create a boundary condition that specifies exact boundary values by passing the exact solution of the equation. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as</p><pre><code class="language-julia hljs">boundary_value_function(x, t, equations)</code></pre><p>where <code>x</code> specifies the coordinates, <code>t</code> is the current time, and <code>equation</code> is the corresponding system of equations.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; BoundaryConditionDirichlet(initial_condition_convergence_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L144-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.BoundaryConditionNavierStokesWall" href="#Trixi.BoundaryConditionNavierStokesWall"><code>Trixi.BoundaryConditionNavierStokesWall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundaryConditionNavierStokesWall</code></pre><p>Creates a wall-type boundary conditions for the compressible Navier-Stokes equations. The fields <code>boundary_condition_velocity</code> and <code>boundary_condition_heat_flux</code> are intended to be boundary condition types such as the <code>NoSlip</code> velocity boundary condition and the <code>Adiabatic</code> or <code>Isothermal</code> heat boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.BoundaryConditionNeumann" href="#Trixi.BoundaryConditionNeumann"><code>Trixi.BoundaryConditionNeumann</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryConditionNeumann(boundary_normal_flux_function)</code></pre><p>Similar to <code>BoundaryConditionDirichlet</code>, but creates a Neumann boundary condition for parabolic equations that uses the function <code>boundary_normal_flux_function</code> to specify the values of the normal flux at the boundary. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as</p><pre><code class="language-julia hljs">boundary_normal_flux_function(x, t, equations)</code></pre><p>where <code>x</code> specifies the coordinates, <code>t</code> is the current time, and <code>equation</code> is the corresponding system of equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L207-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.BoundsCheckCallback" href="#Trixi.BoundsCheckCallback"><code>Trixi.BoundsCheckCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundsCheckCallback(; output_directory=&quot;out&quot;, save_errors=false, interval=1)</code></pre><p>Subcell limiting techniques with <a href="#Trixi.SubcellLimiterIDP"><code>SubcellLimiterIDP</code></a> are constructed to adhere certain local or global bounds. To make sure that these bounds are actually met, this callback calculates the maximum deviation from the bounds. The maximum deviation per applied bound is printed to the screen at the end of the simulation. For more insights, when setting <code>save_errors=true</code> the occurring errors are exported every <code>interval</code> time steps during the simulation. Then, the maximum deviations since the last export are saved in &quot;<code>output_directory</code>/deviations.txt&quot;. The <code>BoundsCheckCallback</code> has to be applied as a stage callback for the SSPRK time integration scheme.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For <code>SubcellLimiterIDP</code>, the solution is corrected in the a posteriori correction stage <a href="#Trixi.SubcellLimiterIDPCorrection"><code>SubcellLimiterIDPCorrection</code></a>. So, to check the final solution, this bounds check callback must be called after the correction stage.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_stage/subcell_bounds_check.jl#L8-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CarpenterKennedy2N43" href="#Trixi.CarpenterKennedy2N43"><code>Trixi.CarpenterKennedy2N43</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">  CarpenterKennedy2N43()</code></pre><p>Carpenter, Kennedy (1994) Third order 2N storage RK schemes with error control</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_2N.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CarpenterKennedy2N54" href="#Trixi.CarpenterKennedy2N54"><code>Trixi.CarpenterKennedy2N54</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CarpenterKennedy2N54()</code></pre><p>The following structures and methods provide a minimal implementation of the low-storage explicit Runge-Kutta method of</p><pre><code class="nohighlight hljs">Carpenter, Kennedy (1994) Fourth order 2N storage RK schemes, Solution 3</code></pre><p>using the same interface as OrdinaryDiffEq.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_2N.jl#L11-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleEulerEquations1D" href="#Trixi.CompressibleEulerEquations1D"><code>Trixi.CompressibleEulerEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerEquations1D(gamma)</code></pre><p>The compressible Euler equations</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho \\ \rho v_1 \\ \rho e
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
\rho v_1 \\ \rho v_1^2 + p \\ (\rho e +p) v_1
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>for an ideal gas with ratio of specific heats <code>gamma</code> in one space dimension. Here, <span>$\rho$</span> is the density, <span>$v_1$</span> the velocity, <span>$e$</span> the specific total energy <strong>rather than</strong> specific internal energy, and</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho v_1^2 \right)\]</p><p>the pressure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L8-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleEulerEquations2D" href="#Trixi.CompressibleEulerEquations2D"><code>Trixi.CompressibleEulerEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerEquations2D(gamma)</code></pre><p>The compressible Euler equations</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho \\ \rho v_1 \\ \rho v_2 \\ \rho e
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
 \rho v_1 \\ \rho v_1^2 + p \\ \rho v_1 v_2 \\ (\rho e +p) v_1
\end{pmatrix}
+
\frac{\partial}{\partial y}
\begin{pmatrix}
\rho v_2 \\ \rho v_1 v_2 \\ \rho v_2^2 + p \\ (\rho e +p) v_2
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>for an ideal gas with ratio of specific heats <code>gamma</code> in two space dimensions. Here, <span>$\rho$</span> is the density, <span>$v_1$</span>, <span>$v_2$</span> the velocities, <span>$e$</span> the specific total energy <strong>rather than</strong> specific internal energy, and</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho (v_1^2+v_2^2) \right)\]</p><p>the pressure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L8-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleEulerEquations3D" href="#Trixi.CompressibleEulerEquations3D"><code>Trixi.CompressibleEulerEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerEquations3D(gamma)</code></pre><p>The compressible Euler equations</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho \\ \rho v_1 \\ \rho v_2 \\ \rho v_3 \\  \rho e
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
 \rho v_1 \\ \rho v_1^2 + p \\ \rho v_1 v_2 \\ \rho v_1 v_3 \\ ( \rho e +p) v_1
\end{pmatrix}
+
\frac{\partial}{\partial y}
\begin{pmatrix}
\rho v_2 \\ \rho v_1 v_2 \\ \rho v_2^2 + p \\ \rho v_1 v_3 \\ ( \rho e +p) v_2
\end{pmatrix}
+
\frac{\partial}{\partial z}
\begin{pmatrix}
\rho v_3 \\ \rho v_1 v_3 \\ \rho v_2 v_3 \\ \rho v_3^2 + p \\ ( \rho e +p) v_3
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 0 \\ 0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>for an ideal gas with ratio of specific heats <code>gamma</code> in three space dimensions. Here, <span>$\rho$</span> is the density, <span>$v_1$</span>, <span>$v_2$</span>, <span>$v_3$</span> the velocities, <span>$e$</span> the specific total energy <strong>rather than</strong> specific internal energy, and</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho (v_1^2+v_2^2+v_3^2) \right)\]</p><p>the pressure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L8-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleEulerEquationsQuasi1D" href="#Trixi.CompressibleEulerEquationsQuasi1D"><code>Trixi.CompressibleEulerEquationsQuasi1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerEquationsQuasi1D(gamma)</code></pre><p>The quasi-1d compressible Euler equations (see Chan et al.  <a href="https://doi.org/10.48550/arXiv.2307.12089">DOI: 10.48550/arXiv.2307.12089</a>  for details)</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
a \rho \\ a \rho v_1 \\ a e
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
a \rho v_1 \\ a \rho v_1^2 \\ a v_1 (e +p)
\end{pmatrix}
+ 
a \frac{\partial}{\partial x}
\begin{pmatrix}
0 \\ p \\ 0    
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>for an ideal gas with ratio of specific heats <code>gamma</code> in one space dimension. Here, <span>$\rho$</span> is the density, <span>$v_1$</span> the velocity, <span>$e$</span> the specific total energy <strong>rather than</strong> specific internal energy,  <span>$a$</span> the (possibly) variable nozzle width, and</p><p class="math-container">\[p = (\gamma - 1) \left( e - \frac{1}{2} \rho v_1^2 \right)\]</p><p>the pressure.</p><p>The nozzle width function <span>$a(x)$</span> is set inside the initial condition routine for a particular problem setup. To test the conservative form of the compressible Euler equations one can set the  nozzle width variable <span>$a$</span> to one. </p><p>In addition to the unknowns, Trixi.jl currently stores the nozzle width values at the approximation points  despite being fixed in time. This affects the implementation and use of these equations in various ways:</p><ul><li>The flux values corresponding to the nozzle width must be zero.</li><li>The nozzle width values must be included when defining initial conditions, boundary conditions or source terms.</li><li><a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> analyzes this variable.</li><li>Trixi.jl&#39;s visualization tools will visualize the nozzle width by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_quasi_1d.jl#L8-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleEulerMulticomponentEquations1D" href="#Trixi.CompressibleEulerMulticomponentEquations1D"><code>Trixi.CompressibleEulerMulticomponentEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerMulticomponentEquations1D(; gammas, gas_constants)</code></pre><p>Multicomponent version of the compressible Euler equations</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho v_1 \\ \rho e \\ \rho_1 \\ \rho_2 \\ \vdots \\ \rho_{n}
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
\rho v_1^2 + p \\ (\rho e +p) v_1 \\ \rho_1 v_1 \\ \rho_2 v_1 \\ \vdots \\ \rho_{n} v_1
\end{pmatrix}

=
\begin{pmatrix}
0 \\ 0 \\ 0 \\ 0 \\ \vdots \\ 0
\end{pmatrix}\]</p><p>for calorically perfect gas in one space dimension. Here, <span>$\rho_i$</span> is the density of component <span>$i$</span>, <span>$\rho=\sum_{i=1}^n\rho_i$</span> the sum of the individual <span>$\rho_i$</span>, <span>$v_1$</span> the velocity, <span>$e$</span> the specific total energy <strong>rather than</strong> specific internal energy, and</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho v_1^2 \right)\]</p><p>the pressure,</p><p class="math-container">\[\gamma=\frac{\sum_{i=1}^n\rho_i C_{v,i}\gamma_i}{\sum_{i=1}^n\rho_i C_{v,i}}\]</p><p>total heat capacity ratio, <span>$\gamma_i$</span> heat capacity ratio of component <span>$i$</span>,</p><p class="math-container">\[C_{v,i}=\frac{R}{\gamma_i-1}\]</p><p>specific heat capacity at constant volume of component <span>$i$</span>.</p><p>In case of more than one component, the specific heat ratios <code>gammas</code> and the gas constants <code>gas_constants</code> should be passed as tuples, e.g., <code>gammas=(1.4, 1.667)</code>.</p><p>The remaining variables like the specific heats at constant volume <code>cv</code> or the specific heats at constant pressure <code>cp</code> are then calculated considering a calorically perfect gas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_1d.jl#L8-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleEulerMulticomponentEquations2D" href="#Trixi.CompressibleEulerMulticomponentEquations2D"><code>Trixi.CompressibleEulerMulticomponentEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerMulticomponentEquations2D(; gammas, gas_constants)</code></pre><p>Multicomponent version of the compressible Euler equations</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho v_1 \\ \rho v_2 \\ \rho e \\ \rho_1 \\ \rho_2 \\ \vdots \\ \rho_{n}
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
\rho v_1^2 + p \\ \rho v_1 v_2 \\ ( \rho e +p) v_1 \\ \rho_1 v_1 \\ \rho_2 v_1 \\ \vdots \\ \rho_{n} v_1
\end{pmatrix}
+
\frac{\partial}{\partial y}
\begin{pmatrix}
\rho v_1 v_2 \\ \rho v_2^2 + p \\ ( \rho e +p) v_2 \\ \rho_1 v_2 \\ \rho_2 v_2 \\ \vdots \\ \rho_{n} v_2
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \vdots \\ 0
\end{pmatrix}\]</p><p>for calorically perfect gas in two space dimensions. Here, <span>$\rho_i$</span> is the density of component <span>$i$</span>, <span>$\rho=\sum_{i=1}^n\rho_i$</span> the sum of the individual <span>$\rho_i$</span>, <span>$v_1$</span>, <span>$v_2$</span> the velocities, <span>$e$</span> the specific total energy <strong>rather than</strong> specific internal energy, and</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho (v_1^2 + v_2^2) \right)\]</p><p>the pressure,</p><p class="math-container">\[\gamma=\frac{\sum_{i=1}^n\rho_i C_{v,i}\gamma_i}{\sum_{i=1}^n\rho_i C_{v,i}}\]</p><p>total heat capacity ratio, <span>$\gamma_i$</span> heat capacity ratio of component <span>$i$</span>,</p><p class="math-container">\[C_{v,i}=\frac{R}{\gamma_i-1}\]</p><p>specific heat capacity at constant volume of component <span>$i$</span>.</p><p>In case of more than one component, the specific heat ratios <code>gammas</code> and the gas constants <code>gas_constants</code> in [kJ/(kg*K)] should be passed as tuples, e.g., <code>gammas=(1.4, 1.667)</code>.</p><p>The remaining variables like the specific heats at constant volume <code>cv</code> or the specific heats at constant pressure <code>cp</code> are then calculated considering a calorically perfect gas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_2d.jl#L8-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleNavierStokesDiffusion1D" href="#Trixi.CompressibleNavierStokesDiffusion1D"><code>Trixi.CompressibleNavierStokesDiffusion1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleNavierStokesDiffusion1D(equations; mu, Pr,
                                    gradient_variables=GradientVariablesPrimitive())</code></pre><p>Contains the diffusion (i.e. parabolic) terms applied to mass, momenta, and total energy together with the advective terms from the <a href="#Trixi.CompressibleEulerEquations1D"><code>CompressibleEulerEquations1D</code></a>.</p><ul><li><code>equations</code>: instance of the <a href="#Trixi.CompressibleEulerEquations1D"><code>CompressibleEulerEquations1D</code></a></li><li><code>mu</code>: dynamic viscosity,</li><li><code>Pr</code>: Prandtl number,</li><li><code>gradient_variables</code>: which variables the gradients are taken with respect to.                       Defaults to <code>GradientVariablesPrimitive()</code>.</li></ul><p>Fluid properties such as the dynamic viscosity <span>$\mu$</span> can be provided in any consistent unit system, e.g., [<span>$\mu$</span>] = kg m⁻¹ s⁻¹. The viscosity <span>$\mu$</span> may be a constant or a function of the current state, e.g.,  depending on temperature (Sutherland&#39;s law): <span>$\mu = \mu(T)$</span>. In the latter case, the function <code>mu</code> needs to have the signature <code>mu(u, equations)</code>.</p><p>The particular form of the compressible Navier-Stokes implemented is</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho \\ \rho v \\ \rho e
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
 \rho v \\ \rho v^2 + p \\ (\rho e + p) v
\end{pmatrix}
=
\frac{\partial}{\partial x}
\begin{pmatrix}
0 \\ \tau \\ \tau v - q
\end{pmatrix}\]</p><p>where the system is closed with the ideal gas assumption giving</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho v^2 \right)\]</p><p>as the pressure. The value of the adiabatic constant <code>gamma</code> is taken from the <a href="#Trixi.CompressibleEulerEquations1D"><code>CompressibleEulerEquations1D</code></a>. The terms on the right hand side of the system above are built from the viscous stress</p><p class="math-container">\[\tau = \mu \frac{\partial}{\partial x} v\]</p><p>where the heat flux is</p><p class="math-container">\[q = -\kappa \frac{\partial}{\partial x} \left(T\right),\quad T = \frac{p}{R\rho}\]</p><p>where <span>$T$</span> is the temperature and <span>$\kappa$</span> is the thermal conductivity for Fick&#39;s law. Under the assumption that the gas has a constant Prandtl number, the thermal conductivity is</p><p class="math-container">\[\kappa = \frac{\gamma \mu R}{(\gamma - 1)\textrm{Pr}}.\]</p><p>From this combination of temperature <span>$T$</span> and thermal conductivity <span>$\kappa$</span> we see that the gas constant <code>R</code> cancels and the heat flux becomes</p><p class="math-container">\[q = -\kappa \frac{\partial}{\partial x} \left(T\right) = -\frac{\gamma \mu}{(\gamma - 1)\textrm{Pr}} \frac{\partial}{\partial x} \left(\frac{p}{\rho}\right)\]</p><p>which is the form implemented below in the <a href="#Trixi.flux"><code>flux</code></a> function.</p><p>In one spatial dimensions we require gradients for two quantities, e.g., primitive quantities</p><p class="math-container">\[\frac{\partial}{\partial x} v,\, \frac{\partial}{\partial x} T\]</p><p>or the entropy variables</p><p class="math-container">\[\frac{\partial}{\partial x} w_2,\, \frac{\partial}{\partial x} w_3\]</p><p>where</p><p class="math-container">\[w_2 = \frac{\rho v1}{p},\, w_3 = -\frac{\rho}{p}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes_1d.jl#L8-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleNavierStokesDiffusion2D" href="#Trixi.CompressibleNavierStokesDiffusion2D"><code>Trixi.CompressibleNavierStokesDiffusion2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleNavierStokesDiffusion2D(equations; mu, Pr,
                                    gradient_variables=GradientVariablesPrimitive())</code></pre><p>Contains the diffusion (i.e. parabolic) terms applied to mass, momenta, and total energy together with the advective terms from the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a>.</p><ul><li><code>equations</code>: instance of the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a></li><li><code>mu</code>: dynamic viscosity,</li><li><code>Pr</code>: Prandtl number,</li><li><code>gradient_variables</code>: which variables the gradients are taken with respect to.                       Defaults to <code>GradientVariablesPrimitive()</code>.</li></ul><p>Fluid properties such as the dynamic viscosity <span>$\mu$</span> can be provided in any consistent unit system, e.g., [<span>$\mu$</span>] = kg m⁻¹ s⁻¹. The viscosity <span>$\mu$</span> may be a constant or a function of the current state, e.g.,  depending on temperature (Sutherland&#39;s law): <span>$\mu = \mu(T)$</span>. In the latter case, the function <code>mu</code> needs to have the signature <code>mu(u, equations)</code>.</p><p>The particular form of the compressible Navier-Stokes implemented is</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho \\ \rho \mathbf{v} \\ \rho e
\end{pmatrix}
+
\nabla \cdot
\begin{pmatrix}
 \rho \mathbf{v} \\ \rho \mathbf{v}\mathbf{v}^T + p \underline{I} \\ (\rho e + p) \mathbf{v}
\end{pmatrix}
=
\nabla \cdot
\begin{pmatrix}
0 \\ \underline{\tau} \\ \underline{\tau}\mathbf{v} - \mathbf{q}
\end{pmatrix}\]</p><p>where the system is closed with the ideal gas assumption giving</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho (v_1^2+v_2^2) \right)\]</p><p>as the pressure. The value of the adiabatic constant <code>gamma</code> is taken from the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a>. The terms on the right hand side of the system above are built from the viscous stress tensor</p><p class="math-container">\[\underline{\tau} = \mu \left(\nabla\mathbf{v} + \left(\nabla\mathbf{v}\right)^T\right) - \frac{2}{3} \mu \left(\nabla\cdot\mathbf{v}\right)\underline{I}\]</p><p>where <span>$\underline{I}$</span> is the <span>$2\times 2$</span> identity matrix and the heat flux is</p><p class="math-container">\[\mathbf{q} = -\kappa\nabla\left(T\right),\quad T = \frac{p}{R\rho}\]</p><p>where <span>$T$</span> is the temperature and <span>$\kappa$</span> is the thermal conductivity for Fick&#39;s law. Under the assumption that the gas has a constant Prandtl number, the thermal conductivity is</p><p class="math-container">\[\kappa = \frac{\gamma \mu R}{(\gamma - 1)\textrm{Pr}}.\]</p><p>From this combination of temperature <span>$T$</span> and thermal conductivity <span>$\kappa$</span> we see that the gas constant <code>R</code> cancels and the heat flux becomes</p><p class="math-container">\[\mathbf{q} = -\kappa\nabla\left(T\right) = -\frac{\gamma \mu}{(\gamma - 1)\textrm{Pr}}\nabla\left(\frac{p}{\rho}\right)\]</p><p>which is the form implemented below in the <a href="#Trixi.flux"><code>flux</code></a> function.</p><p>In two spatial dimensions we require gradients for three quantities, e.g., primitive quantities</p><p class="math-container">\[\nabla v_1,\, \nabla v_2,\, \nabla T\]</p><p>or the entropy variables</p><p class="math-container">\[\nabla w_2,\, \nabla w_3,\, \nabla w_4\]</p><p>where</p><p class="math-container">\[w_2 = \frac{\rho v_1}{p},\, w_3 = \frac{\rho v_2}{p},\, w_4 = -\frac{\rho}{p}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes_2d.jl#L8-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.CompressibleNavierStokesDiffusion3D" href="#Trixi.CompressibleNavierStokesDiffusion3D"><code>Trixi.CompressibleNavierStokesDiffusion3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleNavierStokesDiffusion3D(equations; mu, Pr,
                                    gradient_variables=GradientVariablesPrimitive())</code></pre><p>Contains the diffusion (i.e. parabolic) terms applied to mass, momenta, and total energy together with the advective terms from the <a href="#Trixi.CompressibleEulerEquations3D"><code>CompressibleEulerEquations3D</code></a>.</p><ul><li><code>equations</code>: instance of the <a href="#Trixi.CompressibleEulerEquations3D"><code>CompressibleEulerEquations3D</code></a></li><li><code>mu</code>: dynamic viscosity,</li><li><code>Pr</code>: Prandtl number,</li><li><code>gradient_variables</code>: which variables the gradients are taken with respect to.                       Defaults to <code>GradientVariablesPrimitive()</code>.</li></ul><p>Fluid properties such as the dynamic viscosity <span>$\mu$</span> can be provided in any consistent unit system, e.g., [<span>$\mu$</span>] = kg m⁻¹ s⁻¹. The viscosity <span>$\mu$</span> may be a constant or a function of the current state, e.g.,  depending on temperature (Sutherland&#39;s law): <span>$\mu = \mu(T)$</span>. In the latter case, the function <code>mu</code> needs to have the signature <code>mu(u, equations)</code>.</p><p>The particular form of the compressible Navier-Stokes implemented is</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho \\ \rho \mathbf{v} \\ \rho e
\end{pmatrix}
+
\nabla \cdot
\begin{pmatrix}
 \rho \mathbf{v} \\ \rho \mathbf{v}\mathbf{v}^T + p \underline{I} \\ (\rho e + p) \mathbf{v}
\end{pmatrix}
=
\nabla \cdot
\begin{pmatrix}
0 \\ \underline{\tau} \\ \underline{\tau}\mathbf{v} - \mathbf{q}
\end{pmatrix}\]</p><p>where the system is closed with the ideal gas assumption giving</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho (v_1^2+v_2^2+v_3^2) \right)\]</p><p>as the pressure. The value of the adiabatic constant <code>gamma</code> is taken from the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a>. The terms on the right hand side of the system above are built from the viscous stress tensor</p><p class="math-container">\[\underline{\tau} = \mu \left(\nabla\mathbf{v} + \left(\nabla\mathbf{v}\right)^T\right) - \frac{2}{3} \mu \left(\nabla\cdot\mathbf{v}\right)\underline{I}\]</p><p>where <span>$\underline{I}$</span> is the <span>$3\times 3$</span> identity matrix and the heat flux is</p><p class="math-container">\[\mathbf{q} = -\kappa\nabla\left(T\right),\quad T = \frac{p}{R\rho}\]</p><p>where <span>$T$</span> is the temperature and <span>$\kappa$</span> is the thermal conductivity for Fick&#39;s law. Under the assumption that the gas has a constant Prandtl number, the thermal conductivity is</p><p class="math-container">\[\kappa = \frac{\gamma \mu R}{(\gamma - 1)\textrm{Pr}}.\]</p><p>From this combination of temperature <span>$T$</span> and thermal conductivity <span>$\kappa$</span> we see that the gas constant <code>R</code> cancels and the heat flux becomes</p><p class="math-container">\[\mathbf{q} = -\kappa\nabla\left(T\right) = -\frac{\gamma \mu}{(\gamma - 1)\textrm{Pr}}\nabla\left(\frac{p}{\rho}\right)\]</p><p>which is the form implemented below in the <a href="#Trixi.flux"><code>flux</code></a> function.</p><p>In two spatial dimensions we require gradients for three quantities, e.g., primitive quantities</p><p class="math-container">\[\nabla v_1,\, \nabla v_2,\, \nabla v_3,\, \nabla T\]</p><p>or the entropy variables</p><p class="math-container">\[\nabla w_2,\, \nabla w_3,\, \nabla w_4\, \nabla w_5\]</p><p>where</p><p class="math-container">\[w_2 = \frac{\rho v_1}{p},\, w_3 = \frac{\rho v_2}{p},\, w_4 = \frac{\rho v_3}{p},\, w_5 = -\frac{\rho}{p}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes_3d.jl#L8-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ControllerThreeLevel" href="#Trixi.ControllerThreeLevel"><code>Trixi.ControllerThreeLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ControllerThreeLevel(semi, indicator; base_level=1,
                                      med_level=base_level, med_threshold=0.0,
                                      max_level=base_level, max_threshold=1.0)</code></pre><p>An AMR controller based on three levels (in descending order of precedence):</p><ul><li>set the target level to <code>max_level</code> if <code>indicator &gt; max_threshold</code></li><li>set the target level to <code>med_level</code> if <code>indicator &gt; med_threshold</code>; if <code>med_level &lt; 0</code>, set the target level to the current level</li><li>set the target level to <code>base_level</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/amr.jl#L831-L841">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ControllerThreeLevelCombined" href="#Trixi.ControllerThreeLevelCombined"><code>Trixi.ControllerThreeLevelCombined</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ControllerThreeLevelCombined(semi, indicator_primary, indicator_secondary;
                             base_level=1,
                             med_level=base_level, med_threshold=0.0,
                             max_level=base_level, max_threshold=1.0,
                             max_threshold_secondary=1.0)</code></pre><p>An AMR controller based on three levels (in descending order of precedence):</p><ul><li>set the target level to <code>max_level</code> if <code>indicator_primary &gt; max_threshold</code></li><li>set the target level to <code>med_level</code> if <code>indicator_primary &gt; med_threshold</code>; if <code>med_level &lt; 0</code>, set the target level to the current level</li><li>set the target level to <code>base_level</code> otherwise</li></ul><p>If <code>indicator_secondary &gt;= max_threshold_secondary</code>, set the target level to <code>max_level</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/amr.jl#L1009-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DG" href="#Trixi.DG"><code>Trixi.DG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DG(; basis, mortar, surface_integral, volume_integral)</code></pre><p>Create a discontinuous Galerkin method. If <a href="#Trixi.LobattoLegendreBasis"><code>basis isa LobattoLegendreBasis</code></a>, this creates a <a href="#Trixi.DGSEM"><code>DGSEM</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L381-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMulti-Tuple{SummationByPartsOperators.AbstractDerivativeOperator}" href="#Trixi.DGMulti-Tuple{SummationByPartsOperators.AbstractDerivativeOperator}"><code>Trixi.DGMulti</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMulti(approximation_type::AbstractDerivativeOperator;
        element_type::AbstractElemShape,
        surface_flux=flux_central,
        surface_integral=SurfaceIntegralWeakForm(surface_flux),
        volume_integral=VolumeIntegralWeakForm(),
        kwargs...)</code></pre><p>Create a summation by parts (SBP) discretization on the given <code>element_type</code> using a tensor product structure based on the 1D SBP derivative operator passed as <code>approximation_type</code>.</p><p>For more info, see the documentations of <a href="https://jlchan.github.io/StartUpDG.jl/dev/">StartUpDG.jl</a> and <a href="https://ranocha.de/SummationByPartsOperators.jl/stable/">SummationByPartsOperators.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/sbp.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMulti-Tuple{}" href="#Trixi.DGMulti-Tuple{}"><code>Trixi.DGMulti</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMulti(; polydeg::Integer,
          element_type::AbstractElemShape,
          approximation_type=Polynomial(),
          surface_flux=flux_central,
          surface_integral=SurfaceIntegralWeakForm(surface_flux),
          volume_integral=VolumeIntegralWeakForm(),
          RefElemData_kwargs...)</code></pre><p>Create a discontinuous Galerkin method which uses</p><ul><li>approximations of polynomial degree <code>polydeg</code></li><li>element type <code>element_type</code> (<code>Tri()</code>, <code>Quad()</code>, <code>Tet()</code>, and <code>Hex()</code> currently supported)</li></ul><p>Optional:</p><ul><li><code>approximation_type</code> (default is <code>Polynomial()</code>; <code>SBP()</code> also supported for <code>Tri()</code>, <code>Quad()</code>, and <code>Hex()</code> element types).</li><li><code>RefElemData_kwargs</code> are additional keyword arguments for <code>RefElemData</code>, such as <code>quad_rule_vol</code>. For more info, see the <a href="https://jlchan.github.io/StartUpDG.jl/dev/">StartUpDG.jl docs</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/types.jl#L64-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiMesh" href="#Trixi.DGMultiMesh"><code>Trixi.DGMultiMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DGMultiMesh{NDIMS, ...}</code></pre><p><code>DGMultiMesh</code> describes a mesh type which wraps <code>StartUpDG.MeshData</code> and <code>boundary_faces</code> in a dispatchable type. This is intended to store geometric data and connectivities for any type of mesh (Cartesian, affine, curved, structured/unstructured).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/dgmulti_meshes.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiMesh-Tuple{DGMulti{2, Tri, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{2, Tri, ApproxType}} where {ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, Dict{Symbol, Int64}}" href="#Trixi.DGMultiMesh-Tuple{DGMulti{2, Tri, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{2, Tri, ApproxType}} where {ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, Dict{Symbol, Int64}}"><code>Trixi.DGMultiMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMultiMesh(dg::DGMulti{2, Tri}, triangulateIO, boundary_dict::Dict{Symbol, Int})</code></pre><ul><li><code>dg::DGMulti</code> contains information associated with to the reference element (e.g., quadrature, basis evaluation, differentiation, etc).</li><li><code>triangulateIO</code> is a <code>TriangulateIO</code> mesh representation</li><li><code>boundary_dict</code> is a <code>Dict{Symbol, Int}</code> which associates each integer <code>TriangulateIO</code> boundary tag with a <code>Symbol</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/types.jl#L205-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiMesh-Union{Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType&lt;:SummationByPartsOperators.AbstractPeriodicDerivativeOperator, SurfaceIntegral, VolumeIntegral, Mortar}}, Tuple{NDIMS}} where NDIMS" href="#Trixi.DGMultiMesh-Union{Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType&lt;:SummationByPartsOperators.AbstractPeriodicDerivativeOperator, SurfaceIntegral, VolumeIntegral, Mortar}}, Tuple{NDIMS}} where NDIMS"><code>Trixi.DGMultiMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMultiMesh(dg::DGMulti)</code></pre><p>Constructs a single-element <a href="#Trixi.DGMultiMesh"><code>DGMultiMesh</code></a> for a single periodic element given a DGMulti with <code>approximation_type</code> set to a periodic (finite difference) SBP operator from SummationByPartsOperators.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/sbp.jl#L66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, AbstractArray}} where NDIMS" href="#Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, AbstractArray}} where NDIMS"><code>Trixi.DGMultiMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMultiMesh(dg::DGMulti{NDIMS}, vertex_coordinates, EToV;
            is_on_boundary=nothing,
            periodicity=ntuple(_-&gt;false, NDIMS)) where {NDIMS}</code></pre><ul><li><code>dg::DGMulti</code> contains information associated with to the reference element (e.g., quadrature, basis evaluation, differentiation, etc).</li><li><code>vertex_coordinates</code> is a tuple of vectors containing x,y,... components of the vertex coordinates</li><li><code>EToV</code> is a 2D array containing element-to-vertex connectivities for each element</li><li><code>is_on_boundary</code> specifies boundary using a <code>Dict{Symbol, &lt;:Function}</code></li><li><code>periodicity</code> is a tuple of booleans specifying if the domain is periodic <code>true</code>/<code>false</code> in the (x,y,z) direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/types.jl#L179-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, Any}} where NDIMS" href="#Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, Any}} where NDIMS"><code>Trixi.DGMultiMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMultiMesh(dg::DGMulti{NDIMS}, cells_per_dimension, mapping;
            is_on_boundary=nothing,
            periodicity=ntuple(_ -&gt; false, NDIMS), kwargs...) where {NDIMS}</code></pre><p>Constructs a <code>Curved()</code> <a href="#Trixi.DGMultiMesh"><code>DGMultiMesh</code></a> with element type <code>dg.basis.element_type</code>.</p><ul><li><code>mapping</code> is a function which maps from a reference [-1, 1]^NDIMS domain to a mapped domain,  e.g., <code>xy = mapping(x, y)</code> in 2D.</li><li><code>is_on_boundary</code> specifies boundary using a <code>Dict{Symbol, &lt;:Function}</code></li><li><code>periodicity</code> is a tuple of <code>Bool</code>s specifying periodicity = <code>true</code>/<code>false</code> in the (x,y,z) direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/types.jl#L260-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any}} where NDIMS" href="#Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any}} where NDIMS"><code>Trixi.DGMultiMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMultiMesh(dg::DGMulti, cells_per_dimension;
            coordinates_min=(-1.0, -1.0), coordinates_max=(1.0, 1.0),
            is_on_boundary=nothing,
            periodicity=ntuple(_ -&gt; false, NDIMS))</code></pre><p>Constructs a Cartesian <a href="#Trixi.DGMultiMesh"><code>DGMultiMesh</code></a> with element type <code>dg.basis.element_type</code>. The domain is the tensor product of the intervals <code>[coordinates_min[i], coordinates_max[i]]</code>.</p><ul><li><code>is_on_boundary</code> specifies boundary using a <code>Dict{Symbol, &lt;:Function}</code></li><li><code>periodicity</code> is a tuple of <code>Bool</code>s specifying periodicity = <code>true</code>/<code>false</code> in the (x,y,z) direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/types.jl#L225-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, String}} where NDIMS" href="#Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, &lt;:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, String}} where NDIMS"><code>Trixi.DGMultiMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMultiMesh(dg::DGMulti, filename::String)</code></pre><ul><li><code>dg::DGMulti</code> contains information associated with the reference element (e.g., quadrature, basis evaluation, differentiation, etc).</li><li><code>filename</code> is a path specifying a <code>.mesh</code> file generated by <a href="https://github.com/trixi-framework/HOHQMesh">HOHQMesh</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/types.jl#L291-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGSEM" href="#Trixi.DGSEM"><code>Trixi.DGSEM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DGSEM(; RealT=Float64, polydeg::Integer,
        surface_flux=flux_central,
        surface_integral=SurfaceIntegralWeakForm(surface_flux),
        volume_integral=VolumeIntegralWeakForm(),
        mortar=MortarL2(basis))</code></pre><p>Create a discontinuous Galerkin spectral element method (DGSEM) using a <a href="#Trixi.LobattoLegendreBasis"><code>LobattoLegendreBasis</code></a> with polynomials of degree <code>polydeg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/dgsem.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DissipationGlobalLaxFriedrichs" href="#Trixi.DissipationGlobalLaxFriedrichs"><code>Trixi.DissipationGlobalLaxFriedrichs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DissipationGlobalLaxFriedrichs(λ)</code></pre><p>Create a global Lax-Friedrichs dissipation operator with dissipation coefficient <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DissipationLocalLaxFriedrichs" href="#Trixi.DissipationLocalLaxFriedrichs"><code>Trixi.DissipationLocalLaxFriedrichs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DissipationLocalLaxFriedrichs(max_abs_speed=max_abs_speed_naive)</code></pre><p>Create a local Lax-Friedrichs dissipation operator where the maximum absolute wave speed is estimated as <code>max_abs_speed(u_ll, u_rr, orientation_or_normal_direction, equations)</code>, defaulting to <a href="#Trixi.max_abs_speed_naive"><code>max_abs_speed_naive</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L156-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DragCoefficientPressure-NTuple{4, Any}" href="#Trixi.DragCoefficientPressure-NTuple{4, Any}"><code>Trixi.DragCoefficientPressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DragCoefficientPressure(aoa, rhoinf, uinf, linf)</code></pre><p>Compute the drag coefficient</p><p class="math-container">\[C_{D,p} \coloneqq \frac{\oint_{\partial \Omega} p \boldsymbol n \cdot \psi_D \, \mathrm{d} S}
                        {0.5 \rho_{\infty} U_{\infty}^2 L_{\infty}}\]</p><p>based on the pressure distribution along a boundary. Supposed to be used in conjunction with <a href="#Trixi.AnalysisSurfaceIntegral"><code>AnalysisSurfaceIntegral</code></a> which stores the boundary information and semidiscretization.</p><ul><li><code>aoa::Real</code>: Angle of attack in radians (for airfoils etc.)</li><li><code>rhoinf::Real</code>: Free-stream density</li><li><code>uinf::Real</code>: Free-stream velocity</li><li><code>linf::Real</code>: Reference length of geometry (e.g. airfoil chord length)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/analysis_surface_integral_2d.jl#L105-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DragCoefficientShearStress-NTuple{4, Any}" href="#Trixi.DragCoefficientShearStress-NTuple{4, Any}"><code>Trixi.DragCoefficientShearStress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DragCoefficientShearStress(aoa, rhoinf, uinf, linf)</code></pre><p>Compute the drag coefficient</p><p class="math-container">\[C_{D,f} \coloneqq \frac{\oint_{\partial \Omega} \boldsymbol \tau_w \cdot \psi_D \, \mathrm{d} S}
                        {0.5 \rho_{\infty} U_{\infty}^2 L_{\infty}}\]</p><p>based on the wall shear stress vector <span>$\tau_w$</span> along a boundary. Supposed to be used in conjunction with <a href="#Trixi.AnalysisSurfaceIntegral"><code>AnalysisSurfaceIntegral</code></a> which stores the boundary information and semidiscretization.</p><ul><li><code>aoa::Real</code>: Angle of attack in radians (for airfoils etc.)</li><li><code>rhoinf::Real</code>: Free-stream density</li><li><code>uinf::Real</code>: Free-stream velocity</li><li><code>linf::Real</code>: Reference length of geometry (e.g. airfoil chord length)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/analysis_surface_integral_2d.jl#L155-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.EulerAcousticsCouplingCallback" href="#Trixi.EulerAcousticsCouplingCallback"><code>Trixi.EulerAcousticsCouplingCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EulerAcousticsCouplingCallback</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This callback is experimental and may change in any future release.</p></div></div><p>A callback that couples the acoustic perturbation equations and compressible Euler equations. Must be used in conjunction with <a href="#Trixi.SemidiscretizationEulerAcoustics"><code>SemidiscretizationEulerAcoustics</code></a>. This callback manages the flow solver - which is always one time step ahead of the acoustics solver - and calculates the acoustic source term after each time step. The linearized Lamb vector is used as the source term, i.e.</p><p class="math-container">\[\mathbf{s} = -(\mathbf{\omega&#39;} \times \bar{\mathbf{v}}
  + \bar{\mathbf{\omega}} \times \mathbf{v&#39;}),\]</p><p>where <span>$\mathbf{v}$</span> denotes the velocity, <span>$\mathbf{\omega}$</span> denotes the vorticity, the bar <span>$\bar{(\cdot)}$</span> indicates time-averaged quantities (see <a href="#Trixi.AveragingCallback"><code>AveragingCallback</code></a>) and prime <span>$(\cdot)&#39;$</span> denotes perturbed quantities defined by <span>$\phi&#39; = \phi - \bar{\phi}$</span>. Note that the perturbed quantities here are based entirely on the pure flow solution and should not be confused with the state variables of the acoustic perturbation equations.</p><p>In addition, this callback manages the time step size for both solvers and initializes the mean values of the acoustic perturbation equations using results obtained with the <a href="#Trixi.AveragingCallback"><code>AveragingCallback</code></a>.</p><ul><li>Michael Schlottke-Lakemper (2017) A direct-hybrid method for aeroacoustic analysis <a href="https://doi.org/10.18154/RWTH-2017-04082">DOI: 10.18154/RWTH-2017-04082</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/euler_acoustics_coupling.jl#L8-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.EulerAcousticsCouplingCallback-Tuple{Any, AbstractString, Any, Real, Real}" href="#Trixi.EulerAcousticsCouplingCallback-Tuple{Any, AbstractString, Any, Real, Real}"><code>Trixi.EulerAcousticsCouplingCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EulerAcousticsCouplingCallback(ode_euler, averaging_file::AbstractString, alg,
                               cfl_acoustics::Real, cfl_euler::Real; kwargs...)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This callback is experimental and may change in any future release.</p></div></div><p>Creates an <a href="#Trixi.EulerAcousticsCouplingCallback"><code>EulerAcousticsCouplingCallback</code></a> based on the pure flow <code>ODEProblem</code> given by <code>ode_euler</code>. Creates an integrator using the time integration method <code>alg</code> and the keyword arguments to solve <code>ode_euler</code> (consult the <a href="https://diffeq.sciml.ai/stable/">OrdinaryDiffEq documentation</a> for further information). Manages the step size for both solvers by using the minimum of the maximum step size obtained with CFL numbers <code>cfl_acoustics</code> for the acoustics solver and <code>cfl_euler</code> for and flow solver, respectively. The mean values for the acoustic perturbation equations are read from <code>averaging_file</code> (see <a href="#Trixi.AveragingCallback"><code>AveragingCallback</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/euler_acoustics_coupling.jl#L98-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.EulerAcousticsCouplingCallback-Tuple{Any, DiscreteCallback{&lt;:Any, &lt;:AveragingCallback}, Any, Real, Real}" href="#Trixi.EulerAcousticsCouplingCallback-Tuple{Any, DiscreteCallback{&lt;:Any, &lt;:AveragingCallback}, Any, Real, Real}"><code>Trixi.EulerAcousticsCouplingCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EulerAcousticsCouplingCallback(ode_euler,
                               averaging_callback::DiscreteCallback{&lt;:Any, &lt;:AveragingCallback},
                               alg, cfl_acoustics::Real, cfl_euler::Real; kwargs...)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This callback is experimental and may change in any future release.</p></div></div><p>Creates an <a href="#Trixi.EulerAcousticsCouplingCallback"><code>EulerAcousticsCouplingCallback</code></a> based on the pure flow <code>ODEProblem</code> given by <code>ode_euler</code>. Creates an integrator using the time integration method <code>alg</code> and the keyword arguments to solve <code>ode_euler</code> (consult the <a href="https://diffeq.sciml.ai/stable/">OrdinaryDiffEq documentation</a> for further information). Manages the step size for both solvers by using the minimum of the maximum step size obtained with CFL numbers <code>cfl_acoustics</code> for the acoustics solver and <code>cfl_euler</code> for and flow solver, respectively. The mean values for the acoustic perturbation equations are read from <code>averaging_callback</code> (see <a href="#Trixi.AveragingCallback"><code>AveragingCallback</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/euler_acoustics_coupling.jl#L68-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FDSBP" href="#Trixi.FDSBP"><code>Trixi.FDSBP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FDSBP(D_SBP; surface_integral, volume_integral)</code></pre><p>Specialization of <a href="#Trixi.DG"><code>DG</code></a> methods that uses general summation by parts (SBP) operators from <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a>. In particular, this includes classical finite difference (FD) SBP methods. These methods have the same structure as classical DG methods - local operations on elements with connectivity through interfaces without imposing any continuity constraints.</p><p><code>D_SBP</code> is an SBP derivative operator from SummationByPartsOperators.jl. The other arguments have the same meaning as in <a href="#Trixi.DG"><code>DG</code></a> or <a href="#Trixi.DGSEM"><code>DGSEM</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/fdsbp_tree/fdsbp.jl#L11-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxHLL" href="#Trixi.FluxHLL"><code>Trixi.FluxHLL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxHLL(min_max_speed=min_max_speed_davis)</code></pre><p>Create an HLL (Harten, Lax, van Leer) numerical flux where the minimum and maximum wave speeds are estimated as <code>λ_min, λ_max = min_max_speed(u_ll, u_rr, orientation_or_normal_direction, equations)</code>, defaulting to <a href="#Trixi.min_max_speed_davis"><code>min_max_speed_davis</code></a>. Original paper:</p><ul><li>Amiram Harten, Peter D. Lax, Bram van Leer (1983) On Upstream Differencing and Godunov-Type Schemes for Hyperbolic Conservation Laws <a href="https://doi.org/10.1137/1025002">DOI: 10.1137/1025002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L224-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxHydrostaticReconstruction" href="#Trixi.FluxHydrostaticReconstruction"><code>Trixi.FluxHydrostaticReconstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxHydrostaticReconstruction(numerical_flux, hydrostatic_reconstruction)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This numerical flux is experimental and may change in any future release.</p></div></div><p>Allow for some kind of hydrostatic reconstruction of the solution state prior to the surface flux computation. This is a particular strategy to ensure that the method remains well-balanced for the shallow water equations, see <a href="#Trixi.ShallowWaterEquations1D"><code>ShallowWaterEquations1D</code></a> or <a href="#Trixi.ShallowWaterEquations2D"><code>ShallowWaterEquations2D</code></a>.</p><p>For example, the hydrostatic reconstruction from Audusse et al. is implemented in one and two spatial dimensions, see <a href="#Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations1D}"><code>hydrostatic_reconstruction_audusse_etal</code></a> or the original paper</p><ul><li>Emmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows <a href="https://doi.org/10.1137/S1064827503431090">DOI: 10.1137/S1064827503431090</a></li></ul><p>Other hydrostatic reconstruction techniques are available, particularly to handle wet / dry fronts. A good overview of the development and application of hydrostatic reconstruction can be found in</p><ul><li>Guoxian Chen and Sebastian Noelle A unified surface-gradient and hydrostatic reconstruction scheme for the shallow water equations (2021) <a href="https://www.igpm.rwth-aachen.de/forschung/preprints/517">RWTH Aachen preprint</a></li><li>Andreas Buttinger-Kreuzhuber, Zsolt Horváth, Sebastian Noelle, Günter Blöschl and Jürgen Waser (2019) A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography <a href="https://doi.org/10.1016/j.advwatres.2019.03.010">DOI: 10.1016/j.advwatres.2019.03.010</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L365-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxLMARS" href="#Trixi.FluxLMARS"><code>Trixi.FluxLMARS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxLMARS(c)(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerEquations2D)</code></pre><p>Low Mach number approximate Riemann solver (LMARS) for atmospheric flows using an estimate <code>c</code> of the speed of sound.</p><p>References:</p><ul><li>Xi Chen et al. (2013) A Control-Volume Model of the Compressible Euler Equations with a Vertical Lagrangian Coordinate <a href="https://doi.org/10.1175/mwr-d-12-00129.1">DOI: 10.1175/MWR-D-12-00129.1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L1014-L1026">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxLMARS-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.FluxLMARS-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.FluxLMARS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FluxLMARS(c)(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerEquations3D)</code></pre><p>Low Mach number approximate Riemann solver (LMARS) for atmospheric flows using an estimate <code>c</code> of the speed of sound.</p><p>References:</p><ul><li>Xi Chen et al. (2013) A Control-Volume Model of the Compressible Euler Equations with a Vertical Lagrangian Coordinate <a href="https://doi.org/10.1175/mwr-d-12-00129.1">DOI: 10.1175/MWR-D-12-00129.1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L972-L984">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxLaxFriedrichs" href="#Trixi.FluxLaxFriedrichs"><code>Trixi.FluxLaxFriedrichs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxLaxFriedrichs(max_abs_speed=max_abs_speed_naive)</code></pre><p>Local Lax-Friedrichs (Rusanov) flux with maximum wave speed estimate provided by <code>max_abs_speed</code>, cf. <a href="#Trixi.DissipationLocalLaxFriedrichs"><code>DissipationLocalLaxFriedrichs</code></a> and <a href="#Trixi.max_abs_speed_naive"><code>max_abs_speed_naive</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L202-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxPlusDissipation" href="#Trixi.FluxPlusDissipation"><code>Trixi.FluxPlusDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxPlusDissipation(numerical_flux, dissipation)</code></pre><p>Combine a <code>numerical_flux</code> with a <code>dissipation</code> operator to create a new numerical flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxRotated" href="#Trixi.FluxRotated"><code>Trixi.FluxRotated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxRotated(numerical_flux)</code></pre><p>Compute a <code>numerical_flux</code> flux in direction of a normal vector by rotating the solution, computing the numerical flux in x-direction, and rotating the calculated flux back.</p><p>Requires a rotationally invariant equation with equation-specific functions <a href="#Trixi.rotate_to_x"><code>rotate_to_x</code></a> and <a href="#Trixi.rotate_from_x"><code>rotate_from_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.FluxUpwind" href="#Trixi.FluxUpwind"><code>Trixi.FluxUpwind</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxUpwind(splitting)</code></pre><p>A numerical flux <code>f(u_left, u_right) = f⁺(u_left) + f⁻(u_right)</code> based on flux vector splitting.</p><p>The <a href="#Trixi.SurfaceIntegralUpwind"><code>SurfaceIntegralUpwind</code></a> with a given <code>splitting</code> is equivalent to the <a href="#Trixi.SurfaceIntegralStrongForm"><code>SurfaceIntegralStrongForm</code></a> with <code>FluxUpwind(splitting)</code> as numerical flux (up to floating point differences). Note, that <a href="#Trixi.SurfaceIntegralUpwind"><code>SurfaceIntegralUpwind</code></a> is only available on <a href="#Trixi.TreeMesh"><code>TreeMesh</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L410-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.GlmSpeedCallback" href="#Trixi.GlmSpeedCallback"><code>Trixi.GlmSpeedCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GlmSpeedCallback(; glm_scale=0.5, cfl, semi_indices=())</code></pre><p>Update the divergence cleaning wave speed <code>c_h</code> according to the time step computed in <a href="#Trixi.StepsizeCallback"><code>StepsizeCallback</code></a> for the ideal GLM-MHD equations. The <code>cfl</code> number should be set to the same value as for the time step size calculation. The <code>glm_scale</code> ensures that the GLM wave speed is lower than the fastest physical waves in the MHD solution and should thus be set to a value within the interval [0,1]. Note that <code>glm_scale = 0</code> deactivates the divergence cleaning.</p><p>In case of coupled semidiscretizations, specify for which <code>semi_index</code>, i.e. index of the semidiscretization, the divergence cleaning should be applied. See also <a href="#Trixi.SemidiscretizationCoupled"><code>SemidiscretizationCoupled</code></a>. Note: <code>SemidiscretizationCoupled</code> and all related features are considered experimental and may change at any time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/glm_speed.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.GradientVariablesPrimitive" href="#Trixi.GradientVariablesPrimitive"><code>Trixi.GradientVariablesPrimitive</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GradientVariablesPrimitive</code> and <code>GradientVariablesEntropy</code> are gradient variable type parameters for <code>CompressibleNavierStokesDiffusion1D</code>. By default, the gradient variables are set to be <code>GradientVariablesPrimitive</code>. Specifying <code>GradientVariablesEntropy</code> instead uses the entropy variable formulation from</p><ul><li>Hughes, Mallet, Franca (1986) A new finite element formulation for computational fluid dynamics: I. Symmetric forms of the compressible Euler and Navier-Stokes equations and the second law of thermodynamics. <a href="https://doi.org/10.1016/0045-7825(86)90127-1">https://doi.org/10.1016/0045-7825(86)90127-1</a></li></ul><p>Under <code>GradientVariablesEntropy</code>, the Navier-Stokes discretization is provably entropy stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes.jl#L51-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.HypDiffN3Erk3Sstar52" href="#Trixi.HypDiffN3Erk3Sstar52"><code>Trixi.HypDiffN3Erk3Sstar52</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HypDiffN3Erk3Sstar52()</code></pre><p>Five stage, second-order accurate explicit Runge-Kutta scheme with stability region optimized for the hyperbolic diffusion equation with LLF flux and polynomials of degree polydeg=3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_3Sstar.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.HyperbolicDiffusionEquations1D" href="#Trixi.HyperbolicDiffusionEquations1D"><code>Trixi.HyperbolicDiffusionEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HyperbolicDiffusionEquations1D</code></pre><p>The linear hyperbolic diffusion equations in one space dimension. A description of this system can be found in Sec. 2.5 of the book</p><ul><li>Masatsuka (2013) I Do Like CFD, Too: Vol 1. Freely available at <a href="http://www.cfdbooks.com/">http://www.cfdbooks.com/</a></li></ul><p>Further analysis can be found in the paper</p><ul><li>Nishikawa (2007) A first-order system approach for diffusion equation. I: Second-order residual-distribution schemes <a href="https://doi.org/10.1016/j.jcp.2007.07.029">DOI: 10.1016/j.jcp.2007.07.029</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_1d.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.HyperbolicDiffusionEquations2D" href="#Trixi.HyperbolicDiffusionEquations2D"><code>Trixi.HyperbolicDiffusionEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HyperbolicDiffusionEquations2D</code></pre><p>The linear hyperbolic diffusion equations in two space dimensions. A description of this system can be found in Sec. 2.5 of the book &quot;I Do Like CFD, Too: Vol 1&quot;. The book is freely available at <a href="http://www.cfdbooks.com/">http://www.cfdbooks.com/</a> and further analysis can be found in the paper by Nishikawa <a href="https://doi.org/10.1016/j.jcp.2007.07.029">DOI: 10.1016/j.jcp.2007.07.029</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_2d.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.HyperbolicDiffusionEquations3D" href="#Trixi.HyperbolicDiffusionEquations3D"><code>Trixi.HyperbolicDiffusionEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HyperbolicDiffusionEquations3D</code></pre><p>The linear hyperbolic diffusion equations in three space dimensions. A description of this system can be found in Sec. 2.5 of the book &quot;I Do Like CFD, Too: Vol 1&quot;. The book is freely available at <a href="http://www.cfdbooks.com/">http://www.cfdbooks.com/</a> and further analysis can be found in the paper by Nishikawa <a href="https://doi.org/10.1016/j.jcp.2007.07.029">DOI: 10.1016/j.jcp.2007.07.029</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_3d.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IdealGlmMhdEquations1D" href="#Trixi.IdealGlmMhdEquations1D"><code>Trixi.IdealGlmMhdEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdEquations1D(gamma)</code></pre><p>The ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats <code>gamma</code> in one space dimension.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is no divergence cleaning variable <code>psi</code> because the divergence-free constraint is satisfied trivially in one spatial dimension.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IdealGlmMhdEquations2D" href="#Trixi.IdealGlmMhdEquations2D"><code>Trixi.IdealGlmMhdEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdEquations2D(gamma)</code></pre><p>The ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats <code>gamma</code> in two space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IdealGlmMhdEquations3D" href="#Trixi.IdealGlmMhdEquations3D"><code>Trixi.IdealGlmMhdEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdEquations3D(gamma)</code></pre><p>The ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats <code>gamma</code> in three space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IdealGlmMhdMulticomponentEquations1D" href="#Trixi.IdealGlmMhdMulticomponentEquations1D"><code>Trixi.IdealGlmMhdMulticomponentEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdMulticomponentEquations1D</code></pre><p>The ideal compressible multicomponent GLM-MHD equations in one space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IdealGlmMhdMulticomponentEquations2D" href="#Trixi.IdealGlmMhdMulticomponentEquations2D"><code>Trixi.IdealGlmMhdMulticomponentEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdMulticomponentEquations2D</code></pre><p>The ideal compressible multicomponent GLM-MHD equations in two space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IndicatorClamp" href="#Trixi.IndicatorClamp"><code>Trixi.IndicatorClamp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorClamp(equations::AbstractEquations, basis; min=0.0, max=1.0, variable)
IndicatorClamp(semi::AbstractSemidiscretization; min=0.0, max=1.0, variable)</code></pre><p>A simple indicator returning 1.0 when the element average of <code>variable</code> lies within [min,max]. Returns -1.0 otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/indicators.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IndicatorHennemannGassner" href="#Trixi.IndicatorHennemannGassner"><code>Trixi.IndicatorHennemannGassner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorHennemannGassner(equations::AbstractEquations, basis;
                          alpha_max=0.5,
                          alpha_min=0.001,
                          alpha_smooth=true,
                          variable)
IndicatorHennemannGassner(semi::AbstractSemidiscretization;
                          alpha_max=0.5,
                          alpha_min=0.001,
                          alpha_smooth=true,
                          variable)</code></pre><p>Indicator used for shock-capturing (when passing the <code>equations</code> and the <code>basis</code>) or adaptive mesh refinement (AMR, when passing the <code>semi</code>).</p><p>See also <a href="#Trixi.VolumeIntegralShockCapturingHG"><code>VolumeIntegralShockCapturingHG</code></a>.</p><p><strong>References</strong></p><ul><li>Hennemann, Gassner (2020) &quot;A provably entropy stable subcell shock capturing approach for high order split form DG&quot; <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/indicators.jl#L21-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IndicatorLöhner" href="#Trixi.IndicatorLöhner"><code>Trixi.IndicatorLöhner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorLöhner (equivalent to IndicatorLoehner)

IndicatorLöhner(equations::AbstractEquations, basis;
                f_wave=0.2, variable)
IndicatorLöhner(semi::AbstractSemidiscretization;
                f_wave=0.2, variable)</code></pre><p>AMR indicator adapted from a FEM indicator by Löhner (1987), also used in the FLASH code as standard AMR indicator. The indicator estimates a weighted second derivative of a specified variable locally.</p><p>When constructed to be used for AMR, pass the <code>semi</code>. Pass the <code>equations</code>, and <code>basis</code> if this indicator should be used for shock capturing.</p><p><strong>References</strong></p><ul><li>Löhner (1987) &quot;An adaptive finite element scheme for transient problems in CFD&quot; <a href="https://doi.org/10.1016/0045-7825(87)90098-3">doi: 10.1016/0045-7825(87)90098-3</a></li><li><a href="https://flash.rochester.edu/site/flashcode/user_support/flash4_ug_4p62/node59.html#SECTION05163100000000000000">https://flash.rochester.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node59.html#SECTION05163100000000000000</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/indicators.jl#L137-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.IndicatorMax" href="#Trixi.IndicatorMax"><code>Trixi.IndicatorMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorMax(equations::AbstractEquations, basis; variable)
IndicatorMax(semi::AbstractSemidiscretization; variable)</code></pre><p>A simple indicator returning the maximum of <code>variable</code> in an element. When constructed to be used for AMR, pass the <code>semi</code>. Pass the <code>equations</code>, and <code>basis</code> if this indicator should be used for shock capturing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/indicators.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.InviscidBurgersEquation1D" href="#Trixi.InviscidBurgersEquation1D"><code>Trixi.InviscidBurgersEquation1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InviscidBurgersEquation1D</code></pre><p>The inviscid Burgers&#39; equation</p><p class="math-container">\[\partial_t u + \frac{1}{2} \partial_1 u^2 = 0\]</p><p>in one space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/inviscid_burgers_1d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.Isothermal" href="#Trixi.Isothermal"><code>Trixi.Isothermal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Isothermal</code></pre><p>Used to create a no-slip boundary condition with <a href="#Trixi.BoundaryConditionNavierStokesWall"><code>BoundaryConditionNavierStokesWall</code></a>. The field <code>boundary_value_function</code> should be a function with signature <code>boundary_value_function(x, t, equations)</code> and return a scalar value for the temperature at point <code>x</code> and time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LaplaceDiffusion1D" href="#Trixi.LaplaceDiffusion1D"><code>Trixi.LaplaceDiffusion1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LaplaceDiffusion1D(diffusivity, equations)</code></pre><p><code>LaplaceDiffusion1D</code> represents a scalar diffusion term <span>$\nabla \cdot (\kappa\nabla u))$</span> with diffusivity <span>$\kappa$</span> applied to each solution component defined by <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/laplace_diffusion_1d.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LaplaceDiffusion2D" href="#Trixi.LaplaceDiffusion2D"><code>Trixi.LaplaceDiffusion2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LaplaceDiffusion2D(diffusivity, equations)</code></pre><p><code>LaplaceDiffusion2D</code> represents a scalar diffusion term <span>$\nabla \cdot (\kappa\nabla u))$</span> with diffusivity <span>$\kappa$</span> applied to each solution component defined by <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/laplace_diffusion_2d.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LaplaceDiffusion3D" href="#Trixi.LaplaceDiffusion3D"><code>Trixi.LaplaceDiffusion3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LaplaceDiffusion3D(diffusivity, equations)</code></pre><p><code>LaplaceDiffusion3D</code> represents a scalar diffusion term <span>$\nabla \cdot (\kappa\nabla u))$</span> with diffusivity <span>$\kappa$</span> applied to each solution component defined by <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/laplace_diffusion_3d.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LatticeBoltzmannEquations2D" href="#Trixi.LatticeBoltzmannEquations2D"><code>Trixi.LatticeBoltzmannEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeBoltzmannEquations2D(; Ma, Re, collision_op=collision_bgk,
                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)</code></pre><p>The Lattice-Boltzmann equations</p><p class="math-container">\[\partial_t u_\alpha + v_{\alpha,1} \partial_1 u_\alpha + v_{\alpha,2} \partial_2 u_\alpha = 0\]</p><p>in two space dimensions for the D2Q9 scheme.</p><p>The characteristic Mach number and Reynolds numbers are specified as <code>Ma</code> and <code>Re</code>. By the default, the collision operator <code>collision_op</code> is set to the BGK model. <code>c</code>, <code>L</code>, and <code>rho0</code> specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity <code>u0</code> directly (<code>Ma</code> needs to be set to <code>nothing</code> in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity <code>nu</code> directly (in this case, <code>Re</code> needs to be set to <code>nothing</code>).</p><p>The nine discrete velocity directions of the D2Q9 scheme are sorted as follows [4]:</p><pre><code class="nohighlight hljs">  6     2     5       y
    ┌───┼───┐         │
    │       │         │
  3 ┼   9   ┼ 1        ──── x
    │       │        ╱
    └───┼───┘       ╱
  7     4     8    z</code></pre><p>Note that usually the velocities are numbered from <code>0</code> to <code>8</code>, where <code>0</code> corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from <code>1</code> to <code>9</code>, where <code>1</code> through <code>8</code> correspond to the velocity directions in [4] and <code>9</code> is the zero velocity.</p><p>The corresponding opposite directions are:</p><ul><li>1 ←→ 3</li><li>2 ←→ 4</li><li>3 ←→ 1</li><li>4 ←→ 2</li><li>5 ←→ 7</li><li>6 ←→ 8</li><li>7 ←→ 5</li><li>8 ←→ 6</li><li>9 ←→ 9</li></ul><p>The main sources for the base implementation were</p><ol><li>Misun Min, Taehun Lee, <strong>A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows</strong>, J Comput Phys 230(1), 2011 <a href="https://doi.org/10.1016/j.jcp.2010.09.024">doi:10.1016/j.jcp.2010.09.024</a></li><li>Karsten Golly, <strong>Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum</strong>, Master Thesis, University of Cologne, 2018.</li><li>Dieter Hänel, <strong>Molekulare Gasdynamik</strong>, Springer-Verlag Berlin Heidelberg, 2004 <a href="https://doi.org/10.1007/3-540-35047-0">doi:10.1007/3-540-35047-0</a></li><li>Dieter Krüger et al., <strong>The Lattice Boltzmann Method</strong>, Springer International Publishing, 2017 <a href="https://doi.org/10.1007/978-3-319-44649-3">doi:10.1007/978-3-319-44649-3</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L8-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LatticeBoltzmannEquations3D" href="#Trixi.LatticeBoltzmannEquations3D"><code>Trixi.LatticeBoltzmannEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeBoltzmannEquations3D(; Ma, Re, collision_op=collision_bgk,
                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)</code></pre><p>The Lattice-Boltzmann equations</p><p class="math-container">\[\partial_t u_\alpha + v_{\alpha,1} \partial_1 u_\alpha + v_{\alpha,2} \partial_2 u_\alpha + v_{\alpha,3} \partial_3 u_\alpha = 0\]</p><p>in three space dimensions for the D3Q27 scheme.</p><p>The characteristic Mach number and Reynolds numbers are specified as <code>Ma</code> and <code>Re</code>. By the default, the collision operator <code>collision_op</code> is set to the BGK model. <code>c</code>, <code>L</code>, and <code>rho0</code> specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity <code>u0</code> directly (<code>Ma</code> needs to be set to <code>nothing</code> in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity <code>nu</code> directly (in this case, <code>Re</code> needs to be set to <code>nothing</code>).</p><p>The twenty-seven discrete velocity directions of the D3Q27 scheme are sorted as follows [4]:</p><ul><li>plane at <code>z = -1</code>:<pre><code class="nohighlight hljs">  24    17     21       y
     ┌───┼───┐          │
     │       │          │
  10 ┼   6   ┼ 15        ──── x
     │       │         ╱
     └───┼───┘        ╱
  20    12     26    z</code></pre></li><li>plane at <code>z = 0</code>:<pre><code class="nohighlight hljs">  14     3     7        y
     ┌───┼───┐          │
     │       │          │
   2 ┼  27   ┼ 1         ──── x
     │       │         ╱
     └───┼───┘        ╱
   8     4     13    z</code></pre></li><li>plane at <code>z = +1</code>:<pre><code class="nohighlight hljs">  25    11     19       y
     ┌───┼───┐          │
     │       │          │
  16 ┼   5   ┼ 9         ──── x
     │       │         ╱
     └───┼───┘        ╱
  22    18     23    z</code></pre></li></ul><p>Note that usually the velocities are numbered from <code>0</code> to <code>26</code>, where <code>0</code> corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from <code>1</code> to <code>27</code>, where <code>1</code> through <code>26</code> correspond to the velocity directions in [4] and <code>27</code> is the zero velocity.</p><p>The corresponding opposite directions are:</p><ul><li>1 ←→  2</li><li>2 ←→  1</li><li>3 ←→  4</li><li>4 ←→  3</li><li>5 ←→  6</li><li>6 ←→  5</li><li>7 ←→  8</li><li>8 ←→  7</li><li>9 ←→ 10</li><li>10 ←→  9</li><li>11 ←→ 12</li><li>12 ←→ 11</li><li>13 ←→ 14</li><li>14 ←→ 13</li><li>15 ←→ 16</li><li>16 ←→ 15</li><li>17 ←→ 18</li><li>18 ←→ 17</li><li>19 ←→ 20</li><li>20 ←→ 19</li><li>21 ←→ 22</li><li>22 ←→ 21</li><li>23 ←→ 24</li><li>24 ←→ 23</li><li>25 ←→ 26</li><li>26 ←→ 25</li><li>27 ←→ 27</li></ul><p>The main sources for the base implementation were</p><ol><li>Misun Min, Taehun Lee, <strong>A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows</strong>, J Comput Phys 230(1), 2011 <a href="https://doi.org/10.1016/j.jcp.2010.09.024">doi:10.1016/j.jcp.2010.09.024</a></li><li>Karsten Golly, <strong>Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum</strong>, Master Thesis, University of Cologne, 2018.</li><li>Dieter Hänel, <strong>Molekulare Gasdynamik</strong>, Springer-Verlag Berlin Heidelberg, 2004 <a href="https://doi.org/10.1007/3-540-35047-0">doi:10.1007/3-540-35047-0</a></li><li>Dieter Krüger et al., <strong>The Lattice Boltzmann Method</strong>, Springer International Publishing, 2017 <a href="https://doi.org/10.1007/978-3-319-44649-3">doi:10.1007/978-3-319-44649-3</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L8-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LiftCoefficientPressure-NTuple{4, Any}" href="#Trixi.LiftCoefficientPressure-NTuple{4, Any}"><code>Trixi.LiftCoefficientPressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LiftCoefficientPressure(aoa, rhoinf, uinf, linf)</code></pre><p>Compute the lift coefficient</p><p class="math-container">\[C_{L,p} \coloneqq \frac{\oint_{\partial \Omega} p \boldsymbol n \cdot \psi_L \, \mathrm{d} S}
                        {0.5 \rho_{\infty} U_{\infty}^2 L_{\infty}}\]</p><p>based on the pressure distribution along a boundary. Supposed to be used in conjunction with <a href="#Trixi.AnalysisSurfaceIntegral"><code>AnalysisSurfaceIntegral</code></a> which stores the boundary information and semidiscretization.</p><ul><li><code>aoa::Real</code>: Angle of attack in radians (for airfoils etc.)</li><li><code>rhoinf::Real</code>: Free-stream density</li><li><code>uinf::Real</code>: Free-stream velocity</li><li><code>linf::Real</code>: Reference length of geometry (e.g. airfoil chord length)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/analysis_surface_integral_2d.jl#L78-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LiftCoefficientShearStress-NTuple{4, Any}" href="#Trixi.LiftCoefficientShearStress-NTuple{4, Any}"><code>Trixi.LiftCoefficientShearStress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LiftCoefficientShearStress(aoa, rhoinf, uinf, linf)</code></pre><p>Compute the lift coefficient</p><p class="math-container">\[C_{L,f} \coloneqq \frac{\oint_{\partial \Omega} \boldsymbol \tau_w \cdot \psi_L \, \mathrm{d} S}
                        {0.5 \rho_{\infty} U_{\infty}^2 L_{\infty}}\]</p><p>based on the wall shear stress vector <span>$\tau_w$</span> along a boundary. Supposed to be used in conjunction with <a href="#Trixi.AnalysisSurfaceIntegral"><code>AnalysisSurfaceIntegral</code></a> which stores the boundary information and semidiscretization.</p><ul><li><code>aoa::Real</code>: Angle of attack in radians (for airfoils etc.)</li><li><code>rhoinf::Real</code>: Free-stream density</li><li><code>uinf::Real</code>: Free-stream velocity</li><li><code>linf::Real</code>: Reference length of geometry (e.g. airfoil chord length)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/analysis_surface_integral_2d.jl#L128-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LinearScalarAdvectionEquation1D" href="#Trixi.LinearScalarAdvectionEquation1D"><code>Trixi.LinearScalarAdvectionEquation1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearScalarAdvectionEquation1D</code></pre><p>The linear scalar advection equation</p><p class="math-container">\[\partial_t u + a \partial_1 u  = 0\]</p><p>in one space dimension with constant velocity <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LinearScalarAdvectionEquation2D" href="#Trixi.LinearScalarAdvectionEquation2D"><code>Trixi.LinearScalarAdvectionEquation2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearScalarAdvectionEquation2D</code></pre><p>The linear scalar advection equation</p><p class="math-container">\[\partial_t u + a_1 \partial_1 u + a_2 \partial_2 u = 0\]</p><p>in two space dimensions with constant velocity <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LinearScalarAdvectionEquation3D" href="#Trixi.LinearScalarAdvectionEquation3D"><code>Trixi.LinearScalarAdvectionEquation3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearScalarAdvectionEquation3D</code></pre><p>The linear scalar advection equation</p><p class="math-container">\[\partial_t u + a_1 \partial_1 u + a_2 \partial_2 u + a_3 \partial_3 u = 0\]</p><p>in three space dimensions with constant velocity <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_3d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LinearizedEulerEquations1D" href="#Trixi.LinearizedEulerEquations1D"><code>Trixi.LinearizedEulerEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearizedEulerEquations1D(v_mean_global, c_mean_global, rho_mean_global)</code></pre><p>Linearized Euler equations in one space dimension. The equations are given by</p><p class="math-container">\[\partial_t
\begin{pmatrix}
    \rho&#39; \\ v_1&#39; \\ p&#39;
\end{pmatrix}
+
\partial_x
\begin{pmatrix}
    \bar{\rho} v_1&#39; + \bar{v_1} \rho &#39; \\ \bar{v_1} v_1&#39; + \frac{p&#39;}{\bar{\rho}} \\ \bar{v_1} p&#39; + c^2 \bar{\rho} v_1&#39;
\end{pmatrix}
=
\begin{pmatrix}
    0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>The bar <span>$\bar{(\cdot)}$</span> indicates uniform mean flow variables and <span>$c$</span> is the speed of sound. The unknowns are the perturbation quantities of the acoustic velocity <span>$v_1&#39;$</span>, the pressure <span>$p&#39;$</span>  and the density <span>$\rho&#39;$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_1d.jl#L8-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LinearizedEulerEquations2D" href="#Trixi.LinearizedEulerEquations2D"><code>Trixi.LinearizedEulerEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearizedEulerEquations2D(v_mean_global, c_mean_global, rho_mean_global)</code></pre><p>Linearized Euler equations in two space dimensions. The equations are given by</p><p class="math-container">\[\partial_t
\begin{pmatrix}
    \rho&#39; \\ v_1&#39; \\ v_2&#39; \\ p&#39;
\end{pmatrix}
+
\partial_x
\begin{pmatrix}
    \bar{\rho} v_1&#39; + \bar{v_1} \rho &#39; \\ \bar{v_1} v_1&#39; + \frac{p&#39;}{\bar{\rho}} \\ \bar{v_1} v_2&#39; \\ \bar{v_1} p&#39; + c^2 \bar{\rho} v_1&#39;
\end{pmatrix}
+
\partial_y
\begin{pmatrix}
    \bar{\rho} v_2&#39; + \bar{v_2} \rho &#39; \\ \bar{v_2} v_1&#39; \\ \bar{v_2} v_2&#39; + \frac{p&#39;}{\bar{\rho}} \\ \bar{v_2} p&#39; + c^2 \bar{\rho} v_2&#39;
\end{pmatrix}
=
\begin{pmatrix}
    0 \\ 0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>The bar <span>$\bar{(\cdot)}$</span> indicates uniform mean flow variables and <span>$c$</span> is the speed of sound. The unknowns are the acoustic velocities <span>$v&#39; = (v_1&#39;, v_2&#39;)$</span>, the pressure <span>$p&#39;$</span> and the density <span>$\rho&#39;$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_2d.jl#L8-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LinearizedEulerEquations3D" href="#Trixi.LinearizedEulerEquations3D"><code>Trixi.LinearizedEulerEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearizedEulerEquations3D(v_mean_global, c_mean_global, rho_mean_global)</code></pre><p>Linearized Euler equations in three space dimensions. The equations are given by</p><p class="math-container">\[\partial_t
\begin{pmatrix}
    \rho&#39; \\ v_1&#39; \\ v_2&#39; \\ v_3&#39; \\ p&#39;
\end{pmatrix}
+
\partial_x
\begin{pmatrix}
    \bar{\rho} v_1&#39; + \bar{v_1} \rho &#39; \\ 
    \bar{v_1} v_1&#39; + \frac{p&#39;}{\bar{\rho}} \\ 
    \bar{v_1} v_2&#39; \\ 
    \bar{v_1} v_3&#39; \\ 
    \bar{v_1} p&#39; + c^2 \bar{\rho} v_1&#39;
\end{pmatrix}
+
\partial_y
\begin{pmatrix}
    \bar{\rho} v_2&#39; + \bar{v_2} \rho &#39; \\ 
    \bar{v_2} v_1&#39; \\ 
    \bar{v_2} v_2&#39; + \frac{p&#39;}{\bar{\rho}} \\ 
    \bar{v_2} v_3&#39; \\ 
    \bar{v_2} p&#39; + c^2 \bar{\rho} v_2&#39;
\end{pmatrix}
+ 
\partial_z
\begin{pmatrix}
    \bar{\rho} v_3&#39; + \bar{v_3} \rho &#39; \\ 
    \bar{v_3} v_1&#39; \\ 
    \bar{v_3} v_2&#39; \\ 
    \bar{v_3} v_3&#39; + \frac{p&#39;}{\bar{\rho}} \\ 
    \bar{v_3} p&#39; + c^2 \bar{\rho} v_3&#39;
\end{pmatrix}
=
\begin{pmatrix}
    0 \\ 0 \\ 0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>The bar <span>$\bar{(\cdot)}$</span> indicates uniform mean flow variables and <span>$c$</span> is the speed of sound. The unknowns are the acoustic velocities <span>$v&#39; = (v_1&#39;, v_2, v_3&#39;)$</span>, the pressure <span>$p&#39;$</span> and the density <span>$\rho&#39;$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_3d.jl#L8-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LobattoLegendreBasis" href="#Trixi.LobattoLegendreBasis"><code>Trixi.LobattoLegendreBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LobattoLegendreBasis([RealT=Float64,] polydeg::Integer)</code></pre><p>Create a nodal Lobatto-Legendre basis for polynomials of degree <code>polydeg</code>.</p><p>For the special case <code>polydeg=0</code> the DG method reduces to a finite volume method. Therefore, this function sets the center point of the cell as single node. This exceptional case is currently only supported for TreeMesh!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.NoSlip" href="#Trixi.NoSlip"><code>Trixi.NoSlip</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NoSlip</code></pre><p>Use to create a no-slip boundary condition with <code>BoundaryConditionNavierStokesWall</code>. The field <code>boundary_value_function</code> should be a function with signature <code>boundary_value_function(x, t, equations)</code> and should return a <code>SVector{NDIMS}</code> whose entries are the velocity vector at a point <code>x</code> and time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.NonConservativeLocal" href="#Trixi.NonConservativeLocal"><code>Trixi.NonConservativeLocal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonConservativeLocal()</code></pre><p>Struct used for multiple dispatch on non-conservative flux functions in the format of &quot;local * symmetric&quot;. When the argument <code>nonconservative_type</code> is of type <code>NonConservativeLocal</code>, the function returns the local part of the non-conservative term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.NonConservativeSymmetric" href="#Trixi.NonConservativeSymmetric"><code>Trixi.NonConservativeSymmetric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonConservativeSymmetric()</code></pre><p>Struct used for multiple dispatch on non-conservative flux functions in the format of &quot;local * symmetric&quot;. When the argument <code>nonconservative_type</code> is of type <code>NonConservativeSymmetric</code>, the function returns the symmetric part of the non-conservative term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L232-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.P4estMesh" href="#Trixi.P4estMesh"><code>Trixi.P4estMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">P4estMesh{NDIMS} &lt;: AbstractMesh{NDIMS}</code></pre><p>An unstructured curved mesh based on trees that uses the C library <code>p4est</code> to manage trees and mesh refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/p4est_mesh.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.P4estMesh-Tuple{Any}" href="#Trixi.P4estMesh-Tuple{Any}"><code>Trixi.P4estMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P4estMesh(trees_per_dimension; polydeg,
          mapping=nothing, faces=nothing, coordinates_min=nothing, coordinates_max=nothing,
          RealT=Float64, initial_refinement_level=0, periodicity=true, unsaved_changes=true,
          p4est_partition_allow_for_coarsening=true)</code></pre><p>Create a structured curved <code>P4estMesh</code> of the specified size.</p><p>There are three ways to map the mesh to the physical domain.</p><ol><li>Define a <code>mapping</code> that maps the hypercube <code>[-1, 1]^n</code>.</li><li>Specify a <code>Tuple</code> <code>faces</code> of functions that parametrize each face.</li><li>Create a rectangular mesh by specifying <code>coordinates_min</code> and <code>coordinates_max</code>.</li></ol><p>Non-periodic boundaries will be called <code>:x_neg</code>, <code>:x_pos</code>, <code>:y_neg</code>, <code>:y_pos</code>, <code>:z_neg</code>, <code>:z_pos</code>.</p><p><strong>Arguments</strong></p><ul><li><code>trees_per_dimension::NTupleE{NDIMS, Int}</code>: the number of trees in each dimension.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the reference mesh (<code>[-1, 1]^n</code>) to the physical domain.            Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>faces::NTuple{2*NDIMS}</code>: a tuple of <code>2 * NDIMS</code> functions that describe the faces of the domain.                           Each function must take <code>NDIMS-1</code> arguments.                           <code>faces[1]</code> describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by <code>faces[2]</code>.                           <code>faces[3:4]</code> describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           <code>faces[5:6]</code> describe the faces in positive and negative z-direction respectively (in 3D).                           Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>coordinates_min</code>: vector or tuple of the coordinates of the corner in the negative direction of each dimension                    to create a rectangular mesh.                    Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>coordinates_max</code>: vector or tuple of the coordinates of the corner in the positive direction of each dimension                    to create a rectangular mesh.                    Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code>                deciding for each dimension if the boundaries in this dimension are periodic.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li><li><code>p4est_partition_allow_for_coarsening::Bool</code>: Must be <code>true</code> when using AMR to make mesh adaptivity                                               independent of domain partitioning. Should be <code>false</code> for static meshes                                               to permit more fine-grained partitioning.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/p4est_mesh.jl#L117-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.P4estMesh-Union{Tuple{String}, Tuple{NDIMS}} where NDIMS" href="#Trixi.P4estMesh-Union{Tuple{String}, Tuple{NDIMS}} where NDIMS"><code>Trixi.P4estMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P4estMesh{NDIMS}(meshfile::String;
                 mapping=nothing, polydeg=1, RealT=Float64,
                 initial_refinement_level=0, unsaved_changes=true,
                 p4est_partition_allow_for_coarsening=true,
                 boundary_symbols = nothing)</code></pre><p>Main mesh constructor for the <code>P4estMesh</code> that imports an unstructured, conforming mesh from an Abaqus mesh file (<code>.inp</code>). Each element of the conforming mesh parsed from the <code>meshfile</code> is created as a <a href="https://github.com/cburstedde/p4est"><code>p4est</code></a> tree datatype.</p><p>To create a curved unstructured mesh <code>P4estMesh</code> two strategies are available:</p><ul><li><code>p4est_mesh_from_hohqmesh_abaqus</code>: High-order, curved boundary information created by                                    <a href="https://github.com/trixi-framework/HOHQMesh.jl"><code>HOHQMesh.jl</code></a> is                                    available in the <code>meshfile</code>. The mesh polynomial degree <code>polydeg</code>                                    of the boundaries is provided from the <code>meshfile</code>. The computation of                                    the mapped tree coordinates is done with transfinite interpolation                                    with linear blending similar to <a href="#Trixi.UnstructuredMesh2D"><code>UnstructuredMesh2D</code></a>. Boundary name                                    information is also parsed from the <code>meshfile</code> such that different boundary                                    conditions can be set at each named boundary on a given tree.</li><li><code>p4est_mesh_from_standard_abaqus</code>: By default, with <code>mapping=nothing</code> and <code>polydeg=1</code>, this creates a                                    straight-sided from the information parsed from the <code>meshfile</code>. If a mapping                                    function is specified then it computes the mapped tree coordinates via polynomial                                    interpolants with degree <code>polydeg</code>. The mesh created by this function will only                                    have one boundary <code>:all</code> if <code>boundary_symbols</code> is not specified.                                    If <code>boundary_symbols</code> is specified the mesh file will be parsed for nodesets defining                                    the boundary nodes from which boundary edges (2D) and faces (3D) will be assigned.</li></ul><p>Note that the <code>mapping</code> and <code>polydeg</code> keyword arguments are only used by the <code>p4est_mesh_from_standard_abaqus</code> function. The <code>p4est_mesh_from_hohqmesh_abaqus</code> function obtains the mesh <code>polydeg</code> directly from the <code>meshfile</code> and constructs the transfinite mapping internally.</p><p>The particular strategy is selected according to the header present in the <code>meshfile</code> where the constructor checks whether or not the <code>meshfile</code> was created with <a href="https://github.com/trixi-framework/HOHQMesh.jl">HOHQMesh.jl</a>. If the Abaqus file header is not present in the <code>meshfile</code> then the <code>P4estMesh</code> is created with the function <code>p4est_mesh_from_standard_abaqus</code>.</p><p>The default keyword argument <code>initial_refinement_level=0</code> corresponds to a forest where the number of trees is the same as the number of elements in the original <code>meshfile</code>. Increasing the <code>initial_refinement_level</code> allows one to uniformly refine the base mesh given in the <code>meshfile</code> to create a forest with more trees before the simulation begins. For example, if a two-dimensional base mesh contains 25 elements then setting <code>initial_refinement_level=1</code> creates an initial forest of <code>2^2 * 25 = 100</code> trees.</p><p><strong>Arguments</strong></p><ul><li><code>meshfile::String</code>: an uncurved Abaqus mesh file that can be imported by <code>p4est</code>.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li><li><code>p4est_partition_allow_for_coarsening::Bool</code>: Must be <code>true</code> when using AMR to make mesh adaptivity                                               independent of domain partitioning. Should be <code>false</code> for static meshes                                               to permit more fine-grained partitioning.</li><li><code>boundary_symbols::Vector{Symbol}</code>: A vector of symbols that correspond to the boundary names in the <code>meshfile</code>.                                     If <code>nothing</code> is passed then all boundaries are named <code>:all</code>.                                                </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/p4est_mesh.jl#L288-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ParametersEulerGravity" href="#Trixi.ParametersEulerGravity"><code>Trixi.ParametersEulerGravity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParametersEulerGravity(; background_density=0.0,
                         gravitational_constant=1.0,
                         cfl=1.0,
                         resid_tol=1.0e-4,
                         n_iterations_max=10^4,
                         timestep_gravity=timestep_gravity_erk52_3Sstar!)</code></pre><p>Set up parameters for the gravitational part of a <a href="#Trixi.SemidiscretizationEulerGravity"><code>SemidiscretizationEulerGravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_euler_gravity.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ParsaniKetchesonDeconinck3Sstar32" href="#Trixi.ParsaniKetchesonDeconinck3Sstar32"><code>Trixi.ParsaniKetchesonDeconinck3Sstar32</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParsaniKetchesonDeconinck3Sstar32()</code></pre><p>Parsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems <a href="https://doi.org/10.1137/120885899">DOI: 10.1137/120885899</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_3Sstar.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ParsaniKetchesonDeconinck3Sstar94" href="#Trixi.ParsaniKetchesonDeconinck3Sstar94"><code>Trixi.ParsaniKetchesonDeconinck3Sstar94</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParsaniKetchesonDeconinck3Sstar94()</code></pre><p>Parsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems <a href="https://doi.org/10.1137/120885899">DOI: 10.1137/120885899</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_3Sstar.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PerformanceCounter" href="#Trixi.PerformanceCounter"><code>Trixi.PerformanceCounter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PerformanceCounter()</code></pre><p>A <code>PerformanceCounter</code> can be used to track the runtime performance of some calls. Add a new runtime measurement via <code>put!(counter, runtime)</code> and get the averaged runtime of all measurements added so far via <code>take!(counter)</code>, resetting the <code>counter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PerformanceCounterList" href="#Trixi.PerformanceCounterList"><code>Trixi.PerformanceCounterList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PerformanceCounterList{N}()</code></pre><p>A <code>PerformanceCounterList{N}</code> can be used to track the runtime performance of calls to multiple functions, adding them up. Add a new runtime measurement via <code>put!(counter.counters[i], runtime)</code> and get the averaged runtime of all measurements added so far via <code>take!(counter)</code>, resetting the <code>counter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PlotData1D" href="#Trixi.PlotData1D"><code>Trixi.PlotData1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlotData1D</code></pre><p>Holds all relevant data for creating 1D plots of multiple solution variables and to visualize the mesh.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L121-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PlotData1D-Tuple{Any, Any}" href="#Trixi.PlotData1D-Tuple{Any, Any}"><code>Trixi.PlotData1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlotData1D(u, semi [or mesh, equations, solver, cache];
           solution_variables=nothing, nvisnodes=nothing)</code></pre><p>Create a new <code>PlotData1D</code> object that can be used for visualizing 1D DGSEM solution data array <code>u</code> with <code>Plots.jl</code>. All relevant geometrical information is extracted from the semidiscretization <code>semi</code>. By default, the primitive variables (if existent) or the conservative variables (otherwise) from the solution are used for plotting. This can be changed by passing an appropriate conversion function to <code>solution_variables</code>.</p><p><code>nvisnodes</code> specifies the number of visualization nodes to be used. If it is <code>nothing</code>, twice the number of solution DG nodes are used for visualization, and if set to <code>0</code>, exactly the number of nodes in the DG elements are used.</p><p>When visualizing data from a two-dimensional simulation, a 1D slice is extracted for plotting. <code>slice</code> specifies the axis along which the slice is extracted and may be <code>:x</code>, or <code>:y</code>. The slice position is specified by a <code>point</code> that lies on it, which defaults to <code>(0.0, 0.0)</code>. Both of these values are ignored when visualizing 1D data. This applies analogously to three-dimensional simulations, where <code>slice</code> may be <code>:xy</code>, <code>:xz</code>, or <code>:yz</code>.</p><p>Another way to visualize 2D/3D data is by creating a plot along a given curve. This is done with the keyword argument <code>curve</code>. It can be set to a list of 2D/3D points which define the curve. When using <code>curve</code> any other input from <code>slice</code> or <code>point</code> will be ignored.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L517-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PlotData1D-Tuple{Union{ODESolution{T, N, uType, uType2, DType, tType, rateType, P} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(ODEProblem{uType_, tType_, isinplace, P_} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization})}, Trixi.TimeIntegratorSolution}}" href="#Trixi.PlotData1D-Tuple{Union{ODESolution{T, N, uType, uType2, DType, tType, rateType, P} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(ODEProblem{uType_, tType_, isinplace, P_} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization})}, Trixi.TimeIntegratorSolution}}"><code>Trixi.PlotData1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlotData1D(sol; kwargs...)</code></pre><p>Create a <code>PlotData1D</code> object from a solution object created by either <code>OrdinaryDiffEq.solve!</code> (which returns a <code>SciMLBase.ODESolution</code>) or Trixi.jl&#39;s own <code>solve!</code> (which returns a <code>TimeIntegratorSolution</code>).</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L689-L698">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PlotData2DCartesian" href="#Trixi.PlotData2DCartesian"><code>Trixi.PlotData2DCartesian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlotData2D</code></pre><p>Holds all relevant data for creating 2D plots of multiple solution variables and to visualize the mesh.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PolytropicEulerEquations2D" href="#Trixi.PolytropicEulerEquations2D"><code>Trixi.PolytropicEulerEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolytropicEulerEquations2D(gamma, kappa)</code></pre><p>The polytropic Euler equations</p><p class="math-container">\[\frac{\partial}{\partial t}
\begin{pmatrix}
\rho \\ \rho v_1 \\ \rho v_2
\end{pmatrix}
+
\frac{\partial}{\partial x}
\begin{pmatrix}
 \rho v_1 \\ \rho v_1^2 + \kappa\rho^\gamma \\ \rho v_1 v_2
\end{pmatrix}
+
\frac{\partial}{\partial y}
\begin{pmatrix}
\rho v_2 \\ \rho v_1 v_2 \\ \rho v_2^2 + \kappa\rho^\gamma
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 0 \\ 0
\end{pmatrix}\]</p><p>for an ideal gas with ratio of specific heats <code>gamma</code> in two space dimensions. Here, <span>$\rho$</span> is the density and <span>$v_1$</span> and<code>v_2</code> the velocities and</p><p class="math-container">\[p = \kappa\rho^\gamma\]</p><p>the pressure, which we replaced using this relation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/polytropic_euler_2d.jl#L8-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PositivityPreservingLimiterZhangShu" href="#Trixi.PositivityPreservingLimiterZhangShu"><code>Trixi.PositivityPreservingLimiterZhangShu</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PositivityPreservingLimiterZhangShu(; threshold, variables)</code></pre><p>The fully-discrete positivity-preserving limiter of</p><ul><li>Zhang, Shu (2011) Maximum-principle-satisfying and positivity-preserving high-order schemes for conservation laws: survey and new developments <a href="https://doi.org/10.1098/rspa.2011.0153">doi: 10.1098/rspa.2011.0153</a></li></ul><p>The limiter is applied to all scalar <code>variables</code> in their given order using the associated <code>thresholds</code> to determine the minimal acceptable values. The order of the <code>variables</code> is important and might have a strong influence on the robustness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_stage/positivity_zhang_shu.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SaveRestartCallback" href="#Trixi.SaveRestartCallback"><code>Trixi.SaveRestartCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SaveRestartCallback(; interval=0,
                      save_final_restart=true,
                      output_directory=&quot;out&quot;)</code></pre><p>Save the current numerical solution in a restart file every <code>interval</code> time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/save_restart.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SaveSolutionCallback" href="#Trixi.SaveSolutionCallback"><code>Trixi.SaveSolutionCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SaveSolutionCallback(; interval::Integer=0,
                       dt=nothing,
                       save_initial_solution=true,
                       save_final_solution=true,
                       output_directory=&quot;out&quot;,
                       solution_variables=cons2prim)</code></pre><p>Save the current numerical solution in regular intervals. Either pass <code>interval</code> to save every <code>interval</code> time steps or pass <code>dt</code> to save in intervals of <code>dt</code> in terms of integration time by adding additional (shortened) time steps where necessary (note that this may change the solution). <code>solution_variables</code> can be any callable that converts the conservative variables at a single point to a set of solution variables. The first parameter passed to <code>solution_variables</code> will be the set of conservative variables and the second parameter is the equation struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/save_solution.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationCoupled" href="#Trixi.SemidiscretizationCoupled"><code>Trixi.SemidiscretizationCoupled</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationCoupled</code></pre><p>A struct used to bundle multiple semidiscretizations. <a href="#SummationByPartsOperators.semidiscretize-Tuple{SemidiscretizationHyperbolicParabolic, Any}"><code>semidiscretize</code></a> will return an <code>ODEProblem</code> that synchronizes time steps between the semidiscretizations. Each call of <code>rhs!</code> will call <code>rhs!</code> for each semidiscretization individually. The semidiscretizations can be coupled by gluing meshes together using <a href="#Trixi.BoundaryConditionCoupled"><code>BoundaryConditionCoupled</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This is an experimental feature and can change any time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_coupled.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationCoupled-Tuple" href="#Trixi.SemidiscretizationCoupled-Tuple"><code>Trixi.SemidiscretizationCoupled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationCoupled(semis...)</code></pre><p>Create a coupled semidiscretization that consists of the semidiscretizations passed as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_coupled.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationEulerAcoustics" href="#Trixi.SemidiscretizationEulerAcoustics"><code>Trixi.SemidiscretizationEulerAcoustics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationEulerAcoustics(semi_acoustics::SemiAcoustics, semi_euler::SemiEuler;
                                 source_region=x-&gt;true, weights=x-&gt;1.0)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This semidiscretization is experimental and may change in any future release.</p></div></div><p>Construct a semidiscretization of the acoustic perturbation equations that is coupled with the compressible Euler equations via source terms for the perturbed velocity. Both semidiscretizations have to use the same mesh and solvers with a shared basis. The coupling region is described by a function <code>source_region</code> that maps the coordinates of a single node to <code>true</code> or <code>false</code> depending on whether the point lies within the coupling region or not. A weighting function <code>weights</code> that maps coordinates to weights is applied to the acoustic source terms. Note that this semidiscretization should be used in conjunction with <a href="#Trixi.EulerAcousticsCouplingCallback"><code>EulerAcousticsCouplingCallback</code></a> and only works in two dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_euler_acoustics.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationEulerGravity" href="#Trixi.SemidiscretizationEulerGravity"><code>Trixi.SemidiscretizationEulerGravity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationEulerGravity</code></pre><p>A struct containing everything needed to describe a spatial semidiscretization of a the compressible Euler equations with self-gravity, reformulating the Poisson equation for the gravitational potential as steady-state problem of the hyperblic diffusion equations.</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) &quot;A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics&quot; <a href="https://arXiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_euler_gravity.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationEulerGravity-Union{Tuple{SemiGravity}, Tuple{SemiEuler}, Tuple{Mesh}, Tuple{SemiEuler, SemiGravity, Any}} where {Mesh, SemiEuler&lt;:(SemidiscretizationHyperbolic{Mesh, &lt;:Trixi.AbstractCompressibleEulerEquations}), SemiGravity&lt;:(SemidiscretizationHyperbolic{Mesh, &lt;:Trixi.AbstractHyperbolicDiffusionEquations})}" href="#Trixi.SemidiscretizationEulerGravity-Union{Tuple{SemiGravity}, Tuple{SemiEuler}, Tuple{Mesh}, Tuple{SemiEuler, SemiGravity, Any}} where {Mesh, SemiEuler&lt;:(SemidiscretizationHyperbolic{Mesh, &lt;:Trixi.AbstractCompressibleEulerEquations}), SemiGravity&lt;:(SemidiscretizationHyperbolic{Mesh, &lt;:Trixi.AbstractHyperbolicDiffusionEquations})}"><code>Trixi.SemidiscretizationEulerGravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationEulerGravity(semi_euler::SemiEuler, semi_gravity::SemiGravity, parameters)</code></pre><p>Construct a semidiscretization of the compressible Euler equations with self-gravity. <code>parameters</code> should be given as <a href="#Trixi.ParametersEulerGravity"><code>ParametersEulerGravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_euler_gravity.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationHyperbolic" href="#Trixi.SemidiscretizationHyperbolic"><code>Trixi.SemidiscretizationHyperbolic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationHyperbolic</code></pre><p>A struct containing everything needed to describe a spatial semidiscretization of a hyperbolic conservation law.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_hyperbolic.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationHyperbolic-NTuple{4, Any}" href="#Trixi.SemidiscretizationHyperbolic-NTuple{4, Any}"><code>Trixi.SemidiscretizationHyperbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver;
                             source_terms=nothing,
                             boundary_conditions=boundary_condition_periodic,
                             RealT=real(solver),
                             uEltype=RealT,
                             initial_cache=NamedTuple())</code></pre><p>Construct a semidiscretization of a hyperbolic PDE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_hyperbolic.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationHyperbolicParabolic" href="#Trixi.SemidiscretizationHyperbolicParabolic"><code>Trixi.SemidiscretizationHyperbolicParabolic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationHyperbolicParabolic</code></pre><p>A struct containing everything needed to describe a spatial semidiscretization of a mixed hyperbolic-parabolic conservation law.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SemidiscretizationHyperbolicParabolic-Tuple{Any, Tuple, Any, Any}" href="#Trixi.SemidiscretizationHyperbolicParabolic-Tuple{Any, Tuple, Any, Any}"><code>Trixi.SemidiscretizationHyperbolicParabolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationHyperbolicParabolic(mesh, both_equations, initial_condition, solver;
                                      solver_parabolic=default_parabolic_solver(),
                                      source_terms=nothing,
                                      both_boundary_conditions=(boundary_condition_periodic, boundary_condition_periodic),
                                      RealT=real(solver),
                                      uEltype=RealT,
                                      both_initial_caches=(NamedTuple(), NamedTuple()))</code></pre><p>Construct a semidiscretization of a hyperbolic-parabolic PDE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl#L84-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ShallowWaterEquations1D" href="#Trixi.ShallowWaterEquations1D"><code>Trixi.ShallowWaterEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShallowWaterEquations1D(; gravity, H0 = 0)</code></pre><p>Shallow water equations (SWE) in one space dimension. The equations are given by</p><p class="math-container">\[\begin{aligned}
  \frac{\partial h}{\partial t} + \frac{\partial}{\partial x}(h v) &amp;= 0 \\
    \frac{\partial}{\partial t}(h v) + \frac{\partial}{\partial x}\left(h v^2 + \frac{g}{2}h^2\right)
    + g h \frac{\partial b}{\partial x} &amp;= 0
\end{aligned}\]</p><p>The unknown quantities of the SWE are the water height <span>$h$</span> and the velocity <span>$v$</span>. The gravitational constant is denoted by <code>g</code> and the (possibly) variable bottom topography function <span>$b(x)$</span>. Conservative variable water height <span>$h$</span> is measured from the bottom topography <span>$b$</span>, therefore one also defines the total water height as <span>$H = h + b$</span>.</p><p>The additional quantity <span>$H_0$</span> is also available to store a reference value for the total water height that is useful to set initial conditions or test the &quot;lake-at-rest&quot; well-balancedness.</p><p>The bottom topography function <span>$b(x)$</span> is set inside the initial condition routine for a particular problem setup. To test the conservative form of the SWE one can set the bottom topography variable <code>b</code> to zero.</p><p>In addition to the unknowns, Trixi.jl currently stores the bottom topography values at the approximation points despite being fixed in time. This is done for convenience of computing the bottom topography gradients on the fly during the approximation as well as computing auxiliary quantities like the total water height <span>$H$</span> or the entropy variables. This affects the implementation and use of these equations in various ways:</p><ul><li>The flux values corresponding to the bottom topography must be zero.</li><li>The bottom topography values must be included when defining initial conditions, boundary conditions or source terms.</li><li><a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> analyzes this variable.</li><li>Trixi.jl&#39;s visualization tools will visualize the bottom topography by default.</li></ul><p>References for the SWE are many but a good introduction is available in Chapter 13 of the book:</p><ul><li>Randall J. LeVeque (2002) Finite Volume Methods for Hyperbolic Problems <a href="https://doi.org/10.1017/CBO9780511791253">DOI: 10.1017/CBO9780511791253</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L8-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ShallowWaterEquations2D" href="#Trixi.ShallowWaterEquations2D"><code>Trixi.ShallowWaterEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShallowWaterEquations2D(; gravity, H0 = 0)</code></pre><p>Shallow water equations (SWE) in two space dimensions. The equations are given by</p><p class="math-container">\[\begin{aligned}
  \frac{\partial h}{\partial t} + \frac{\partial}{\partial x}(h v_1)
    + \frac{\partial}{\partial y}(h v_2) &amp;= 0 \\
    \frac{\partial}{\partial t}(h v_1) + \frac{\partial}{\partial x}\left(h v_1^2 + \frac{g}{2}h^2\right)
    + \frac{\partial}{\partial y}(h v_1 v_2) + g h \frac{\partial b}{\partial x} &amp;= 0 \\
    \frac{\partial}{\partial t}(h v_2) + \frac{\partial}{\partial x}(h v_1 v_2)
    + \frac{\partial}{\partial y}\left(h v_2^2 + \frac{g}{2}h^2\right) + g h \frac{\partial b}{\partial y} &amp;= 0.
\end{aligned}\]</p><p>The unknown quantities of the SWE are the water height <span>$h$</span> and the velocities <span>$\mathbf{v} = (v_1, v_2)^T$</span>. The gravitational constant is denoted by <code>g</code> and the (possibly) variable bottom topography function <span>$b(x,y)$</span>. Conservative variable water height <span>$h$</span> is measured from the bottom topography <span>$b$</span>, therefore one also defines the total water height as <span>$H = h + b$</span>.</p><p>The additional quantity <span>$H_0$</span> is also available to store a reference value for the total water height that is useful to set initial conditions or test the &quot;lake-at-rest&quot; well-balancedness.</p><p>The bottom topography function <span>$b(x,y)$</span> is set inside the initial condition routine for a particular problem setup. To test the conservative form of the SWE one can set the bottom topography variable <code>b</code> to zero.</p><p>In addition to the unknowns, Trixi.jl currently stores the bottom topography values at the approximation points despite being fixed in time. This is done for convenience of computing the bottom topography gradients on the fly during the approximation as well as computing auxiliary quantities like the total water height <span>$H$</span> or the entropy variables. This affects the implementation and use of these equations in various ways:</p><ul><li>The flux values corresponding to the bottom topography must be zero.</li><li>The bottom topography values must be included when defining initial conditions, boundary conditions or source terms.</li><li><a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> analyzes this variable.</li><li>Trixi.jl&#39;s visualization tools will visualize the bottom topography by default.</li></ul><p>References for the SWE are many but a good introduction is available in Chapter 13 of the book:</p><ul><li>Randall J. LeVeque (2002) Finite Volume Methods for Hyperbolic Problems <a href="https://doi.org/10.1017/CBO9780511791253">DOI: 10.1017/CBO9780511791253</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L8-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ShallowWaterEquationsQuasi1D" href="#Trixi.ShallowWaterEquationsQuasi1D"><code>Trixi.ShallowWaterEquationsQuasi1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShallowWaterEquationsQuasi1D(; gravity, H0 = 0, threshold_limiter = nothing threshold_wet = nothing)</code></pre><p>The quasi-1D shallow water equations (SWE). The equations are given by</p><p class="math-container">\[\begin{aligned}
  \frac{\partial}{\partial t}(a h) + \frac{\partial}{\partial x}(a h v) &amp;= 0 \\
    \frac{\partial}{\partial t}(a h v) + \frac{\partial}{\partial x}(a h v^2)
    + g a h \frac{\partial}{\partial x}(h + b) &amp;= 0
\end{aligned}\]</p><p>The unknown quantities of the Quasi-1D SWE are the water height <span>$h$</span> and the scaled velocity <span>$v$</span>. The gravitational constant is denoted by <code>g</code>, the (possibly) variable bottom topography function <span>$b(x)$</span>, and (possibly) variable channel width <span>$a(x)$</span>. The water height <span>$h$</span> is measured from the bottom topography <span>$b$</span>, therefore one also defines the total water height as <span>$H = h + b$</span>.</p><p>The additional quantity <span>$H_0$</span> is also available to store a reference value for the total water height that is useful to set initial conditions or test the &quot;lake-at-rest&quot; well-balancedness.</p><p>The bottom topography function <span>$b(x)$</span> and channel width <span>$a(x)$</span> are set inside the initial condition routine for a particular problem setup. To test the conservative form of the SWE one can set the bottom topography variable <code>b</code> to zero and <span>$a$</span> to one. </p><p>In addition to the unknowns, Trixi.jl currently stores the bottom topography and channel width values at the approximation points  despite being fixed in time. This is done for convenience of computing the bottom topography gradients on the fly during the approximation as well as computing auxiliary quantities like the total water height <span>$H$</span> or the entropy variables. This affects the implementation and use of these equations in various ways:</p><ul><li>The flux values corresponding to the bottom topography and channel width must be zero.</li><li>The bottom topography and channel width values must be included when defining initial conditions, boundary conditions or source terms.</li><li><a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> analyzes this variable.</li><li>Trixi.jl&#39;s visualization tools will visualize the bottom topography and channel width by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_quasi_1d.jl#L8-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SimpleSSPRK33" href="#Trixi.SimpleSSPRK33"><code>Trixi.SimpleSSPRK33</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleSSPRK33(; stage_callbacks=())</code></pre><p>The third-order SSP Runge-Kutta method of Shu and Osher.</p><p><strong>References</strong></p><ul><li>Shu, Osher (1988) &quot;Efficient Implementation of Essentially Non-oscillatory Shock-Capturing Schemes&quot; (Eq. 2.18) <a href="https://doi.org/10.1016/0021-9991(88)90177-5">DOI: 10.1016/0021-9991(88)90177-5</a></li></ul><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_SSP.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SteadyStateCallback" href="#Trixi.SteadyStateCallback"><code>Trixi.SteadyStateCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateCallback(; abstol=1.0e-8, reltol=1.0e-6)</code></pre><p>Terminates the integration when the <a href="#Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}"><code>residual_steady_state(du, equations)</code></a> falls below the threshold specified by <code>abstol, reltol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/steady_state.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.StepsizeCallback" href="#Trixi.StepsizeCallback"><code>Trixi.StepsizeCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StepsizeCallback(; cfl=1.0)</code></pre><p>Set the time step size according to a CFL condition with CFL number <code>cfl</code> if the time integration method isn&#39;t adaptive itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/stepsize.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.StructuredMesh" href="#Trixi.StructuredMesh"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh{NDIMS} &lt;: AbstractMesh{NDIMS}</code></pre><p>A structured curved mesh.</p><p>Different numbers of cells per dimension are possible and arbitrary functions can be used as domain faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/structured_mesh.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.StructuredMesh-Tuple{Any, Any, Any}" href="#Trixi.StructuredMesh-Tuple{Any, Any, Any}"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh(cells_per_dimension, coordinates_min, coordinates_max; periodicity=true)</code></pre><p>Create a StructuredMesh that represents a uncurved structured mesh with a rectangular domain.</p><p><strong>Arguments</strong></p><ul><li><code>cells_per_dimension::NTuple{NDIMS, Int}</code>: the number of cells in each dimension.</li><li><code>coordinates_min::NTuple{NDIMS, RealT}</code>: coordinate of the corner in the negative direction of each dimension.</li><li><code>coordinates_max::NTuple{NDIMS, RealT}</code>: coordinate of the corner in the positive direction of each dimension.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code> deciding for                each dimension if the boundaries in this dimension are periodic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/structured_mesh.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.StructuredMesh-Tuple{Any, Any}" href="#Trixi.StructuredMesh-Tuple{Any, Any}"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh(cells_per_dimension, mapping; RealT=Float64, unsaved_changes=true, mapping_as_string=mapping2string(mapping, length(cells_per_dimension)))</code></pre><p>Create a StructuredMesh of the given size and shape that uses <code>RealT</code> as coordinate type.</p><p><strong>Arguments</strong></p><ul><li><code>cells_per_dimension::NTupleE{NDIMS, Int}</code>: the number of cells in each dimension.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping, which transforms            the reference mesh to the physical domain.            If no <code>mapping_as_string</code> is defined, this function must be defined with the name <code>mapping</code>            to allow for restarts.            This will be changed in the future, see <a href="https://github.com/trixi-framework/Trixi.jl/issues/541">https://github.com/trixi-framework/Trixi.jl/issues/541</a>.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code>                deciding for each dimension if the boundaries in this dimension are periodic.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li><li><code>mapping_as_string::String</code>: the code that defines the <code>mapping</code>.                              If <code>CodeTracking</code> can&#39;t find the function definition, it can be passed directly here.                              The code string must define the mapping function with the name <code>mapping</code>.                              This will be changed in the future, see <a href="https://github.com/trixi-framework/Trixi.jl/issues/541">https://github.com/trixi-framework/Trixi.jl/issues/541</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/structured_mesh.jl#L25-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.StructuredMesh-Tuple{Any, Tuple}" href="#Trixi.StructuredMesh-Tuple{Any, Tuple}"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh(cells_per_dimension, faces; RealT=Float64, unsaved_changes=true, faces_as_string=faces2string(faces))</code></pre><p>Create a StructuredMesh of the given size and shape that uses <code>RealT</code> as coordinate type.</p><p><strong>Arguments</strong></p><ul><li><code>cells_per_dimension::NTupleE{NDIMS, Int}</code>: the number of cells in each dimension.</li><li><code>faces::NTuple{2*NDIMS}</code>: a tuple of <code>2 * NDIMS</code> functions that describe the faces of the domain.                           Each function must take <code>NDIMS-1</code> arguments.                           <code>faces[1]</code> describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by <code>faces[2]</code>.                           <code>faces[3:4]</code> describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           <code>faces[5:6]</code> describe the faces in positive and negative z-direction respectively (in 3D).</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code> deciding for                each dimension if the boundaries in this dimension are periodic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/structured_mesh.jl#L69-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.StructuredMeshView" href="#Trixi.StructuredMeshView"><code>Trixi.StructuredMeshView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StructuredMeshView{NDIMS, RealT &lt;: Real} &lt;: AbstractMesh{NDIMS}</code></pre><p>A view on a structured curved mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/structured_mesh_view.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.StructuredMeshView-Union{Tuple{StructuredMesh{NDIMS, RealT}}, Tuple{RealT}, Tuple{NDIMS}} where {NDIMS, RealT}" href="#Trixi.StructuredMeshView-Union{Tuple{StructuredMesh{NDIMS, RealT}}, Tuple{RealT}, Tuple{NDIMS}} where {NDIMS, RealT}"><code>Trixi.StructuredMeshView</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuredMeshView(parent; indices_min, indices_max)</code></pre><p>Create a StructuredMeshView on a StructuredMesh parent.</p><p><strong>Arguments</strong></p><ul><li><code>parent</code>: the parent StructuredMesh.</li><li><code>indices_min</code>: starting indices of the parent mesh.</li><li><code>indices_max</code>: ending indices of the parent mesh.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/structured_mesh_view.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SubcellLimiterIDP" href="#Trixi.SubcellLimiterIDP"><code>Trixi.SubcellLimiterIDP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubcellLimiterIDP(equations::AbstractEquations, basis;
                  local_twosided_variables_cons = String[],
                  positivity_variables_cons = String[],
                  positivity_variables_nonlinear = [],
                  positivity_correction_factor = 0.1,
                  local_onesided_variables_nonlinear = [],
                  max_iterations_newton = 10,
                  newton_tolerances = (1.0e-12, 1.0e-14),
                  gamma_constant_newton = 2 * ndims(equations))</code></pre><p>Subcell invariant domain preserving (IDP) limiting used with <a href="#Trixi.VolumeIntegralSubcellLimiting"><code>VolumeIntegralSubcellLimiting</code></a> including:</p><ul><li>Local two-sided Zalesak-type limiting for conservative variables (<code>local_twosided_variables_cons</code>)</li><li>Positivity limiting for conservative variables (<code>positivity_variables_cons</code>) and nonlinear variables</li></ul><p>(<code>positivity_variables_nonlinear</code>)</p><ul><li>Local one-sided limiting for nonlinear variables, e.g. <code>entropy_guermond_etal</code> and <code>entropy_math</code></li></ul><p>with <code>local_onesided_variables_nonlinear</code></p><p>To use these three limiting options use the following structure:</p><p>***Conservative variables*** to be limited are passed as a vector of strings, e.g. <code>local_twosided_variables_cons = [&quot;rho&quot;]</code> and <code>positivity_variables_cons = [&quot;rho&quot;]</code>. For ***nonlinear variables***, the wanted variable functions are passed within a vector: To ensure positivity use a plain vector including the desired variables, e.g. <code>positivity_variables_nonlinear = [pressure]</code>. For local one-sided limiting pass the variable function combined with the requested bound (<code>min</code> or <code>max</code>) as a tuple. For instance, to impose a lower local bound on the modified specific entropy by Guermond et al. use <code>local_onesided_variables_nonlinear = [(Trixi.entropy_guermond_etal, min)]</code>.</p><p>The bounds are calculated using the low-order FV solution. The positivity limiter uses <code>positivity_correction_factor</code> such that <code>u^new &gt;= positivity_correction_factor * u^FV</code>. Local and global limiting of nonlinear variables uses a Newton-bisection method with a maximum of <code>max_iterations_newton</code> iterations, relative and absolute tolerances of <code>newton_tolerances</code> and a provisional update constant <code>gamma_constant_newton</code> (<code>gamma_constant_newton&gt;=2*d</code>, where <code>d = #dimensions</code>). See equation (20) of Pazner (2020) and equation (30) of Rueda-Ramírez et al. (2022).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This limiter and the correction callback <a href="#Trixi.SubcellLimiterIDPCorrection"><code>SubcellLimiterIDPCorrection</code></a> only work together. Without the callback, no correction takes place, leading to a standard low-order FV scheme.</p></div></div><p><strong>References</strong></p><ul><li>Rueda-Ramírez, Pazner, Gassner (2022) Subcell Limiting Strategies for Discontinuous Galerkin Spectral Element Methods <a href="https://doi.org/10.1016/j.compfluid.2022.105627">DOI: 10.1016/j.compfluid.2022.105627</a></li><li>Pazner (2020) Sparse invariant domain preserving discontinuous Galerkin methods with subcell convex limiting <a href="https://doi.org/10.1016/j.cma.2021.113876">DOI: 10.1016/j.cma.2021.113876</a></li></ul><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/subcell_limiters.jl#L15-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SubcellLimiterIDPCorrection" href="#Trixi.SubcellLimiterIDPCorrection"><code>Trixi.SubcellLimiterIDPCorrection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubcellLimiterIDPCorrection()</code></pre><p>Perform antidiffusive correction stage for the a posteriori IDP limiter <a href="#Trixi.SubcellLimiterIDP"><code>SubcellLimiterIDP</code></a> called with <a href="#Trixi.VolumeIntegralSubcellLimiting"><code>VolumeIntegralSubcellLimiting</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This callback and the actual limiter <a href="#Trixi.SubcellLimiterIDP"><code>SubcellLimiterIDP</code></a> only work together. This is not a replacement but a necessary addition.</p></div></div><p><strong>References</strong></p><ul><li>Rueda-Ramírez, Pazner, Gassner (2022) Subcell Limiting Strategies for Discontinuous Galerkin Spectral Element Methods <a href="https://doi.org/10.1016/j.compfluid.2022.105627">DOI: 10.1016/j.compfluid.2022.105627</a></li><li>Pazner (2020) Sparse invariant domain preserving discontinuous Galerkin methods with subcell convex limiting <a href="https://doi.org/10.1016/j.cma.2021.113876">DOI: 10.1016/j.cma.2021.113876</a></li></ul><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_stage/subcell_limiter_idp_correction.jl#L8-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SurfaceIntegralStrongForm" href="#Trixi.SurfaceIntegralStrongForm"><code>Trixi.SurfaceIntegralStrongForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurfaceIntegralStrongForm(surface_flux=flux_central)</code></pre><p>The classical strong form surface integral type for FD/DG methods.</p><p>See also <a href="#Trixi.VolumeIntegralStrongForm"><code>VolumeIntegralStrongForm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L324-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SurfaceIntegralUpwind" href="#Trixi.SurfaceIntegralUpwind"><code>Trixi.SurfaceIntegralUpwind</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurfaceIntegralUpwind(splitting)</code></pre><p>Couple elements with upwind simultaneous approximation terms (SATs) that use a particular flux <code>splitting</code>, e.g., <a href="#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations1D}"><code>splitting_steger_warming</code></a>.</p><p>See also <a href="#Trixi.VolumeIntegralUpwind"><code>VolumeIntegralUpwind</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L352-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SurfaceIntegralWeakForm" href="#Trixi.SurfaceIntegralWeakForm"><code>Trixi.SurfaceIntegralWeakForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurfaceIntegralWeakForm(surface_flux=flux_central)</code></pre><p>The classical weak form surface integral type for DG methods as explained in standard textbooks.</p><p>See also <a href="#Trixi.VolumeIntegralWeakForm"><code>VolumeIntegralWeakForm</code></a>.</p><p><strong>References</strong></p><ul><li>Kopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers <a href="https://doi.org/10.1007/978-90-481-2261-5">doi: 10.1007/978-90-481-2261-5</a></li><li>Hesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications <a href="https://doi.org/10.1007/978-0-387-72067-8">doi: 10.1007/978-0-387-72067-8</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L286-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh" href="#Trixi.T8codeMesh"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh{NDIMS} &lt;: AbstractMesh{NDIMS}</code></pre><p>An unstructured curved mesh based on trees that uses the C library <a href="https://github.com/DLR-AMR/t8code">&#39;t8code&#39;</a> to manage trees and mesh refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Tuple{Any}" href="#Trixi.T8codeMesh-Tuple{Any}"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh(trees_per_dimension; polydeg, mapping=identity,
           RealT=Float64, initial_refinement_level=0, periodicity=true)</code></pre><p>Create a structured potentially curved &#39;T8codeMesh&#39; of the specified size.</p><p>Non-periodic boundaries will be called &#39;:x<em>neg&#39;, &#39;:x</em>pos&#39;, &#39;:y<em>neg&#39;, &#39;:y</em>pos&#39;, &#39;:z<em>neg&#39;, &#39;:z</em>pos&#39;.</p><p><strong>Arguments</strong></p><ul><li>&#39;trees<em>per</em>dimension::NTupleE{NDIMS, Int}&#39;: the number of trees in each dimension.</li><li>&#39;polydeg::Integer&#39;: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the reference mesh (<code>[-1, 1]^n</code>) to the physical domain.            Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>faces::NTuple{2*NDIMS}</code>: a tuple of <code>2 * NDIMS</code> functions that describe the faces of the domain.                           Each function must take <code>NDIMS-1</code> arguments.                           <code>faces[1]</code> describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by <code>faces[2]</code>.                           <code>faces[3:4]</code> describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           <code>faces[5:6]</code> describe the faces in positive and negative z-direction respectively (in 3D).                           Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>coordinates_min</code>: vector or tuple of the coordinates of the corner in the negative direction of each dimension                    to create a rectangular mesh.                    Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>coordinates_max</code>: vector or tuple of the coordinates of the corner in the positive direction of each dimension                    to create a rectangular mesh.                    Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li>&#39;RealT::Type&#39;: the type that should be used for coordinates.</li><li>&#39;initial<em>refinement</em>level::Integer&#39;: refine the mesh uniformly to this level before the simulation starts.</li><li>&#39;periodicity&#39;: either a &#39;Bool&#39; deciding if all of the boundaries are periodic or an &#39;NTuple{NDIMS, Bool}&#39;                deciding for each dimension if the boundaries in this dimension are periodic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L226-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Tuple{Ptr{P4est.LibP4est.p4est_connectivity}}" href="#Trixi.T8codeMesh-Tuple{Ptr{P4est.LibP4est.p4est_connectivity}}"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh(conn::Ptr{p4est_connectivity}; kwargs...)</code></pre><p>Main mesh constructor for the <code>T8codeMesh</code> that imports an unstructured, conforming mesh from a <code>p4est_connectivity</code> data structure.</p><p><strong>Arguments</strong></p><ul><li><code>conn::Ptr{p4est_connectivity}</code>: Pointer to a P4est connectivity object.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L386-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Tuple{Ptr{P4est.LibP4est.p8est_connectivity}}" href="#Trixi.T8codeMesh-Tuple{Ptr{P4est.LibP4est.p8est_connectivity}}"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh(conn::Ptr{p8est_connectivity}; kwargs...)</code></pre><p>Main mesh constructor for the <code>T8codeMesh</code> that imports an unstructured, conforming mesh from a <code>p4est_connectivity</code> data structure.</p><p><strong>Arguments</strong></p><ul><li><code>conn::Ptr{p4est_connectivity}</code>: Pointer to a P4est connectivity object.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L410-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Tuple{Ptr{T8code.Libt8.t8_cmesh}}" href="#Trixi.T8codeMesh-Tuple{Ptr{T8code.Libt8.t8_cmesh}}"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh(cmesh::Ptr{t8_cmesh},
           mapping=nothing, polydeg=1, RealT=Float64,
           initial_refinement_level=0)</code></pre><p>Main mesh constructor for the <code>T8codeMesh</code> that imports an unstructured, conforming mesh from a <code>t8_cmesh</code> data structure.</p><p><strong>Arguments</strong></p><ul><li><code>cmesh::Ptr{t8_cmesh}</code>: Pointer to a cmesh object.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L344-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Tuple{String, Any}" href="#Trixi.T8codeMesh-Tuple{String, Any}"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh(meshfile::String, NDIMS; kwargs...)</code></pre><p>Main mesh constructor for the <code>T8codeMesh</code> that imports an unstructured, conforming mesh from either a Gmsh mesh file (<code>.msh</code>) or Abaqus mesh file  (<code>.inp</code>) which is determined by the file extension.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code>: path to a Gmsh or Abaqus mesh file.</li><li><code>ndims</code>: Mesh file dimension: <code>2</code> or <code>3</code>.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>mapping</code>: A function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: Polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: The type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: Refine the mesh uniformly to this level before the simulation starts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L443-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Union{Tuple{RealT}, Tuple{NDIMS}, Tuple{Ptr{T8code.Libt8.t8_forest}, Any}} where {NDIMS, RealT}" href="#Trixi.T8codeMesh-Union{Tuple{RealT}, Tuple{NDIMS}, Tuple{Ptr{T8code.Libt8.t8_forest}, Any}} where {NDIMS, RealT}"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh{NDIMS, RealT}(forest, boundary_names; polydeg = 1, mapping = nothing)</code></pre><p>Main mesh constructor for the <code>T8codeMesh</code> wrapping around a given t8code <code>forest</code> object. This constructor is typically called by other <code>T8codeMesh</code> constructors.</p><p><strong>Arguments</strong></p><ul><li><code>forest</code>: Pointer to a t8code forest.</li><li><code>boundary_names</code>: List of boundary names.</li><li><code>polydeg::Integer</code>: Polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.</li><li><code>mapping</code>: A function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L103-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Union{Tuple{Trixi.AbaqusFile{NDIMS}}, Tuple{NDIMS}} where NDIMS" href="#Trixi.T8codeMesh-Union{Tuple{Trixi.AbaqusFile{NDIMS}}, Tuple{NDIMS}} where NDIMS"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh(meshfile::AbaqusFile{NDIMS};
           mapping=nothing, polydeg=1, RealT=Float64,
           initial_refinement_level=0, unsaved_changes=true,
           boundary_symbols = nothing)</code></pre><p>Main mesh constructor for the <code>T8codeMesh</code> that imports an unstructured, conforming mesh from an Abaqus mesh file (<code>.inp</code>).</p><p>To create a curved unstructured <code>T8codeMesh</code> two strategies are available:</p><ul><li><p><code>HOHQMesh Abaqus</code>: High-order, curved boundary information created by                    <a href="https://github.com/trixi-framework/HOHQMesh.jl"><code>HOHQMesh.jl</code></a> is                    available in the <code>meshfile</code>. The mesh polynomial degree <code>polydeg</code>                    of the boundaries is provided from the <code>meshfile</code>. The computation of                    the mapped tree coordinates is done with transfinite interpolation                    with linear blending similar to <a href="#Trixi.UnstructuredMesh2D"><code>UnstructuredMesh2D</code></a>. Boundary name                    information is also parsed from the <code>meshfile</code> such that different boundary                    conditions can be set at each named boundary on a given tree.</p></li><li><p><code>Standard Abaqus</code>: By default, with <code>mapping=nothing</code> and <code>polydeg=1</code>, this creates a                    straight-sided mesh from the information parsed from the <code>meshfile</code>. If a mapping                    function is specified then it computes the mapped tree coordinates via polynomial                    interpolants with degree <code>polydeg</code>. The mesh created by this function will only                    have one boundary <code>:all</code> if <code>boundary_symbols</code> is not specified.                    If <code>boundary_symbols</code> is specified the mesh file will be parsed for nodesets defining                    the boundary nodes from which boundary edges (2D) and faces (3D) will be assigned.</p></li></ul><p>Note that the <code>mapping</code> and <code>polydeg</code> keyword arguments are only used by the <code>HOHQMesh Abaqus</code> option. The <code>Standard Abaqus</code> routine obtains the mesh <code>polydeg</code> directly from the <code>meshfile</code> and constructs the transfinite mapping internally.</p><p>The particular strategy is selected according to the header present in the <code>meshfile</code> where the constructor checks whether or not the <code>meshfile</code> was created with <a href="https://github.com/trixi-framework/HOHQMesh.jl">HOHQMesh.jl</a>. If the Abaqus file header is not present in the <code>meshfile</code> then the <code>T8codeMesh</code> is created by <code>Standard Abaqus</code>.</p><p>The default keyword argument <code>initial_refinement_level=0</code> corresponds to a forest where the number of trees is the same as the number of elements in the original <code>meshfile</code>. Increasing the <code>initial_refinement_level</code> allows one to uniformly refine the base mesh given in the <code>meshfile</code> to create a forest with more trees before the simulation begins. For example, if a two-dimensional base mesh contains 25 elements then setting <code>initial_refinement_level=1</code> creates an initial forest of <code>2^2 * 25 = 100</code> trees.</p><p><strong>Arguments</strong></p><ul><li><code>meshfile::AbaqusFile{NDIMS}</code>: Abaqus mesh file object of dimension NDIMS and given <code>path</code> to the file.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>mapping</code>: A function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: Polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: The type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: Refine the mesh uniformly to this level before the simulation starts.</li><li><code>boundary_symbols::Vector{Symbol}</code>: A vector of symbols that correspond to the boundary names in the <code>meshfile</code>.                                     If <code>nothing</code> is passed then all boundaries are named <code>:all</code>.                                                </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L515-L575">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.T8codeMesh-Union{Tuple{Trixi.GmshFile{NDIMS}}, Tuple{NDIMS}} where NDIMS" href="#Trixi.T8codeMesh-Union{Tuple{Trixi.GmshFile{NDIMS}}, Tuple{NDIMS}} where NDIMS"><code>Trixi.T8codeMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T8codeMesh(meshfile::GmshFile{NDIMS}; kwargs...)</code></pre><p>Main mesh constructor for the <code>T8codeMesh</code> that imports an unstructured, conforming mesh from a Gmsh mesh file (<code>.msh</code>).</p><p><strong>Arguments</strong></p><ul><li><code>meshfile::GmshFile{NDIMS}</code>: Gmsh mesh file object of dimension NDIMS and give <code>path</code> to the file.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>mapping</code>: A function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: Polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: The type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: Refine the mesh uniformly to this level before the simulation starts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L484-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.TimeSeriesCallback" href="#Trixi.TimeSeriesCallback"><code>Trixi.TimeSeriesCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeSeriesCallback(semi, point_coordinates;
                   interval=1, solution_variables=cons2cons,
                   output_directory=&quot;out&quot;, filename=&quot;time_series.h5&quot;,
                   RealT=real(solver), uEltype=eltype(cache.elements))</code></pre><p>Create a callback that records point-wise data at points given in <code>point_coordinates</code> every <code>interval</code> time steps. The point coordinates are to be specified either as a vector of coordinate tuples or as a two-dimensional array where the first dimension is the point number and the second dimension is the coordinate dimension. By default, the conservative variables are recorded, but this can be controlled by passing a different conversion function to <code>solution_variables</code>.</p><p>After the last time step, the results are stored in an HDF5 file <code>filename</code> in directory <code>output_directory</code>.</p><p>The real data type <code>RealT</code> and data type for solution variables <code>uEltype</code> default to the respective types used in the solver and the cache.</p><p>Currently this callback is only implemented for <a href="#Trixi.TreeMesh"><code>TreeMesh</code></a> and <a href="#Trixi.UnstructuredMesh2D"><code>UnstructuredMesh2D</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/time_series.jl#L8-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.TrafficFlowLWREquations1D" href="#Trixi.TrafficFlowLWREquations1D"><code>Trixi.TrafficFlowLWREquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrafficFlowLWREquations1D</code></pre><p>The classic Lighthill-Witham Richards (LWR) model for 1D traffic flow. The car density is denoted by <span>$u \in [0, 1]$</span> and  the maximum possible speed (e.g. due to speed limits) is <span>$v_{\text{max}}$</span>.</p><p class="math-container">\[\partial_t u + v_{\text{max}} \partial_1 [u (1 - u)] = 0\]</p><p>For more details see e.g. Section 11.1 of </p><ul><li>Randall LeVeque (2002)</li></ul><p>Finite Volume Methods for Hyperbolic Problems [DOI: 10.1017/CBO9780511791253]https://doi.org/10.1017/CBO9780511791253</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/traffic_flow_lwr_1d.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.TreeMesh" href="#Trixi.TreeMesh"><code>Trixi.TreeMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreeMesh{NDIMS} &lt;: AbstractMesh{NDIMS}</code></pre><p>A Cartesian mesh based on trees of hypercubes to support adaptive mesh refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/tree_mesh.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.UnstructuredMesh2D" href="#Trixi.UnstructuredMesh2D"><code>Trixi.UnstructuredMesh2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnstructuredMesh2D &lt;: AbstractMesh{2}</code></pre><p>An unstructured (possibly curved) quadrilateral mesh.</p><pre><code class="nohighlight hljs">UnstructuredMesh2D(filename; RealT=Float64, periodicity=false)</code></pre><p>All mesh information, neighbour coupling, and boundary curve information is read in from a mesh file <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/unstructured_mesh.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.UnstructuredSortedBoundaryTypes" href="#Trixi.UnstructuredSortedBoundaryTypes"><code>Trixi.UnstructuredSortedBoundaryTypes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnstructuredSortedBoundaryTypes</code></pre><p>General container to sort the boundary conditions by type and name for some unstructured meshes/solvers. It stores a set of global indices for each boundary condition type and name to expedite computation during the call to <code>calc_boundary_flux!</code>. The original dictionary form of the boundary conditions set by the user in the elixir file is also stored for printing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_unstructured/sort_boundary_conditions.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ViscousFormulationBassiRebay1" href="#Trixi.ViscousFormulationBassiRebay1"><code>Trixi.ViscousFormulationBassiRebay1</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ViscousFormulationBassiRebay1()</p><p>The classical BR1 flux from</p><ul><li>F. Bassi, S. Rebay (1997) A High-Order Accurate Discontinuous Finite Element Method for the Numerical Solution of the Compressible Navier-Stokes Equations <a href="https://doi.org/10.1006/jcph.1996.5572">DOI: 10.1006/jcph.1996.5572</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/solvers_parabolic.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ViscousFormulationLocalDG" href="#Trixi.ViscousFormulationLocalDG"><code>Trixi.ViscousFormulationLocalDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ViscousFormulationLocalDG(penalty_parameter)</code></pre><p>The local DG (LDG) flux from &quot;The Local Discontinuous Galerkin Method for Time-Dependent Convection-Diffusion Systems&quot; by Cockburn and Shu (1998).</p><p>Note that, since this implementation does not involve the parabolic &quot;upwinding&quot; vector, the LDG solver is equivalent to <a href="#Trixi.ViscousFormulationBassiRebay1"><code>ViscousFormulationBassiRebay1</code></a> with an LDG-type penalization.</p><ul><li>Cockburn and Shu (1998). The Local Discontinuous Galerkin Method for Time-Dependent Convection-Diffusion Systems <a href="https://doi.org/10.1137/S0036142997316712">DOI: 10.1137/S0036142997316712</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/solvers_parabolic.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VisualizationCallback-Tuple{}" href="#Trixi.VisualizationCallback-Tuple{}"><code>Trixi.VisualizationCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VisualizationCallback(; interval=0,
                        solution_variables=cons2prim,
                        variable_names=[],
                        show_mesh=false,
                        plot_data_creator=PlotData2D,
                        plot_creator=show_plot,
                        plot_arguments...)</code></pre><p>Create a callback that visualizes results during a simulation, also known as <em>in-situ visualization</em>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in any future releases.</p></div></div><p>The <code>interval</code> specifies the number of time step iterations after which a new plot is generated. The available variables to plot are configured with the <code>solution_variables</code> parameter, which acts the same way as for the <a href="#Trixi.SaveSolutionCallback"><code>SaveSolutionCallback</code></a>. The variables to be actually plotted can be selected by providing a single string or a list of strings to <code>variable_names</code>, and if <code>show_mesh</code> is <code>true</code>, an additional plot with the mesh will be generated.</p><p>To customize the generated figure, <code>plot_data_creator</code> allows to use different plot data types. With <code>plot_creator</code> you can further specify an own function to visualize results, which must support the same interface as the default implementation <a href="#Trixi.show_plot-Tuple{Any, Any}"><code>show_plot</code></a>. All remaining keyword arguments are collected and passed as additional arguments to the plotting command.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/visualization.jl#L59-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VolumeIntegralFluxDifferencing" href="#Trixi.VolumeIntegralFluxDifferencing"><code>Trixi.VolumeIntegralFluxDifferencing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralFluxDifferencing(volume_flux)</code></pre><p>Volume integral type for DG methods based on SBP operators and flux differencing using a symmetric two-point <code>volume_flux</code>. This <code>volume_flux</code> needs to satisfy the interface of numerical fluxes in Trixi.jl.</p><p><strong>References</strong></p><ul><li>LeFloch, Mercier, Rohde (2002) Fully Discrete, Entropy Conservative Schemes of Arbitrary Order <a href="https://doi.org/10.1137/S003614290240069X">doi: 10.1137/S003614290240069X</a></li><li>Fisher, Carpenter (2013) High-order entropy stable finite difference schemes for nonlinear conservation laws: Finite domains <a href="https://doi.org/10.1016/j.jcp.2013.06.014">doi: 10.1016/j.jcp.2013.06.014</a></li><li>Hendrik Ranocha (2017) Comparison of Some Entropy Conservative Numerical Fluxes for the Euler Equations <a href="https://arxiv.org/abs/1701.02264">arXiv: 1701.02264</a> <a href="https://doi.org/10.1007/s10915-017-0618-1">doi: 10.1007/s10915-017-0618-1</a></li><li>Chen, Shu (2017) Entropy stable high order discontinuous Galerkin methods with suitable quadrature rules for hyperbolic conservation laws <a href="https://doi.org/10.1016/j.jcp.2017.05.025">doi: 10.1016/j.jcp.2017.05.025</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L53-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VolumeIntegralPureLGLFiniteVolume" href="#Trixi.VolumeIntegralPureLGLFiniteVolume"><code>Trixi.VolumeIntegralPureLGLFiniteVolume</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralPureLGLFiniteVolume(volume_flux_fv)</code></pre><p>A volume integral that only uses the subcell finite volume schemes of the <a href="#Trixi.VolumeIntegralShockCapturingHG"><code>VolumeIntegralShockCapturingHG</code></a>.</p><p>This gives a formally O(1)-accurate finite volume scheme on an LGL-type subcell mesh (LGL = Legendre-Gauss-Lobatto).</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>Hennemann, Gassner (2020) &quot;A provably entropy stable subcell shock capturing approach for high order split form DG&quot; <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L150-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VolumeIntegralShockCapturingHG" href="#Trixi.VolumeIntegralShockCapturingHG"><code>Trixi.VolumeIntegralShockCapturingHG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralShockCapturingHG(indicator; volume_flux_dg=flux_central,
                                          volume_flux_fv=flux_lax_friedrichs)</code></pre><p>Shock-capturing volume integral type for DG methods using a convex blending of the finite volume method with numerical flux <code>volume_flux_fv</code> and the <a href="#Trixi.VolumeIntegralFluxDifferencing"><code>VolumeIntegralFluxDifferencing</code></a> with volume flux <code>volume_flux_dg</code>. The amount of blending is determined by the <code>indicator</code>, e.g., <a href="#Trixi.IndicatorHennemannGassner"><code>IndicatorHennemannGassner</code></a>.</p><p><strong>References</strong></p><ul><li>Hennemann, Gassner (2020) &quot;A provably entropy stable subcell shock capturing approach for high order split form DG&quot; <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L95-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VolumeIntegralStrongForm" href="#Trixi.VolumeIntegralStrongForm"><code>Trixi.VolumeIntegralStrongForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralStrongForm()</code></pre><p>The classical strong form volume integral type for FD/DG methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VolumeIntegralSubcellLimiting" href="#Trixi.VolumeIntegralSubcellLimiting"><code>Trixi.VolumeIntegralSubcellLimiting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralSubcellLimiting(limiter;
                              volume_flux_dg, volume_flux_fv)</code></pre><p>A subcell limiting volume integral type for DG methods based on subcell blending approaches with a low-order FV method. Used with limiter <a href="#Trixi.SubcellLimiterIDP"><code>SubcellLimiterIDP</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Subcell limiting methods are not fully functional on non-conforming meshes. This is mainly because the implementation assumes that low- and high-order schemes have the same surface terms, which is not guaranteed for non-conforming meshes. The low-order scheme with a high-order mortar is not invariant domain preserving.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L187-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VolumeIntegralUpwind" href="#Trixi.VolumeIntegralUpwind"><code>Trixi.VolumeIntegralUpwind</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralUpwind(splitting)</code></pre><p>Specialized volume integral for finite difference summation-by-parts (FDSBP) solvers. Can be used together with the upwind SBP operators of Mattsson (2017) implemented in SummationByPartsOperators.jl. The <code>splitting</code> controls the discretization.</p><p>See also <a href="#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations1D}"><code>splitting_steger_warming</code></a>, <a href="#Trixi.splitting_lax_friedrichs-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>splitting_lax_friedrichs</code></a>, <a href="#Trixi.splitting_vanleer_haenel-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>splitting_vanleer_haenel</code></a>.</p><p><strong>References</strong></p><ul><li>Mattsson (2017) Diagonal-norm upwind SBP operators <a href="https://doi.org/10.1016/j.jcp.2017.01.042">doi: 10.1016/j.jcp.2017.01.042</a></li></ul><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L247-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.VolumeIntegralWeakForm" href="#Trixi.VolumeIntegralWeakForm"><code>Trixi.VolumeIntegralWeakForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralWeakForm()</code></pre><p>The classical weak form volume integral type for DG methods as explained in standard textbooks.</p><p><strong>References</strong></p><ul><li>Kopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers <a href="https://doi.org/10.1007/978-90-481-2261-5">doi: 10.1007/978-90-481-2261-5</a></li><li>Hesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications <a href="https://doi.org/10.1007/978-0-387-72067-8">doi: 10.1007/978-0-387-72067-8</a></li></ul><p><code>VolumeIntegralWeakForm()</code> is only implemented for conserved terms as non-conservative terms should always be discretized in conjunction with a flux-splitting scheme, see <a href="#Trixi.VolumeIntegralFluxDifferencing"><code>VolumeIntegralFluxDifferencing</code></a>. This treatment is required to achieve, e.g., entropy-stability or well-balancedness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L27-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{Trixi.AbstractPlotData, Any}" href="#Base.getindex-Tuple{Trixi.AbstractPlotData, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(pd::AbstractPlotData, variable_name)</code></pre><p>Extract a single variable <code>variable_name</code> from <code>pd</code> for plotting with <code>Plots.plot</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.resize!-Tuple{Trixi.AbstractContainer, Any}" href="#Base.resize!-Tuple{Trixi.AbstractContainer, Any}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize!(c::AbstractContainer, new_length) -&gt; AbstractContainer</code></pre><p>Resize <code>c</code> to contain <code>new_length</code> elements. If <code>new_length</code> is smaller than the current container length, the first <code>new_length</code> elements will be retained. If <code>new_length</code> is larger, the new elements are invalidated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/containers.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialBases.compute_coefficients!-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization}" href="#PolynomialBases.compute_coefficients!-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization}"><code>PolynomialBases.compute_coefficients!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_coefficients!(u_ode, func, t, semi::AbstractSemidiscretization)</code></pre><p>Same as <a href="#PolynomialBases.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}"><code>compute_coefficients</code></a> but stores the result in <code>u_ode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialBases.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}" href="#PolynomialBases.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}"><code>PolynomialBases.compute_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_coefficients(func, t, semi::AbstractSemidiscretization)</code></pre><p>Compute the discrete coefficients of the continuous function <code>func</code> at time <code>t</code> associated with the semidiscretization <code>semi</code>. For example, the discrete coefficients of <code>func</code> for a discontinuous Galerkin spectral element method (<a href="#Trixi.DGSEM"><code>DGSEM</code></a>) are the values of <code>func</code> at the Lobatto-Legendre nodes. Similarly, a classical finite difference method will use the values of <code>func</code> at the nodes of the grid assoociated with the semidiscretization <code>semi</code>.</p><p>For semidiscretizations <code>semi</code> associated with an initial condition, <code>func</code> can be omitted to use the given initial condition at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L117-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialBases.integrate-Tuple{Any, Any, LobattoLegendreBasis}" href="#PolynomialBases.integrate-Tuple{Any, Any, LobattoLegendreBasis}"><code>PolynomialBases.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate(f, u, basis::LobattoLegendreBasis)</code></pre><p>Map the function <code>f</code> to the coefficients <code>u</code> and integrate with respect to the quadrature rule given by <code>basis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialBases.integrate-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization}} where Func" href="#PolynomialBases.integrate-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization}} where Func"><code>PolynomialBases.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate([func=(u_node,equations)-&gt;u_node,] u_ode, semi::AbstractSemidiscretization; normalize=true)</code></pre><p>Call <code>func(u_node, equations)</code> for each vector of nodal variables <code>u_node</code> in <code>u_ode</code> and integrate the result using a quadrature associated with the semidiscretization <code>semi</code>.</p><p>If <code>normalize</code> is true, the result is divided by the total volume of the computational domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.add_tstop!-Tuple{Trixi.SimpleIntegratorSSP, Any}" href="#SciMLBase.add_tstop!-Tuple{Trixi.SimpleIntegratorSSP, Any}"><code>SciMLBase.add_tstop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_tstop!(integrator::SimpleIntegratorSSP, t)</code></pre><p>Add a time stop during the time integration process. This function is called after the periodic SaveSolutionCallback to specify the next stop to save the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_SSP.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperators.semidiscretize-Tuple{SemidiscretizationHyperbolicParabolic, Any}" href="#SummationByPartsOperators.semidiscretize-Tuple{SemidiscretizationHyperbolicParabolic, Any}"><code>SummationByPartsOperators.semidiscretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">semidiscretize(semi::SemidiscretizationHyperbolicParabolic, tspan)</code></pre><p>Wrap the semidiscretization <code>semi</code> as a split ODE problem in the time interval <code>tspan</code> that can be passed to <code>solve</code> from the <a href="https://diffeq.sciml.ai/latest/">SciML ecosystem</a>. The parabolic right-hand side is the first function of the split ODE problem and will be used by default by the implicit part of IMEX methods from the SciML ecosystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization_hyperbolic_parabolic.jl#L269-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperators.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any, AbstractString}" href="#SummationByPartsOperators.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any, AbstractString}"><code>SummationByPartsOperators.semidiscretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">semidiscretize(semi::AbstractSemidiscretization, tspan, restart_file::AbstractString)</code></pre><p>Wrap the semidiscretization <code>semi</code> as an ODE problem in the time interval <code>tspan</code> that can be passed to <code>solve</code> from the <a href="https://diffeq.sciml.ai/latest/">SciML ecosystem</a>. The initial condition etc. is taken from the <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperators.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any}" href="#SummationByPartsOperators.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any}"><code>SummationByPartsOperators.semidiscretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">semidiscretize(semi::AbstractSemidiscretization, tspan)</code></pre><p>Wrap the semidiscretization <code>semi</code> as an ODE problem in the time interval <code>tspan</code> that can be passed to <code>solve</code> from the <a href="https://diffeq.sciml.ai/latest/">SciML ecosystem</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.DGMultiBasis-Tuple{Any, Any}" href="#Trixi.DGMultiBasis-Tuple{Any, Any}"><code>Trixi.DGMultiBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMultiBasis(element_type, polydeg; approximation_type = Polynomial(), kwargs...)</code></pre><p>Constructs a basis for DGMulti solvers. Returns a &quot;StartUpDG.RefElemData&quot; object.   The <code>kwargs</code> arguments are additional keyword arguments for <code>RefElemData</code>, such as <code>quad_rule_vol</code>.   These are the same as the <code>RefElemData_kwargs</code> used in <a href="../meshes/dgmulti_mesh/#DGMulti"><code>DGMulti</code></a>.   For more info, see the <a href="https://jlchan.github.io/StartUpDG.jl/dev/">StartUpDG.jl docs</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/types.jl#L128-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.LBMCollisionCallback-Tuple{}" href="#Trixi.LBMCollisionCallback-Tuple{}"><code>Trixi.LBMCollisionCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LBMCollisionCallback()</code></pre><p>Apply the Lattice-Boltzmann method (LBM) collision operator before each time step. See <a href="#Trixi.LatticeBoltzmannEquations2D"><code>LatticeBoltzmannEquations2D</code></a> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/lbm_collision.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.P4estMeshCubedSphere-NTuple{4, Any}" href="#Trixi.P4estMeshCubedSphere-NTuple{4, Any}"><code>Trixi.P4estMeshCubedSphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P4estMeshCubedSphere(trees_per_face_dimension, layers, inner_radius, thickness;
                     polydeg, RealT=Float64,
                     initial_refinement_level=0, unsaved_changes=true,
                     p4est_partition_allow_for_coarsening=true)</code></pre><p>Build a &quot;Cubed Sphere&quot; mesh as <code>P4estMesh</code> with <code>6 * trees_per_face_dimension^2 * layers</code> trees.</p><p>The mesh will have two boundaries, <code>:inside</code> and <code>:outside</code>.</p><p><strong>Arguments</strong></p><ul><li><code>trees_per_face_dimension::Integer</code>: the number of trees in the first two local dimensions of                                      each face.</li><li><code>layers::Integer</code>: the number of trees in the third local dimension of each face, i.e., the number                    of layers of the sphere.</li><li><code>inner_radius::Integer</code>: the inner radius of the sphere.</li><li><code>thickness::Integer</code>: the thickness of the sphere. The outer radius will be <code>inner_radius + thickness</code>.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li><li><code>p4est_partition_allow_for_coarsening::Bool</code>: Must be <code>true</code> when using AMR to make mesh adaptivity                                               independent of domain partitioning. Should be <code>false</code> for static meshes                                               to permit more fine-grained partitioning.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/p4est_mesh.jl#L717-L744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PlotData2D-Tuple{Any, Any}" href="#Trixi.PlotData2D-Tuple{Any, Any}"><code>Trixi.PlotData2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlotData2D(u, semi [or mesh, equations, solver, cache];
           solution_variables=nothing,
           grid_lines=true, max_supported_level=11, nvisnodes=nothing,
           slice=:xy, point=(0.0, 0.0, 0.0))</code></pre><p>Create a new <code>PlotData2D</code> object that can be used for visualizing 2D/3D DGSEM solution data array <code>u</code> with <code>Plots.jl</code>. All relevant geometrical information is extracted from the semidiscretization <code>semi</code>. By default, the primitive variables (if existent) or the conservative variables (otherwise) from the solution are used for plotting. This can be changed by passing an appropriate conversion function to <code>solution_variables</code>.</p><p>If <code>grid_lines</code> is <code>true</code>, also extract grid vertices for visualizing the mesh. The output resolution is indirectly set via <code>max_supported_level</code>: all data is interpolated to <code>2^max_supported_level</code> uniformly distributed points in each spatial direction, also setting the maximum allowed refinement level in the solution. <code>nvisnodes</code> specifies the number of visualization nodes to be used. If it is <code>nothing</code>, twice the number of solution DG nodes are used for visualization, and if set to <code>0</code>, exactly the number of nodes in the DG elements are used.</p><p>When visualizing data from a three-dimensional simulation, a 2D slice is extracted for plotting. <code>slice</code> specifies the plane that is being sliced and may be <code>:xy</code>, <code>:xz</code>, or <code>:yz</code>. The slice position is specified by a <code>point</code> that lies on it, which defaults to <code>(0.0, 0.0, 0.0)</code>. Both of these values are ignored when visualizing 2D data.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Trixi, Plots

julia&gt; trixi_include(default_example())
[...]

julia&gt; pd = PlotData2D(sol)
PlotData2D(...)

julia&gt; plot(pd) # To plot all available variables

julia&gt; plot(pd[&quot;scalar&quot;]) # To plot only a single variable

julia&gt; plot!(getmesh(pd)) # To add grid lines to the plot</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L186-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.PlotData2D-Tuple{Union{ODESolution{T, N, uType, uType2, DType, tType, rateType, P} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(ODEProblem{uType_, tType_, isinplace, P_} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization})}, Trixi.TimeIntegratorSolution}}" href="#Trixi.PlotData2D-Tuple{Union{ODESolution{T, N, uType, uType2, DType, tType, rateType, P} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(ODEProblem{uType_, tType_, isinplace, P_} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization})}, Trixi.TimeIntegratorSolution}}"><code>Trixi.PlotData2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlotData2D(sol; kwargs...)</code></pre><p>Create a <code>PlotData2D</code> object from a solution object created by either <code>OrdinaryDiffEq.solve!</code> (which returns a <code>SciMLBase.ODESolution</code>) or Trixi.jl&#39;s own <code>solve!</code> (which returns a <code>TimeIntegratorSolution</code>).</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L291-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ScalarPlotData2D-Tuple{Any, Trixi.AbstractSemidiscretization}" href="#Trixi.ScalarPlotData2D-Tuple{Any, Trixi.AbstractSemidiscretization}"><code>Trixi.ScalarPlotData2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ScalarPlotData2D(u, semi::AbstractSemidiscretization; kwargs...)</code></pre><p>Returns an <code>PlotData2DTriangulated</code> object which is used to visualize a single scalar field. <code>u</code> should be an array whose entries correspond to values of the scalar field at nodal points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L440-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.SummaryCallback" href="#Trixi.SummaryCallback"><code>Trixi.SummaryCallback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SummaryCallback()</code></pre><p>Create and return a callback that prints a human-readable summary of the simulation setup at the beginning of a simulation and then resets the timer. When the returned callback is executed directly, the current timer values are shown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/summary.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.TrivialCallback-Tuple{}" href="#Trixi.TrivialCallback-Tuple{}"><code>Trixi.TrivialCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TrivialCallback()</code></pre><p>A callback that does nothing. This can be useful to disable some callbacks easily via <a href="../reference-trixibase/#TrixiBase.trixi_include-Tuple{Module, AbstractString}"><code>trixi_include</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/trivial.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.adapt!-Tuple{T8codeMesh, Any}" href="#Trixi.adapt!-Tuple{T8codeMesh, Any}"><code>Trixi.adapt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Trixi.adapt!(mesh::T8codeMesh, adapt_callback; kwargs...)</code></pre><p>Adapt a <code>T8codeMesh</code> according to a user-defined <code>adapt_callback</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>mesh::T8codeMesh</code>: Initialized mesh object.</p></li><li><p><code>adapt_callback</code>: A user-defined callback which tells the adaption routines                   if an element should be refined, coarsened or stay unchanged.</p><p>The expected callback signature is as follows:</p><pre><code class="nohighlight hljs">`adapt_callback(forest, ltreeid, eclass_scheme, lelemntid, elements, is_family, user_data)`
  # Arguments
  - `forest`: Pointer to the analyzed forest.
  - `ltreeid`: Local index of the current tree where the analyzed elements are part of.
  - `eclass_scheme`: Element class of `elements`.
  - `lelemntid`: Local index of the first element in `elements`.
  - `elements`: Array of elements. If consecutive elements form a family
                they are passed together, otherwise `elements` consists of just one element.
  - `is_family`: Boolean signifying if `elements` represents a family or not.
  - `user_data`: Void pointer to some arbitrary user data. Default value is `C_NULL`.
  # Returns
    -1 : Coarsen family of elements.
     0 : Stay unchanged.
     1 : Refine element.</code></pre></li><li><p><code>kwargs</code>:</p><ul><li><code>recursive = true</code>: Adapt the forest recursively. If true the caller must ensure that the callback                     returns 0 for every analyzed element at some point to stop the recursion.</li><li><code>balance = true</code>: Make sure the adapted forest is 2^(NDIMS-1):1 balanced.</li><li><code>partition = true</code>: Partition the forest to redistribute elements evenly among MPI ranks.</li><li><code>ghost = true</code>: Create a ghost layer for MPI data exchange.</li><li><code>user_data = C_NULL</code>: Pointer to some arbitrary user-defined data.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L669-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}" href="#Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}"><code>Trixi.adapt_to_mesh_level!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt_to_mesh_level!(u_ode, semi, level)
adapt_to_mesh_level!(sol::Trixi.TrixiODESolution, level)</code></pre><p>Like <a href="#Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}"><code>adapt_to_mesh_level</code></a>, but modifies the solution and parts of the semidiscretization (mesh and caches) in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/utilities.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}" href="#Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}"><code>Trixi.adapt_to_mesh_level</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt_to_mesh_level(u_ode, semi, level)
adapt_to_mesh_level(sol::Trixi.TrixiODESolution, level)</code></pre><p>Use the regular adaptive mesh refinement routines to adaptively refine/coarsen the solution <code>u_ode</code> with semidiscretization <code>semi</code> towards a uniformly refined grid with refinement level <code>level</code>. The solution and semidiscretization are copied such that the original objects remain <em>unaltered</em>.</p><p>A convenience method accepts an ODE solution object, from which solution and semidiscretization are extracted as needed.</p><p>See also: <a href="#Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}"><code>adapt_to_mesh_level!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/utilities.jl#L285-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.balance!-Tuple{T8codeMesh}" href="#Trixi.balance!-Tuple{T8codeMesh}"><code>Trixi.balance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Trixi.balance!(mesh::T8codeMesh)</code></pre><p>Balance a <code>T8codeMesh</code> to ensure 2^(NDIMS-1):1 face neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L743-L747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.barycentric_weights-Tuple{Any}" href="#Trixi.barycentric_weights-Tuple{Any}"><code>Trixi.barycentric_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">barycentric_weights(nodes)</code></pre><p>Calculate the barycentric weights for a given node distribution, i.e.,</p><p class="math-container">\[w_j = \frac{1}{ \prod_{k \neq j} \left( x_j - x_k \right ) }\]</p><p>For details, see (especially Section 3)</p><ul><li>Jean-Paul Berrut and Lloyd N. Trefethen (2004). Barycentric Lagrange Interpolation. <a href="https://doi.org/10.1137/S0036144502417715">DOI:10.1137/S0036144502417715</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L469-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.boundary_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_x(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation1D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>initial_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.boundary_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_x(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation2D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>initial_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.boundary_condition_linear_x_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_x_y(u_inner, orientation, direction, x, t,
                              surface_flux_function,
                              equation::LinearScalarAdvectionEquation2D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>initial_condition_linear_x_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L114-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.boundary_condition_linear_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_y(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation2D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>initial_condition_linear_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L186-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.boundary_condition_linear_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_z(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation1D)</code></pre><p>Boundary conditions for <a href="#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}"><code>boundary_condition_linear_z</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_3d.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_noslip_wall-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.boundary_condition_noslip_wall-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.boundary_condition_noslip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_noslip_wall(u_inner, orientation, direction, x, t,
                               surface_flux_function,
                               equations::LatticeBoltzmannEquations2D)</code></pre><p>No-slip wall boundary condition using the bounce-back approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.boundary_condition_poisson_nonperiodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_poisson_nonperiodic(u_inner, orientation, direction, x, t,
                                       surface_flux_function,
                                       equations::HyperbolicDiffusionEquations1D)</code></pre><p>Boundary conditions used for convergence tests in combination with <a href="#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>initial_condition_poisson_nonperiodic</code></a> and <a href="#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_poisson_nonperiodic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_1d.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,
                             equations::AcousticPerturbationEquations2D)</code></pre><p>Use an orthogonal projection of the perturbed velocities to zero out the normal velocity while retaining the possibility of a tangential velocity in the boundary state. Further details are available in the paper:</p><ul><li>Marcus Bauer, Jürgen Dierke and Roland Ewert (2011) Application of a discontinuous Galerkin method to discretize acoustic perturbation equations <a href="https://doi.org/10.2514/1.J050333">DOI: 10.2514/1.J050333</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L222-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, normal_direction, direction, x, t,
                             surface_flux_function, equations::CompressibleEulerEquations2D)</code></pre><p>Should be used together with <a href="#Trixi.StructuredMesh"><code>StructuredMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, normal_direction, direction, x, t,
                             surface_flux_function, equations::CompressibleEulerEquations3D)</code></pre><p>Should be used together with <a href="#Trixi.StructuredMesh"><code>StructuredMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,
                             equations::CompressibleEulerEquations2D)</code></pre><p>Determine the boundary numerical surface flux for a slip wall condition. Imposes a zero normal velocity at the wall. Density is taken from the internal solution state and pressure is computed as an exact solution of a 1D Riemann problem. Further details about this boundary state are available in the paper:</p><ul><li>J. J. W. van der Vegt and H. van der Ven (2002) Slip flow boundary conditions in discontinuous Galerkin discretizations of the Euler equations of gas dynamics <a href="https://reports.nlr.nl/bitstream/handle/10921/692/TP-2002-300.pdf?sequence=1">PDF</a></li></ul><p>Details about the 1D pressure Riemann solution can be found in Section 6.3.3 of the book</p><ul><li>Eleuterio F. Toro (2009) Riemann Solvers and Numerical Methods for Fluid Dynamics: A Practical Introduction 3rd edition <a href="https://doi.org/10.1007/b79761">DOI: 10.1007/b79761</a></li></ul><p>Should be used together with <a href="#Trixi.UnstructuredMesh2D"><code>UnstructuredMesh2D</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L269-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,
                             equations::CompressibleEulerEquations3D)</code></pre><p>Determine the boundary numerical surface flux for a slip wall condition. Imposes a zero normal velocity at the wall. Density is taken from the internal solution state and pressure is computed as an exact solution of a 1D Riemann problem. Further details about this boundary state are available in the paper:</p><ul><li>J. J. W. van der Vegt and H. van der Ven (2002) Slip flow boundary conditions in discontinuous Galerkin discretizations of the Euler equations of gas dynamics <a href="https://reports.nlr.nl/bitstream/handle/10921/692/TP-2002-300.pdf?sequence=1">PDF</a></li></ul><p>Details about the 1D pressure Riemann solution can be found in Section 6.3.3 of the book</p><ul><li>Eleuterio F. Toro (2009) Riemann Solvers and Numerical Methods for Fluid Dynamics: A Practical Introduction 3rd edition <a href="https://doi.org/10.1007/b79761">DOI: 10.1007/b79761</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L264-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, ShallowWaterEquations2D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, ShallowWaterEquations2D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,
                             equations::ShallowWaterEquations2D)</code></pre><p>Create a boundary state by reflecting the normal velocity component and keep the tangential velocity component unchanged. The boundary water height is taken from the internal value. For details see Section 9.2.5 of the book:</p><ul><li>Eleuterio F. Toro (2001) Shock-Capturing Methods for Free-Surface Shallow Flows 1st edition ISBN 0471987662</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L164-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations1D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations1D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, orientation, direction, x, t,
                             surface_flux_function, equations::CompressibleEulerEquations1D)</code></pre><p>Determine the boundary numerical surface flux for a slip wall condition. Imposes a zero normal velocity at the wall. Density is taken from the internal solution state and pressure is computed as an exact solution of a 1D Riemann problem. Further details about this boundary state are available in the paper:</p><ul><li><p>J. J. W. van der Vegt and H. van der Ven (2002) Slip flow boundary conditions in discontinuous Galerkin discretizations of the Euler equations of gas dynamics <a href="https://reports.nlr.nl/bitstream/handle/10921/692/TP-2002-300.pdf?sequence=1">PDF</a></p><p>Should be used together with <a href="#Trixi.TreeMesh"><code>TreeMesh</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L201-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, orientation, direction, x, t,
                             surface_flux_function, equations::CompressibleEulerEquations2D)</code></pre><p>Should be used together with <a href="#Trixi.TreeMesh"><code>TreeMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L331-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, orientation, direction, x, t,
                             surface_flux_function, equations::CompressibleEulerEquations3D)</code></pre><p>Should be used together with <a href="#Trixi.TreeMesh"><code>TreeMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L334-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, ShallowWaterEquations1D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, ShallowWaterEquations1D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, orientation_or_normal, x, t, surface_flux_function,
                              equations::ShallowWaterEquations1D)</code></pre><p>Create a boundary state by reflecting the normal velocity component and keep the tangential velocity component unchanged. The boundary water height is taken from the internal value.</p><p>For details see Section 9.2.5 of the book:</p><ul><li>Eleuterio F. Toro (2001) Shock-Capturing Methods for Free-Surface Shallow Flows 1st edition ISBN 0471987662</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L146-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, ShallowWaterEquations2D}" href="#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, ShallowWaterEquations2D}"><code>Trixi.boundary_condition_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_slip_wall(u_inner, orientation, direction, x, t,
                             surface_flux_function, equations::ShallowWaterEquations2D)</code></pre><p>Should be used together with <a href="#Trixi.TreeMesh"><code>TreeMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.boundary_condition_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,
                        equations::AcousticPerturbationEquations2D)</code></pre><p>Boundary conditions for a solid wall.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L191-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, LinearizedEulerEquations1D}" href="#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, LinearizedEulerEquations1D}"><code>Trixi.boundary_condition_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,
                            equations::LinearizedEulerEquations1D)</code></pre><p>Boundary conditions for a solid wall.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_1d.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, LinearizedEulerEquations2D}" href="#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, LinearizedEulerEquations2D}"><code>Trixi.boundary_condition_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,
                            equations::LinearizedEulerEquations2D)</code></pre><p>Boundary conditions for a solid wall.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_2d.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, LinearizedEulerEquations3D}" href="#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, LinearizedEulerEquations3D}"><code>Trixi.boundary_condition_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,
                            equations::LinearizedEulerEquations3D)</code></pre><p>Boundary conditions for a solid wall.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_3d.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.calc_error_norms-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization, Any}" href="#Trixi.calc_error_norms-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization, Any}"><code>Trixi.calc_error_norms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_error_norms([func=(u_node,equations)-&gt;u_node,] u_ode, t, analyzer, semi::AbstractSemidiscretization, cache_analysis)</code></pre><p>Calculate discrete L2 and L∞ error norms of <code>func</code> applied to each nodal variable <code>u_node</code> in <code>u_ode</code>. If no exact solution is available, &quot;errors&quot; are calculated using some reference state and can be useful for regression tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.calc_fast_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fast_wavespeed_roe(u_ll, u_rr, direction, equations::IdealGlmMhdEquations1D)</code></pre><p>Compute the fast magnetoacoustic wave speed using Roe averages as given by</p><ul><li>Cargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws <a href="https://doi.org/10.1006/jcph.1997.5773">DOI: 10.1006/jcph.1997.5773</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L592-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.calc_fast_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fast_wavespeed_roe(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations2D)</code></pre><p>Compute the fast magnetoacoustic wave speed using Roe averages as given by</p><ul><li>Cargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws <a href="https://doi.org/10.1006/jcph.1997.5773">DOI: 10.1006/jcph.1997.5773</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L1197-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.calc_fast_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fast_wavespeed_roe(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations3D)</code></pre><p>Compute the fast magnetoacoustic wave speed using Roe averages as given by</p><ul><li>Cargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws <a href="https://doi.org/10.1006/jcph.1997.5773">DOI: 10.1006/jcph.1997.5773</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L1081-L1089">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.calc_wavespeed_roe-Tuple{Any, Any, Integer, ShallowWaterEquations1D}" href="#Trixi.calc_wavespeed_roe-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>Trixi.calc_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_wavespeed_roe(u_ll, u_rr, direction::Integer,
                   equations::ShallowWaterEquations1D)</code></pre><p>Calculate Roe-averaged velocity <code>v_roe</code> and wavespeed <code>c_roe = sqrt{g * h_roe}</code> See for instance equation (62) in </p><ul><li>Paul A. Ullrich, Christiane Jablonowski, and Bram van Leer (2010) High-order finite-volume methods for the shallow-water equations on the sphere <a href="https://doi.org/10.1016/j.jcp.2010.04.044">DOI: 10.1016/j.jcp.2010.04.044</a></li></ul><p>Or equation (9.17) in <a href="https://metaphor.ethz.ch/x/2019/hs/401-4671-00L/literature/mishra_hyperbolic_pdes.pdf">this lecture notes</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L623-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.calc_wavespeed_roe-Tuple{Any, Any, Integer, ShallowWaterEquations2D}" href="#Trixi.calc_wavespeed_roe-Tuple{Any, Any, Integer, ShallowWaterEquations2D}"><code>Trixi.calc_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_wavespeed_roe(u_ll, u_rr, direction::Integer,
                   equations::ShallowWaterEquations2D)</code></pre><p>Calculate Roe-averaged velocity <code>v_roe</code> and wavespeed <code>c_roe = sqrt{g * h_roe}</code> depending on direction. See for instance equation (62) in </p><ul><li>Paul A. Ullrich, Christiane Jablonowski, and Bram van Leer (2010) High-order finite-volume methods for the shallow-water equations on the sphere <a href="https://doi.org/10.1016/j.jcp.2010.04.044">DOI: 10.1016/j.jcp.2010.04.044</a></li></ul><p>Or <a href="https://faculty.washington.edu/rjl/classes/am574w2011/slides/am574lecture20nup3.pdf">this slides</a>,  slides 8 and 9.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L1001-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.collision_bgk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collision_bgk(u, dt, equations::LatticeBoltzmannEquations2D)</code></pre><p>Collision operator for the Bhatnagar, Gross, and Krook (BGK) model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations3D}" href="#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations3D}"><code>Trixi.collision_bgk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collision_bgk(u, dt, equations::LatticeBoltzmannEquations3D)</code></pre><p>Collision operator for the Bhatnagar, Gross, and Krook (BGK) model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.cons2cons-Tuple{Any, Trixi.AbstractEquations}" href="#Trixi.cons2cons-Tuple{Any, Trixi.AbstractEquations}"><code>Trixi.cons2cons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cons2cons(u, equations)</code></pre><p>Return the conserved variables <code>u</code>. While this function is as trivial as <code>identity</code>, it is also as useful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L278-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.cons2entropy" href="#Trixi.cons2entropy"><code>Trixi.cons2entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cons2entropy(u, equations)</code></pre><p>Convert the conserved variables <code>u</code> to the entropy variables for a given set of <code>equations</code> with chosen standard <a href="#Trixi.entropy"><code>entropy</code></a>.</p><p><code>u</code> is a vector type of the correct length <code>nvariables(equations)</code>. Notice the function doesn&#39;t include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by <a href="#Trixi.entropy2cons"><code>entropy2cons</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L321-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.cons2prim" href="#Trixi.cons2prim"><code>Trixi.cons2prim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cons2prim(u, equations)</code></pre><p>Convert the conserved variables <code>u</code> to the primitive variables for a given set of <code>equations</code>. <code>u</code> is a vector type of the correct length <code>nvariables(equations)</code>. Notice the function doesn&#39;t include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by <a href="#Trixi.prim2cons"><code>prim2cons</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L288-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.convergence_test-Tuple{Module, AbstractString, Any}" href="#Trixi.convergence_test-Tuple{Module, AbstractString, Any}"><code>Trixi.convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convergence_test([mod::Module=Main,] elixir::AbstractString, iterations; kwargs...)</code></pre><p>Run <code>iterations</code> Trixi.jl simulations using the setup given in <code>elixir</code> and compute the experimental order of convergence (EOC) in the <span>$L^2$</span> and <span>$L^\infty$</span> norm. In each iteration, the resolution of the respective mesh will be doubled. Additional keyword arguments <code>kwargs...</code> and the optional module <code>mod</code> are passed directly to <a href="../reference-trixibase/#TrixiBase.trixi_include-Tuple{Module, AbstractString}"><code>trixi_include</code></a>.</p><p>This function assumes that the spatial resolution is set via the keywords <code>initial_refinement_level</code> (an integer) or <code>cells_per_dimension</code> (a tuple of integers, one per spatial dimension).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/special_elixirs.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.default_analysis_errors-Tuple{Trixi.AbstractEquations}" href="#Trixi.default_analysis_errors-Tuple{Trixi.AbstractEquations}"><code>Trixi.default_analysis_errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_analysis_errors(equations)</code></pre><p>Default analysis errors (<code>:l2_error</code> and <code>:linf_error</code>) used by the <a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L263-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.default_analysis_integrals-Tuple{Trixi.AbstractEquations}" href="#Trixi.default_analysis_integrals-Tuple{Trixi.AbstractEquations}"><code>Trixi.default_analysis_integrals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_analysis_integrals(equations)</code></pre><p>Default analysis integrals used by the <a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.default_example-Tuple{}" href="#Trixi.default_example-Tuple{}"><code>Trixi.default_example</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_example()</code></pre><p>Return the path to an example elixir that can be used to quickly see Trixi.jl in action on a <a href="#Trixi.TreeMesh"><code>TreeMesh</code></a>. See also <a href="#Trixi.examples_dir-Tuple{}"><code>examples_dir</code></a> and <a href="#Trixi.get_examples-Tuple{}"><code>get_examples</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.default_example_unstructured-Tuple{}" href="#Trixi.default_example_unstructured-Tuple{}"><code>Trixi.default_example_unstructured</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_example_unstructured()</code></pre><p>Return the path to an example elixir that can be used to quickly see Trixi.jl in action on an <a href="#Trixi.UnstructuredMesh2D"><code>UnstructuredMesh2D</code></a>. This simulation is run on the example curved, unstructured mesh given in the Trixi.jl documentation regarding unstructured meshes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.density-Tuple{Real, LatticeBoltzmannEquations2D}" href="#Trixi.density-Tuple{Real, LatticeBoltzmannEquations2D}"><code>Trixi.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(p::Real, equations::LatticeBoltzmannEquations2D)
density(u, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic density from the pressure <code>p</code> or the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L259-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.density-Tuple{Real, LatticeBoltzmannEquations3D}" href="#Trixi.density-Tuple{Real, LatticeBoltzmannEquations3D}"><code>Trixi.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(p::Real, equations::LatticeBoltzmannEquations3D)
density(u, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic density from the pressure <code>p</code> or the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.download-Tuple{Any, Any}" href="#Trixi.download-Tuple{Any, Any}"><code>Trixi.download</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Trixi.download(src_url, file_path)</code></pre><p>Download a file from given <code>src_url</code> to given <code>file_path</code> if <code>file_path</code> is not already a file. This function just returns <code>file_path</code>. This is a small wrapper of <code>Downloads.download(src_url, file_path)</code> that avoids race conditions when multiple MPI ranks are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L351-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.dynamic_viscosity-Tuple{Any, Any}" href="#Trixi.dynamic_viscosity-Tuple{Any, Any}"><code>Trixi.dynamic_viscosity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dynamic_viscosity(u, equations)</code></pre><p>Wrapper for the dynamic viscosity that calls <code>dynamic_viscosity(u, equations.mu, equations)</code>, which dispatches on the type of  <code>equations.mu</code>.  For constant <code>equations.mu</code>, i.e., <code>equations.mu</code> is of <code>Real</code>-type it is returned directly. In all other cases, <code>equations.mu</code> is assumed to be a function with arguments <code>u</code> and <code>equations</code> and is called with these arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_navier_stokes.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.each_dof_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}" href="#Trixi.each_dof_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}"><code>Trixi.each_dof_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_dof_global(mesh::DGMultiMesh, dg::DGMulti, other_args...)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the degrees of freedom (DOF) in <code>dg</code>. In particular, not the DOFs themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/dg.jl#L95-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.each_face_node-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}" href="#Trixi.each_face_node-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}"><code>Trixi.each_face_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_face_node(mesh::DGMultiMesh, dg::DGMulti, other_args...)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the face nodes in <code>dg</code>. In particular, not the face_nodes themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/dg.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.each_face_node_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}" href="#Trixi.each_face_node_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}"><code>Trixi.each_face_node_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_face_node_global(mesh::DGMultiMesh, dg::DGMulti, other_args...)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the face nodes in <code>mesh</code>. In particular, not the face nodes themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/dg.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.each_quad_node-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}" href="#Trixi.each_quad_node-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}"><code>Trixi.each_quad_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_quad_node(mesh::DGMultiMesh, dg::DGMulti, other_args...)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the quadrature nodes in <code>dg</code>. In particular, not the quadrature nodes themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/dg.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.each_quad_node_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}" href="#Trixi.each_quad_node_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}"><code>Trixi.each_quad_node_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">each_quad_node_global(mesh::DGMultiMesh, dg::DGMulti, other_args...)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the global quadrature nodes in <code>mesh</code>. In particular, not the quadrature nodes themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/dg.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachboundary-Tuple{DG, Any}" href="#Trixi.eachboundary-Tuple{DG, Any}"><code>Trixi.eachboundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachboundary(dg::DG, cache)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the boundaries in <code>cache</code>. In particular, not the boundaries themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L483-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachcomponent-Tuple{Trixi.AbstractCompressibleEulerMulticomponentEquations}" href="#Trixi.eachcomponent-Tuple{Trixi.AbstractCompressibleEulerMulticomponentEquations}"><code>Trixi.eachcomponent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachcomponent(equations::AbstractCompressibleEulerMulticomponentEquations)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the components in <code>AbstractCompressibleEulerMulticomponentEquations</code>. In particular, not the components themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L439-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachcomponent-Tuple{Trixi.AbstractIdealGlmMhdMulticomponentEquations}" href="#Trixi.eachcomponent-Tuple{Trixi.AbstractIdealGlmMhdMulticomponentEquations}"><code>Trixi.eachcomponent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachcomponent(equations::AbstractIdealGlmMhdMulticomponentEquations)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the components in <code>AbstractIdealGlmMhdMulticomponentEquations</code>. In particular, not the components themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L472-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachdim-Tuple{Any}" href="#Trixi.eachdim-Tuple{Any}"><code>Trixi.eachdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachdim(mesh)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the dimensions in <code>AbstractTree</code>. In particular, not the dimensions themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/dg.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachdirection-Tuple{Trixi.AbstractTree}" href="#Trixi.eachdirection-Tuple{Trixi.AbstractTree}"><code>Trixi.eachdirection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachdirection(tree::AbstractTree)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the directions in <code>AbstractTree</code>.  In particular, not the directions themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/abstract_tree.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachelement-Tuple{DG, Any}" href="#Trixi.eachelement-Tuple{DG, Any}"><code>Trixi.eachelement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachelement(dg::DG, cache)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the elements in <code>cache</code>. In particular, not the elements themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L465-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachelement-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}" href="#Trixi.eachelement-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}"><code>Trixi.eachelement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachelement(mesh::DGMultiMesh, dg::DGMulti, other_args...)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the elements in <code>mesh</code>. In particular, not the elements themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgmulti/dg.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachelement-Tuple{Trixi.ElementContainer1D}" href="#Trixi.eachelement-Tuple{Trixi.ElementContainer1D}"><code>Trixi.eachelement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachelement(elements::ElementContainer1D)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the elements in <code>elements</code>.  In particular, not the elements themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/containers_1d.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachelement-Tuple{Trixi.ElementContainer2D}" href="#Trixi.eachelement-Tuple{Trixi.ElementContainer2D}"><code>Trixi.eachelement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachelement(elements::ElementContainer2D)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the elements in <code>elements</code>. In particular, not the elements themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/containers_2d.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachelement-Tuple{Trixi.ElementContainer3D}" href="#Trixi.eachelement-Tuple{Trixi.ElementContainer3D}"><code>Trixi.eachelement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachelement(elements::ElementContainer3D)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the elements in <code>elements</code>.  In particular, not the elements themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/containers_3d.jl#L78-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachelement-Tuple{Trixi.UnstructuredElementContainer2D}" href="#Trixi.eachelement-Tuple{Trixi.UnstructuredElementContainer2D}"><code>Trixi.eachelement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachelement(elements::UnstructuredElementContainer2D)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the elements in <code>elements</code>. In particular, not the elements themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_unstructured/containers_2d.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachinterface-Tuple{DG, Any}" href="#Trixi.eachinterface-Tuple{DG, Any}"><code>Trixi.eachinterface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachinterface(dg::DG, cache)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the interfaces in <code>cache</code>. In particular, not the interfaces themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L474-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachmortar-Tuple{DG, Any}" href="#Trixi.eachmortar-Tuple{DG, Any}"><code>Trixi.eachmortar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachmortar(dg::DG, cache)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the mortars in <code>cache</code>. In particular, not the mortars themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L492-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachmpiinterface-Tuple{DG, Any}" href="#Trixi.eachmpiinterface-Tuple{DG, Any}"><code>Trixi.eachmpiinterface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachmpiinterface(dg::DG, cache)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the MPI interfaces in <code>cache</code>. In particular, not the interfaces themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L501-L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachmpimortar-Tuple{DG, Any}" href="#Trixi.eachmpimortar-Tuple{DG, Any}"><code>Trixi.eachmpimortar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachmpimortar(dg::DG, cache)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the MPI mortars in <code>cache</code>. In particular, not the mortars themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L510-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachnode-Tuple{DG}" href="#Trixi.eachnode-Tuple{DG}"><code>Trixi.eachnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachnode(dg::DG)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the nodes in <code>dg</code>. In particular, not the nodes themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dg.jl#L448-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachnode-Tuple{LobattoLegendreBasis}" href="#Trixi.eachnode-Tuple{LobattoLegendreBasis}"><code>Trixi.eachnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachnode(basis::LobattoLegendreBasis)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the nodes in <code>basis</code>.  In particular, not the nodes themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachnode-Tuple{Trixi.LobattoLegendreAnalyzer}" href="#Trixi.eachnode-Tuple{Trixi.LobattoLegendreAnalyzer}"><code>Trixi.eachnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachnode(analyzer::LobattoLegendreAnalyzer)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the nodes in <code>analyzer</code>.  In particular, not the nodes themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.eachvariable-Tuple{Trixi.AbstractEquations}" href="#Trixi.eachvariable-Tuple{Trixi.AbstractEquations}"><code>Trixi.eachvariable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachvariable(equations::AbstractEquations)</code></pre><p>Return an iterator over the indices that specify the location in relevant data structures for the variables in <code>equations</code>. In particular, not the variables themselves are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.energy_internal" href="#Trixi.energy_internal"><code>Trixi.energy_internal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">energy_internal(u, equations)</code></pre><p>Return the internal energy of the conserved variables <code>u</code> for a given set of <code>equations</code>, e.g., the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a>.</p><p><code>u</code> is a vector of the conserved variables at a single node, i.e., a vector of the correct length <code>nvariables(equations)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L368-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.energy_kinetic" href="#Trixi.energy_kinetic"><code>Trixi.energy_kinetic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">energy_kinetic(u, equations)</code></pre><p>Return the kinetic energy of the conserved variables <code>u</code> for a given set of <code>equations</code>, e.g., the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a>.</p><p><code>u</code> is a vector of the conserved variables at a single node, i.e., a vector of the correct length <code>nvariables(equations)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L357-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.energy_total" href="#Trixi.energy_total"><code>Trixi.energy_total</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">energy_total(u, equations)</code></pre><p>Return the total energy of the conserved variables <code>u</code> for a given set of <code>equations</code>, e.g., the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a>.</p><p><code>u</code> is a vector of the conserved variables at a single node, i.e., a vector of the correct length <code>nvariables(equations)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L346-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.entropy" href="#Trixi.entropy"><code>Trixi.entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entropy(u, equations)</code></pre><p>Return the chosen entropy of the conserved variables <code>u</code> for a given set of <code>equations</code>.</p><p><code>u</code> is a vector of the conserved variables at a single node, i.e., a vector of the correct length <code>nvariables(equations)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L310-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.entropy2cons" href="#Trixi.entropy2cons"><code>Trixi.entropy2cons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entropy2cons(w, equations)</code></pre><p>Convert the entropy variables <code>w</code> based on a standard <a href="#Trixi.entropy"><code>entropy</code></a> to the conserved variables for a given set of <code>equations</code>. <code>u</code> is a vector type of the correct length <code>nvariables(equations)</code>. Notice the function doesn&#39;t include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by <a href="#Trixi.cons2entropy"><code>cons2entropy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L334-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, Any, LatticeBoltzmannEquations3D}" href="#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, Any, LatticeBoltzmannEquations3D}"><code>Trixi.equilibrium_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equilibrium_distribution(alpha, rho, v1, v2, v3, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the local equilibrium distribution for the distribution function with index <code>alpha</code> and given the macroscopic state defined by <code>rho</code>, <code>v1</code>, <code>v2</code>, <code>v3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.equilibrium_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equilibrium_distribution(alpha, rho, v1, v2, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the local equilibrium distribution for the distribution function with index <code>alpha</code> and given the macroscopic state defined by <code>rho</code>, <code>v1</code>, <code>v2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L312-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.examples_dir-Tuple{}" href="#Trixi.examples_dir-Tuple{}"><code>Trixi.examples_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">examples_dir()</code></pre><p>Return the directory where the example files provided with Trixi.jl are located. If Trixi.jl is installed as a regular package (with <code>]add Trixi</code>), these files are read-only and should <em>not</em> be modified. To find out which files are available, use, e.g., <code>readdir</code>:</p><p><strong>Examples</strong></p><pre><code class="language- hljs">readdir(examples_dir())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L98-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux" href="#Trixi.flux"><code>Trixi.flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux(u, orientation_or_normal, equations)</code></pre><p>Given the conservative variables <code>u</code>, calculate the (physical) flux in Cartesian direction <code>orientation::Integer</code> or in arbitrary direction <code>normal::AbstractVector</code> for the corresponding set of governing <code>equations</code>. <code>orientation</code> is <code>1</code>, <code>2</code>, and <code>3</code> for the x-, y-, and z-directions, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux-Tuple{Any, AbstractVector, Trixi.AbstractEquations{1}}" href="#Trixi.flux-Tuple{Any, AbstractVector, Trixi.AbstractEquations{1}}"><code>Trixi.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux(u, normal_direction::AbstractVector, equations::AbstractEquations{1})</code></pre><p>Enables calling <code>flux</code> with a non-integer argument <code>normal_direction</code> for one-dimensional equations. Returns the value of <code>flux(u, 1, equations)</code> scaled by <code>normal_direction[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_central-Tuple{Any, Any, Any, Trixi.AbstractEquations}" href="#Trixi.flux_central-Tuple{Any, Any, Any, Trixi.AbstractEquations}"><code>Trixi.flux_central</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_central(u_ll, u_rr, orientation_or_normal_direction, equations::AbstractEquations)</code></pre><p>The classical central numerical flux <code>f((u_ll) + f(u_rr)) / 2</code>. When this flux is used as volume flux, the discretization is equivalent to the classical weak form DG method (except floating point errors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_chan_etal-Tuple{Any, Any, Integer, CompressibleEulerEquationsQuasi1D}" href="#Trixi.flux_chan_etal-Tuple{Any, Any, Integer, CompressibleEulerEquationsQuasi1D}"><code>Trixi.flux_chan_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>@inline function flux<em>chan</em>etal(u<em>ll, u</em>rr, orientation::Integer,                                            equations::CompressibleEulerEquationsQuasi1D)</p><p>Conservative (symmetric) part of the entropy conservative flux for quasi 1D compressible Euler equations split form. This flux is a generalization of <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> for <a href="#Trixi.CompressibleEulerEquations1D"><code>CompressibleEulerEquations1D</code></a>. Further details are available in the paper:</p><ul><li>Jesse Chan, Khemraj Shukla, Xinhui Wu, Ruofeng Liu, Prani Nalluri (2023)  High order entropy stable schemes for the quasi-one-dimensional shallow water and compressible Euler equations <a href="https://doi.org/10.48550/arXiv.2307.12089">DOI: 10.48550/arXiv.2307.12089</a>     </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_quasi_1d.jl#L217-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_chan_etal-Tuple{Any, Any, Integer, ShallowWaterEquationsQuasi1D}" href="#Trixi.flux_chan_etal-Tuple{Any, Any, Integer, ShallowWaterEquationsQuasi1D}"><code>Trixi.flux_chan_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chan_etal(u_ll, u_rr, orientation,
               equations::ShallowWaterEquationsQuasi1D)</code></pre><p>Total energy conservative (mathematical entropy for quasi 1D shallow water equations) split form. When the bottom topography is nonzero this scheme will be well-balanced when used as a <code>volume_flux</code>. The <code>surface_flux</code> should still use, e.g., <a href="#Trixi.FluxPlusDissipation"><code>FluxPlusDissipation(flux_chan_etal, DissipationLocalLaxFriedrichs())</code></a>.</p><p>Further details are available in the paper:</p><ul><li>Jesse Chan, Khemraj Shukla, Xinhui Wu, Ruofeng Liu, Prani Nalluri (2023)  High order entropy stable schemes for the quasi-one-dimensional shallow water and compressible Euler equations <a href="https://doi.org/10.48550/arXiv.2307.12089">DOI: 10.48550/arXiv.2307.12089</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_quasi_1d.jl#L181-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Chandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations <a href="https://doi.org/10.4208/cicp.170712.010313a">DOI: 10.4208/cicp.170712.010313a</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L332-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation_or_normal_direction, equations::CompressibleEulerEquations2D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Chandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations <a href="https://doi.org/10.4208/cicp.170712.010313a">DOI: 10.4208/cicp.170712.010313a</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L554-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation_or_normal_direction, equations::CompressibleEulerEquations3D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Chandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations <a href="https://doi.org/10.4208/cicp.170712.010313a">DOI: 10.4208/cicp.170712.010313a</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L604-L612">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Ayoub Gouasmi, Karthik Duraisamy (2020) &quot;Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations&quot; <a href="https://arxiv.org/abs/1904.00972">arXiv:1904.00972v3</a> [math.NA] 4 Feb 2020</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_1d.jl#L241-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Adaption of the entropy conserving two-point flux by</p><ul><li>Ayoub Gouasmi, Karthik Duraisamy (2020) &quot;Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations&quot; <a href="https://arxiv.org/abs/1904.00972">arXiv:1904.00972v3</a> [math.NA] 4 Feb 2020</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_2d.jl#L292-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L127-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L472-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations3D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L324-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)</code></pre><p>Entropy conserving two-point flux adapted by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L176-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>Entropy conserving two-point flux adapted by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L255-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}" href="#Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>Trixi.flux_fjordholm_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_fjordholm_etal(u_ll, u_rr, orientation,
                    equations::ShallowWaterEquations1D)</code></pre><p>Total energy conservative (mathematical entropy for shallow water equations). When the bottom topography is nonzero this should only be used as a surface flux otherwise the scheme will not be well-balanced. For well-balancedness in the volume flux use <a href="#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_wintermeyer_etal</code></a>.</p><p>Details are available in Eq. (4.1) in the paper:</p><ul><li>Ulrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography <a href="https://doi.org/10.1016/j.jcp.2011.03.042">DOI: 10.1016/j.jcp.2011.03.042</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L348-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}" href="#Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}"><code>Trixi.flux_fjordholm_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_fjordholm_etal(u_ll, u_rr, orientation_or_normal_direction,
                    equations::ShallowWaterEquations2D)</code></pre><p>Total energy conservative (mathematical entropy for shallow water equations). When the bottom topography is nonzero this should only be used as a surface flux otherwise the scheme will not be well-balanced. For well-balancedness in the volume flux use <a href="#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_wintermeyer_etal</code></a>.</p><p>Details are available in Eq. (4.1) in the paper:</p><ul><li>Ulrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography <a href="https://doi.org/10.1016/j.jcp.2011.03.042">DOI: 10.1016/j.jcp.2011.03.042</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L592-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_godunov-Tuple{Any, Any, Integer, LinearizedEulerEquations2D}" href="#Trixi.flux_godunov-Tuple{Any, Any, Integer, LinearizedEulerEquations2D}"><code>Trixi.flux_godunov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_godunov(u_ll, u_rr, orientation_or_normal_direction,
             equations::LinearizedEulerEquations2D)</code></pre><p>An upwind flux for the linearized Euler equations based on diagonalization of the physical flux matrix. Given the physical flux <span>$Au$</span>, <span>$A=T \Lambda T^{-1}$</span> with <span>$\Lambda$</span> being a diagonal matrix that holds the eigenvalues of <span>$A$</span>, decompose <span>$\Lambda = \Lambda^+ + \Lambda^-$</span> where <span>$\Lambda^+$</span> and <span>$\Lambda^-$</span> are diagonal matrices holding the positive and negative eigenvalues of <span>$A$</span>, respectively. Then for left and right states <span>$u_L, u_R$</span>, the numerical flux calculated by this function is given by <span>$A^+ u_L + A^- u_R$</span> where <span>$A^{\pm} = T \Lambda^{\pm} T^{-1}$</span>.</p><p>The diagonalization of the flux matrix can be found in</p><ul><li>R. F. Warming, Richard M. Beam and B. J. Hyett (1975) Diagonalization and simultaneous symmetrization of the gas-dynamic matrices <a href="https://doi.org/10.1090/S0025-5718-1975-0388967-5">DOI: 10.1090/S0025-5718-1975-0388967-5</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_2d.jl#L172-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdEquations1D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L196-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdEquations2D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L564-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdEquations3D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L425-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdMulticomponentEquations1D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L276-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L392-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_hllc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Computes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro <a href="http://www.prague-sum.com/download/2012/Toro_2-HLLC-RiemannSolver.pdf">Lecture slides</a> Signal speeds: <a href="https://doi.org/10.1137/S1064827593260140">DOI: 10.1137/S1064827593260140</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L734-L740">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_hllc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hllc(u_ll, u_rr, orientation_or_normal_direction, equations::CompressibleEulerEquations2D)</code></pre><p>Computes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro <a href="http://www.prague-sum.com/download/2012/Toro_2-HLLC-RiemannSolver.pdf">Lecture slides</a> Signal speeds: <a href="https://doi.org/10.1137/S1064827593260140">DOI: 10.1137/S1064827593260140</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L1542-L1548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_hllc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hllc(u_ll, u_rr, orientation_or_normal_direction, equations::CompressibleEulerEquations3D)</code></pre><p>Computes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro <a href="http://www.prague-sum.com/download/2012/Toro_2-HLLC-RiemannSolver.pdf">Lecture slides</a> Signal speeds: <a href="https://doi.org/10.1137/S1064827593260140">DOI: 10.1137/S1064827593260140</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L1233-L1239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_hllc-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}" href="#Trixi.flux_hllc-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}"><code>Trixi.flux_hllc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hllc(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)</code></pre><ul><li>Li (2005)</li></ul><p>An HLLC Riemann solver for magneto-hydrodynamics <a href="https://doi.org/10.1016/j.jcp.2004.08.020">DOI: 10.1016/j.jcp.2004.08.020</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_kennedy_gruber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_kennedy_gruber(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Kinetic energy preserving two-point flux by</p><ul><li>Kennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid <a href="https://doi.org/10.1016/j.jcp.2007.09.020">DOI: 10.1016/j.jcp.2007.09.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L301-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_kennedy_gruber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,
                    equations::CompressibleEulerEquations2D)</code></pre><p>Kinetic energy preserving two-point flux by</p><ul><li>Kennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid <a href="https://doi.org/10.1016/j.jcp.2007.09.020">DOI: 10.1016/j.jcp.2007.09.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L488-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_kennedy_gruber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,
                    equations::CompressibleEulerEquations3D)</code></pre><p>Kinetic energy preserving two-point flux by</p><ul><li>Kennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid <a href="https://doi.org/10.1016/j.jcp.2007.09.020">DOI: 10.1016/j.jcp.2007.09.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L516-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_audusse_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}" href="#Trixi.flux_nonconservative_audusse_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>Trixi.flux_nonconservative_audusse_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_audusse_etal(u_ll, u_rr, orientation::Integer,
                                  equations::ShallowWaterEquations1D)</code></pre><p>Non-symmetric two-point surface flux that discretizes the nonconservative (source) term. The discretization uses the <code>hydrostatic_reconstruction_audusse_etal</code> on the conservative variables.</p><p>This hydrostatic reconstruction ensures that the finite volume numerical fluxes remain well-balanced for discontinuous bottom topographies <a href="#Trixi.ShallowWaterEquations1D"><code>ShallowWaterEquations1D</code></a>. Should be used together with <a href="#Trixi.FluxHydrostaticReconstruction"><code>FluxHydrostaticReconstruction</code></a> and <a href="#Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations1D}"><code>hydrostatic_reconstruction_audusse_etal</code></a> in the surface flux to ensure consistency.</p><p>Further details on the hydrostatic reconstruction and its motivation can be found in</p><ul><li>Emmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows <a href="https://doi.org/10.1137/S1064827503431090">DOI: 10.1137/S1064827503431090</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L269-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_audusse_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}" href="#Trixi.flux_nonconservative_audusse_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}"><code>Trixi.flux_nonconservative_audusse_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_audusse_etal(u_ll, u_rr, orientation::Integer,
                                  equations::ShallowWaterEquations2D)
flux_nonconservative_audusse_etal(u_ll, u_rr,
                                  normal_direction_ll     ::AbstractVector,
                                  normal_direction_average::AbstractVector,
                                  equations::ShallowWaterEquations2D)</code></pre><p>Non-symmetric two-point surface flux that discretizes the nonconservative (source) term. The discretization uses the <code>hydrostatic_reconstruction_audusse_etal</code> on the conservative variables.</p><p>This hydrostatic reconstruction ensures that the finite volume numerical fluxes remain well-balanced for discontinuous bottom topographies <a href="#Trixi.ShallowWaterEquations2D"><code>ShallowWaterEquations2D</code></a>. Should be used together with <a href="#Trixi.FluxHydrostaticReconstruction"><code>FluxHydrostaticReconstruction</code></a> and <a href="#Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations1D}"><code>hydrostatic_reconstruction_audusse_etal</code></a> in the surface flux to ensure consistency.</p><p>Further details for the hydrostatic reconstruction and its motivation can be found in</p><ul><li>Emmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows <a href="https://doi.org/10.1137/S1064827503431090">DOI: 10.1137/S1064827503431090</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L439-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_chan_etal-Tuple{Any, Any, Integer, CompressibleEulerEquationsQuasi1D}" href="#Trixi.flux_nonconservative_chan_etal-Tuple{Any, Any, Integer, CompressibleEulerEquationsQuasi1D}"><code>Trixi.flux_nonconservative_chan_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_chan_etal(u_ll, u_rr, orientation::Integer,
                               equations::CompressibleEulerEquationsQuasi1D)
flux_nonconservative_chan_etal(u_ll, u_rr, normal_direction, 
                               equations::CompressibleEulerEquationsQuasi1D)
flux_nonconservative_chan_etal(u_ll, u_rr, normal_ll, normal_rr,
                               equations::CompressibleEulerEquationsQuasi1D)</code></pre><p>Non-symmetric two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the pressure  <a href="#Trixi.CompressibleEulerEquationsQuasi1D"><code>CompressibleEulerEquationsQuasi1D</code></a>  and the nozzle width.</p><p>Further details are available in the paper:</p><ul><li>Jesse Chan, Khemraj Shukla, Xinhui Wu, Ruofeng Liu, Prani Nalluri (2023)   High order entropy stable schemes for the quasi-one-dimensional   shallow water and compressible Euler equations   <a href="https://doi.org/10.48550/arXiv.2307.12089">DOI: 10.48550/arXiv.2307.12089</a>    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_quasi_1d.jl#L163-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_chan_etal-Tuple{Any, Any, Integer, ShallowWaterEquationsQuasi1D}" href="#Trixi.flux_nonconservative_chan_etal-Tuple{Any, Any, Integer, ShallowWaterEquationsQuasi1D}"><code>Trixi.flux_nonconservative_chan_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_chan_etal(u_ll, u_rr, orientation::Integer,
                               equations::ShallowWaterEquationsQuasi1D)
flux_nonconservative_chan_etal(u_ll, u_rr, normal_direction::AbstractVector,
                               equations::ShallowWaterEquationsQuasi1D)    
flux_nonconservative_chan_etal(u_ll, u_rr, 
                               normal_ll::AbstractVector, normal_rr::AbstractVector,
                               equations::ShallowWaterEquationsQuasi1D)</code></pre><p>Non-symmetric two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the bottom topography <a href="#Trixi.ShallowWaterEquationsQuasi1D"><code>ShallowWaterEquationsQuasi1D</code></a>  and the channel width.</p><p>Further details are available in the paper:</p><ul><li>Jesse Chan, Khemraj Shukla, Xinhui Wu, Ruofeng Liu, Prani Nalluri (2023)   High order entropy stable schemes for the quasi-one-dimensional   shallow water and compressible Euler equations   <a href="https://doi.org/10.48550/arXiv.2307.12089">DOI: 10.48550/arXiv.2307.12089</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_quasi_1d.jl#L129-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_ersing_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}" href="#Trixi.flux_nonconservative_ersing_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>Trixi.flux_nonconservative_ersing_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_ersing_etal(u_ll, u_rr, orientation::Integer,
                                 equations::ShallowWaterEquations1D)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This numerical flux is experimental and may change in any future release.</p></div></div><p>Non-symmetric path-conservative two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the bottom topography <a href="#Trixi.ShallowWaterEquations1D"><code>ShallowWaterEquations1D</code></a>.</p><p>This is a modified version of <a href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_nonconservative_wintermeyer_etal</code></a> that gives entropy  conservation and well-balancedness in both the volume and surface when combined with  <a href="#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_wintermeyer_etal</code></a>.</p><p>For further details see:</p><ul><li>Patrick Ersing, Andrew R. Winters (2023) An entropy stable discontinuous Galerkin method for the two-layer shallow water equations on  curvilinear meshes <a href="https://doi.org/10.48550/arXiv.2306.12699">DOI: 10.48550/arXiv.2306.12699</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L310-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_ersing_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}" href="#Trixi.flux_nonconservative_ersing_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}"><code>Trixi.flux_nonconservative_ersing_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_ersing_etal(u_ll, u_rr, orientation::Integer,
                                 equations::ShallowWaterEquations2D)
flux_nonconservative_ersing_etal(u_ll, u_rr,
                                 normal_direction_ll::AbstractVector,
                                 normal_direction_average::AbstractVector,
                                 equations::ShallowWaterEquations2D)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This numerical flux is experimental and may change in any future release.</p></div></div><p>Non-symmetric path-conservative two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the bottom topography <a href="#Trixi.ShallowWaterEquations2D"><code>ShallowWaterEquations2D</code></a>.</p><p>On curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.</p><p>This is a modified version of <a href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_nonconservative_wintermeyer_etal</code></a> that gives entropy  conservation and well-balancedness in both the volume and surface when combined with  <a href="#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_wintermeyer_etal</code></a>.</p><p>For further details see:</p><ul><li>Patrick Ersing, Andrew R. Winters (2023) An entropy stable discontinuous Galerkin method for the two-layer shallow water equations on  curvilinear meshes <a href="https://doi.org/10.48550/arXiv.2306.12699">DOI: 10.48550/arXiv.2306.12699</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L524-L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}" href="#Trixi.flux_nonconservative_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>Trixi.flux_nonconservative_fjordholm_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_fjordholm_etal(u_ll, u_rr, orientation::Integer,
                                    equations::ShallowWaterEquations1D)</code></pre><p>Non-symmetric two-point surface flux discretizing the nonconservative (source) term of that contains the gradient of the bottom topography <a href="#Trixi.ShallowWaterEquations1D"><code>ShallowWaterEquations1D</code></a>.</p><p>This contains additional terms compared to <a href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_nonconservative_wintermeyer_etal</code></a> that account for possible discontinuities in the bottom topography function. Thus, this flux should be used in general at interfaces. For flux differencing volume terms, <a href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_nonconservative_wintermeyer_etal</code></a> is analytically equivalent but slightly cheaper.</p><p>Further details for the original finite volume formulation are available in</p><ul><li>Ulrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography <a href="https://doi.org/10.1016/j.jcp.2011.03.042">DOI: 10.1016/j.jcp.2011.03.042</a></li></ul><p>and for curvilinear 2D case in the paper:</p><ul><li>Niklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry <a href="https://doi.org/10.1016/j.jcp.2017.03.036">DOI: 10.1016/j.jcp.2017.03.036</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L223-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}" href="#Trixi.flux_nonconservative_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}"><code>Trixi.flux_nonconservative_fjordholm_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_fjordholm_etal(u_ll, u_rr, orientation::Integer,
                                    equations::ShallowWaterEquations2D)
flux_nonconservative_fjordholm_etal(u_ll, u_rr,
                                    normal_direction_ll     ::AbstractVector,
                                    normal_direction_average::AbstractVector,
                                    equations::ShallowWaterEquations2D)</code></pre><p>Non-symmetric two-point surface flux discretizing the nonconservative (source) term of that contains the gradient of the bottom topography <a href="#Trixi.ShallowWaterEquations2D"><code>ShallowWaterEquations2D</code></a>.</p><p>On curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.</p><p>This contains additional terms compared to <a href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_nonconservative_wintermeyer_etal</code></a> that account for possible discontinuities in the bottom topography function. Thus, this flux should be used in general at interfaces. For flux differencing volume terms, <a href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_nonconservative_wintermeyer_etal</code></a> is analytically equivalent but slightly cheaper.</p><p>Further details for the original finite volume formulation are available in</p><ul><li>Ulrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography <a href="https://doi.org/10.1016/j.jcp.2011.03.042">DOI: 10.1016/j.jcp.2011.03.042</a></li></ul><p>and for curvilinear 2D case in the paper:</p><ul><li>Niklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry <a href="https://doi.org/10.1016/j.jcp.2017.03.036">DOI: 10.1016/j.jcp.2017.03.036</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L314-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.flux_nonconservative_powell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,
                            equations::IdealGlmMhdEquations2D)
flux_nonconservative_powell(u_ll, u_rr,
                            normal_direction_ll     ::AbstractVector,
                            normal_direction_average::AbstractVector,
                            equations::IdealGlmMhdEquations2D)</code></pre><p>Non-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the <a href="#Trixi.IdealGlmMhdEquations2D"><code>IdealGlmMhdEquations2D</code></a>.</p><p>On curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.</p><p><strong>References</strong></p><ul><li>Marvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification <a href="https://doi.org/10.1016/j.jcp.2018.06.027">DOI: 10.1016/j.jcp.2018.06.027</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L187-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.flux_nonconservative_powell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,
                            equations::IdealGlmMhdEquations3D)
flux_nonconservative_powell(u_ll, u_rr,
                            normal_direction_ll     ::AbstractVector,
                            normal_direction_average::AbstractVector,
                            equations::IdealGlmMhdEquations3D)</code></pre><p>Non-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the <a href="#Trixi.IdealGlmMhdEquations3D"><code>IdealGlmMhdEquations3D</code></a>.</p><p>On curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.</p><p><strong>References</strong></p><ul><li>Marvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification <a href="https://doi.org/10.1016/j.jcp.2018.06.027">DOI: 10.1016/j.jcp.2018.06.027</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L215-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.flux_nonconservative_powell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,
                            equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>Non-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the <a href="#Trixi.IdealGlmMhdMulticomponentEquations2D"><code>IdealGlmMhdMulticomponentEquations2D</code></a>.</p><p><strong>References</strong></p><ul><li>Marvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification <a href="https://doi.org/10.1016/j.jcp.2018.06.027">DOI: 10.1016/j.jcp.2018.06.027</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L197-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_powell_local_symmetric-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D, Trixi.NonConservativeSymmetric, Integer}" href="#Trixi.flux_nonconservative_powell_local_symmetric-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D, Trixi.NonConservativeSymmetric, Integer}"><code>Trixi.flux_nonconservative_powell_local_symmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell_local_symmetric(u_ll, orientation::Integer,
                                            equations::IdealGlmMhdEquations2D,
                                            nonconservative_type::NonConservativeSymmetric,
                                            nonconservative_term::Integer)</code></pre><p>Symmetric part of the Powell and GLM non-conservative terms. Needed for the calculation of the non-conservative staggered &quot;fluxes&quot; for subcell limiting. See, e.g.,</p><ul><li>Rueda-Ramírez, Gassner (2023). A Flux-Differencing Formula for Split-Form Summation By Parts Discretizations of Non-Conservative Systems. https://arxiv.org/pdf/2211.14009.pdf.</li></ul><p>This function is used to compute the subcell fluxes in dg<em>2d</em>subcell_limiters.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L410-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_powell_local_symmetric-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.flux_nonconservative_powell_local_symmetric-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.flux_nonconservative_powell_local_symmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell_local_symmetric(u_ll, u_rr,
                                            orientation::Integer,
                                            equations::IdealGlmMhdEquations2D)</code></pre><p>Non-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the <a href="#Trixi.IdealGlmMhdEquations2D"><code>IdealGlmMhdEquations2D</code></a>.</p><p>This implementation uses a non-conservative term that can be written as the product of local and symmetric parts. It is equivalent to the non-conservative flux of Bohm et al. (<code>flux_nonconservative_powell</code>) for conforming meshes but it yields different results on non-conforming meshes(!).</p><p>The two other flux functions with the same name return either the local or symmetric portion of the non-conservative flux based on the type of the nonconservative<em>type argument, employing multiple dispatch. They are used to compute the subcell fluxes in dg</em>2d<em>subcell</em>limiters.jl.</p><p><strong>References</strong></p><ul><li>Rueda-Ramírez, Gassner (2023). A Flux-Differencing Formula for Split-Form Summation By Parts Discretizations of Non-Conservative Systems. https://arxiv.org/pdf/2211.14009.pdf.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L284-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_powell_local_symmetric-Tuple{Any, Integer, IdealGlmMhdEquations2D, Trixi.NonConservativeLocal, Integer}" href="#Trixi.flux_nonconservative_powell_local_symmetric-Tuple{Any, Integer, IdealGlmMhdEquations2D, Trixi.NonConservativeLocal, Integer}"><code>Trixi.flux_nonconservative_powell_local_symmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell_local_symmetric(u_ll, orientation::Integer,
                                            equations::IdealGlmMhdEquations2D,
                                            nonconservative_type::NonConservativeLocal,
                                            nonconservative_term::Integer)</code></pre><p>Local part of the Powell and GLM non-conservative terms. Needed for the calculation of the non-conservative staggered &quot;fluxes&quot; for subcell limiting. See, e.g.,</p><ul><li>Rueda-Ramírez, Gassner (2023). A Flux-Differencing Formula for Split-Form Summation By Parts Discretizations of Non-Conservative Systems. https://arxiv.org/pdf/2211.14009.pdf.</li></ul><p>This function is used to compute the subcell fluxes in dg<em>2d</em>subcell_limiters.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L348-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}" href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>Trixi.flux_nonconservative_wintermeyer_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_wintermeyer_etal(u_ll, u_rr, orientation::Integer,
                                      equations::ShallowWaterEquations1D)</code></pre><p>Non-symmetric two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the bottom topography <a href="#Trixi.ShallowWaterEquations1D"><code>ShallowWaterEquations1D</code></a>.</p><p>Further details are available in the paper:</p><ul><li>Niklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry <a href="https://doi.org/10.1016/j.jcp.2017.03.036">DOI: 10.1016/j.jcp.2017.03.036</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L196-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}" href="#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}"><code>Trixi.flux_nonconservative_wintermeyer_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_wintermeyer_etal(u_ll, u_rr, orientation::Integer,
                                      equations::ShallowWaterEquations2D)
flux_nonconservative_wintermeyer_etal(u_ll, u_rr,
                                      normal_direction_ll     ::AbstractVector,
                                      normal_direction_average::AbstractVector,
                                      equations::ShallowWaterEquations2D)</code></pre><p>Non-symmetric two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the bottom topography <a href="#Trixi.ShallowWaterEquations2D"><code>ShallowWaterEquations2D</code></a>.</p><p>On curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.</p><p>Further details are available in the paper:</p><ul><li>Niklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry <a href="https://doi.org/10.1016/j.jcp.2017.03.036">DOI: 10.1016/j.jcp.2017.03.036</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L261-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction, equations::CompressibleEulerEquations1D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L370-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerEquations2D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L633-L647">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerEquations3D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L700-L714">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_1d.jl#L309-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_2d.jl#L374-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_ranocha_turbo-NTuple{4, Any}" href="#Trixi.flux_ranocha_turbo-NTuple{4, Any}"><code>Trixi.flux_ranocha_turbo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha_turbo(u_ll, u_rr, orientation_or_normal_direction, equations)</code></pre><p>Equivalent to <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> except that it may use specialized methods, e.g., when used with <a href="#Trixi.VolumeIntegralFluxDifferencing"><code>VolumeIntegralFluxDifferencing</code></a>. These specialized methods may enable better use of SIMD instructions to increase runtime efficiency on modern hardware.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L352-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_shima_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_shima_etal(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>This flux is is a modification of the original kinetic energy preserving two-point flux by</p><ul><li>Yuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms <a href="https://doi.org/10.1016/j.jcp.2018.08.058">DOI: 10.1016/j.jcp.2018.08.058</a></li></ul><p>The modification is in the energy flux to guarantee pressure equilibrium and was developed by</p><ul><li>Nao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows <a href="https://doi.org/10.1016/j.jcp.2020.110060">DOI: 10.1016/j.jcp.2020.110060</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L264-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_shima_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,
                equations::CompressibleEulerEquations2D)</code></pre><p>This flux is is a modification of the original kinetic energy preserving two-point flux by</p><ul><li>Yuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms <a href="https://doi.org/10.1016/j.jcp.2018.08.058">DOI: 10.1016/j.jcp.2018.08.058</a></li></ul><p>The modification is in the energy flux to guarantee pressure equilibrium and was developed by</p><ul><li>Nao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows <a href="https://doi.org/10.1016/j.jcp.2020.110060">DOI: 10.1016/j.jcp.2020.110060</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L414-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_shima_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,
                equations::CompressibleEulerEquations3D)</code></pre><p>This flux is is a modification of the original kinetic energy preserving two-point flux by</p><ul><li>Yuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms <a href="https://doi.org/10.1016/j.jcp.2018.08.058">DOI: 10.1016/j.jcp.2018.08.058</a></li></ul><p>The modification is in the energy flux to guarantee pressure equilibrium and was developed by</p><ul><li>Nao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows <a href="https://doi.org/10.1016/j.jcp.2020.110060">DOI: 10.1016/j.jcp.2020.110060</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L428-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_shima_etal_turbo-NTuple{4, Any}" href="#Trixi.flux_shima_etal_turbo-NTuple{4, Any}"><code>Trixi.flux_shima_etal_turbo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_shima_etal_turbo(u_ll, u_rr, orientation_or_normal_direction, equations)</code></pre><p>Equivalent to <a href="#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_shima_etal</code></a> except that it may use specialized methods, e.g., when used with <a href="#Trixi.VolumeIntegralFluxDifferencing"><code>VolumeIntegralFluxDifferencing</code></a>. These specialized methods may enable better use of SIMD instructions to increase runtime efficiency on modern hardware.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L339-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}" href="#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>Trixi.flux_wintermeyer_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_wintermeyer_etal(u_ll, u_rr, orientation,
                      equations::ShallowWaterEquations1D)</code></pre><p>Total energy conservative (mathematical entropy for shallow water equations) split form. When the bottom topography is nonzero this scheme will be well-balanced when used as a <code>volume_flux</code>. The <code>surface_flux</code> should still use, e.g., <a href="#Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_fjordholm_etal</code></a>.</p><p>Further details are available in Theorem 1 of the paper:</p><ul><li>Niklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry <a href="https://doi.org/10.1016/j.jcp.2017.03.036">DOI: 10.1016/j.jcp.2017.03.036</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L381-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}" href="#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}"><code>Trixi.flux_wintermeyer_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_wintermeyer_etal(u_ll, u_rr, orientation_or_normal_direction,
                      equations::ShallowWaterEquations2D)</code></pre><p>Total energy conservative (mathematical entropy for shallow water equations) split form. When the bottom topography is nonzero this scheme will be well-balanced when used as a <code>volume_flux</code>. The <code>surface_flux</code> should still use, e.g., <a href="#Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}"><code>flux_fjordholm_etal</code></a>.</p><p>Further details are available in Theorem 1 of the paper:</p><ul><li>Niklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry <a href="https://doi.org/10.1016/j.jcp.2017.03.036">DOI: 10.1016/j.jcp.2017.03.036</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L660-L673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.flux_winters_etal-Tuple{Any, Any, AbstractVector, PolytropicEulerEquations2D}" href="#Trixi.flux_winters_etal-Tuple{Any, Any, AbstractVector, PolytropicEulerEquations2D}"><code>Trixi.flux_winters_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_winters_etal(u_ll, u_rr, orientation_or_normal_direction,
                  equations::PolytropicEulerEquations2D)</code></pre><p>Entropy conserving two-point flux for isothermal or polytropic gases. Requires a special weighted Stolarsky mean for the evaluation of the density denoted here as <code>stolarsky_mean</code>. Note, for isothermal gases where <code>gamma = 1</code> this <code>stolarsky_mean</code> becomes the <a href="#Trixi.ln_mean-Tuple{Any, Any}"><code>ln_mean</code></a>.</p><p>For details see Section 3.2 of the following reference</p><ul><li>Andrew R. Winters, Christof Czernik, Moritz B. Schily &amp; Gregor J. Gassner (2020) Entropy stable numerical approximations for the isothermal and polytropic Euler equations <a href="https://doi.org/10.1007/s10543-019-00789-w">DOI: 10.1007/s10543-019-00789-w</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/polytropic_euler_2d.jl#L158-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.gauss_nodes_weights-Tuple{Integer}" href="#Trixi.gauss_nodes_weights-Tuple{Integer}"><code>Trixi.gauss_nodes_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauss_nodes_weights(n_nodes::Integer)</code></pre><p>Computes nodes <span>$x_j$</span> and weights <span>$w_j$</span> for the Gauss-Legendre quadrature. This implements algorithm 23 &quot;LegendreGaussNodesAndWeights&quot; from the book</p><ul><li>David A. Kopriva, (2009).  Implementing spectral methods for partial differential equations: Algorithms for scientists and engineers.  <a href="https://doi.org/10.1007/978-90-481-2261-5">DOI:10.1007/978-90-481-2261-5</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L657-L667">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.get_boundary_outer_state-Tuple{BoundaryConditionDirichlet, Any, Any, Any, Any, Vararg{Any}}" href="#Trixi.get_boundary_outer_state-Tuple{BoundaryConditionDirichlet, Any, Any, Any, Any, Vararg{Any}}"><code>Trixi.get_boundary_outer_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_boundary_outer_state(boundary_condition::BoundaryConditionDirichlet,
                         cache, t, equations, dg, indices...)</code></pre><p>For subcell limiting, the calculation of local bounds for non-periodic domains require the boundary outer state. This function returns the boundary value at time <code>t</code> and for node with spatial indices <code>indices</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem_tree/dg_2d_subcell_limiters.jl#L467-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.get_examples-Tuple{}" href="#Trixi.get_examples-Tuple{}"><code>Trixi.get_examples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_examples()</code></pre><p>Return a list of all example elixirs that are provided by Trixi.jl. See also <a href="#Trixi.examples_dir-Tuple{}"><code>examples_dir</code></a> and <a href="#Trixi.default_example-Tuple{}"><code>default_example</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.get_name-Tuple{Any}" href="#Trixi.get_name-Tuple{Any}"><code>Trixi.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(x)</code></pre><p>Returns a name of <code>x</code> ready for pretty printing. By default, return <code>string(y)</code> if <code>x isa Val{y}</code> and return <code>string(x)</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Trixi.get_name(&quot;test&quot;)
&quot;test&quot;

julia&gt; Trixi.get_name(Val(:test))
&quot;test&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L183-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.get_name-Tuple{Trixi.AbstractEquations}" href="#Trixi.get_name-Tuple{Trixi.AbstractEquations}"><code>Trixi.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(equations::AbstractEquations)</code></pre><p>Returns the canonical, human-readable name for the given system of equations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Trixi.get_name(CompressibleEulerEquations1D(1.4))
&quot;CompressibleEulerEquations1D&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.getmesh-Tuple{Trixi.AbstractPlotData}" href="#Trixi.getmesh-Tuple{Trixi.AbstractPlotData}"><code>Trixi.getmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getmesh(pd::AbstractPlotData)</code></pre><p>Extract grid lines from <code>pd</code> for plotting with <code>Plots.plot</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/visualization/types.jl#L176-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.global_mean_vars-Tuple{AcousticPerturbationEquations2D}" href="#Trixi.global_mean_vars-Tuple{AcousticPerturbationEquations2D}"><code>Trixi.global_mean_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_mean_vars(equations::AcousticPerturbationEquations2D)</code></pre><p>Returns the global mean variables stored in <code>equations</code>. This makes it easier to define flexible initial conditions for problems with constant mean flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.have_nonconservative_terms-Tuple{Trixi.AbstractEquations}" href="#Trixi.have_nonconservative_terms-Tuple{Trixi.AbstractEquations}"><code>Trixi.have_nonconservative_terms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">have_nonconservative_terms(equations)</code></pre><p>Trait function determining whether <code>equations</code> represent a conservation law with or without nonconservative terms. Classical conservation laws such as the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a> do not have nonconservative terms. The <a href="#Trixi.ShallowWaterEquations2D"><code>ShallowWaterEquations2D</code></a> with non-constant bottom topography are an example of equations with nonconservative terms. The return value will be <code>True()</code> or <code>False()</code> to allow dispatching on the return type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L242-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations1D}" href="#Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations1D}"><code>Trixi.hydrostatic_reconstruction_audusse_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydrostatic_reconstruction_audusse_etal(u_ll, u_rr, orientation::Integer,
                                        equations::ShallowWaterEquations1D)</code></pre><p>A particular type of hydrostatic reconstruction on the water height to guarantee well-balancedness for a general bottom topography <a href="#Trixi.ShallowWaterEquations1D"><code>ShallowWaterEquations1D</code></a>. The reconstructed solution states <code>u_ll_star</code> and <code>u_rr_star</code> variables are then used to evaluate the surface numerical flux at the interface. Use in combination with the generic numerical flux routine <a href="#Trixi.FluxHydrostaticReconstruction"><code>FluxHydrostaticReconstruction</code></a>.</p><p>Further details on this hydrostatic reconstruction and its motivation can be found in</p><ul><li>Emmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows <a href="https://doi.org/10.1137/S1064827503431090">DOI: 10.1137/S1064827503431090</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L416-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations2D}" href="#Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations2D}"><code>Trixi.hydrostatic_reconstruction_audusse_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydrostatic_reconstruction_audusse_etal(u_ll, u_rr, orientation_or_normal_direction,
                                        equations::ShallowWaterEquations2D)</code></pre><p>A particular type of hydrostatic reconstruction on the water height to guarantee well-balancedness for a general bottom topography <a href="#Trixi.ShallowWaterEquations2D"><code>ShallowWaterEquations2D</code></a>. The reconstructed solution states <code>u_ll_star</code> and <code>u_rr_star</code> variables are used to evaluate the surface numerical flux at the interface. Use in combination with the generic numerical flux routine <a href="#Trixi.FluxHydrostaticReconstruction"><code>FluxHydrostaticReconstruction</code></a>.</p><p>Further details for the hydrostatic reconstruction and its motivation can be found in</p><ul><li>Emmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows <a href="https://doi.org/10.1137/S1064827503431090">DOI: 10.1137/S1064827503431090</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L404-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.init_mpi-Tuple{}" href="#Trixi.init_mpi-Tuple{}"><code>Trixi.init_mpi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_mpi()</code></pre><p>Initialize MPI by calling <code>MPI.Initialized()</code>. The function will check if MPI is already initialized and if yes, do nothing, thus it is safe to call it multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/mpi.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.init_p4est-Tuple{}" href="#Trixi.init_p4est-Tuple{}"><code>Trixi.init_p4est</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_p4est()</code></pre><p>Initialize <code>p4est</code> by calling <code>p4est_init</code> and setting the log level to <code>SC_LP_ERROR</code>. This function will check if <code>p4est</code> is already initialized and if yes, do nothing, thus it is safe to call it multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/p4est.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.init_t8code-Tuple{}" href="#Trixi.init_t8code-Tuple{}"><code>Trixi.init_t8code</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_t8code()</code></pre><p>Initialize <code>t8code</code> by calling <code>sc_init</code>, <code>p4est_init</code>, and <code>t8_init</code> while setting the log level to <code>SC_LP_ERROR</code>. This function will check if <code>t8code</code> is already initialized and if yes, do nothing, thus it is safe to call it multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/t8code.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>A constant initial condition where the state variables are zero and the mean flow is constant. Uses the global mean values from <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::IdealGlmMhdEquations3D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, InviscidBurgersEquation1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, InviscidBurgersEquation1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::InviscidBurgersEquation1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/inviscid_burgers_1d.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LatticeBoltzmannEquations2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LatticeBoltzmannEquations3D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_3d.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a>. Uses the global mean values from <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquationsQuasi1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquationsQuasi1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerEquationsQuasi1D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_quasi_1d.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_1d.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_2d.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations3D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations3D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations3D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations1D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, InviscidBurgersEquation1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, InviscidBurgersEquation1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::InviscidBurgersEquation1D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/inviscid_burgers_1d.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A smooth initial condition used for convergence tests (in combination with <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_3d.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearizedEulerEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearizedEulerEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearizedEulerEquations1D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_1d.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearizedEulerEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearizedEulerEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearizedEulerEquations2D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_2d.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearizedEulerEquations3D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearizedEulerEquations3D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearizedEulerEquations3D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linearized_euler_3d.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, PolytropicEulerEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, PolytropicEulerEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::PolytropicEulerEquations2D)</code></pre><p>Manufactured smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/polytropic_euler_2d.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, ShallowWaterEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, ShallowWaterEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::ShallowWaterEquations2D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, ShallowWaterEquationsQuasi1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, ShallowWaterEquationsQuasi1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::ShallowWaterEquationsQuasi1D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_quasi_1d.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, TrafficFlowLWREquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, TrafficFlowLWREquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::TrafficFlowLWREquations1D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/traffic_flow_lwr_1d.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_density_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_wave(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper</p><ul><li>Gregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes <a href="https://arxiv.org/abs/2007.09026">arXiv: 2007.09026</a></li></ul><p>with the following parameters</p><ul><li>domain [-1, 1]</li><li>mesh = 4x4</li><li>polydeg = 5</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L118-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_density_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_wave(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper</p><ul><li>Gregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes <a href="https://arxiv.org/abs/2007.09026">arXiv: 2007.09026</a></li></ul><p>with the following parameters</p><ul><li>domain [-1, 1]</li><li>mesh = 4x4</li><li>polydeg = 5</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L127-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>One dimensional variant of the setup used for convergence tests of the Euler equations with self-gravity from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is no additional source term necessary for the manufactured solution in one spatial dimension. Thus, <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> is not present there.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L170-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> or <a href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_euler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L180-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> or <a href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_euler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L165-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations1D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_harmonic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_1d.jl#L128-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_harmonic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_2d.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_harmonic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_3d.jl#L119-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>A Gaussian pulse in a constant mean flow. Uses the global mean values from <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A Gaussian pulse used together with <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_gauss)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equation::LinearScalarAdvectionEquation2D)</code></pre><p>A Gaussian pulse used together with <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_gauss)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A Gaussian pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_3d.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A linear function of <code>x[1]</code> used together with <a href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}"><code>boundary_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A linear function of <code>x[1]</code> used together with <a href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}"><code>boundary_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_linear_x_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_x_y(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A linear function of <code>x[1] + x[2]</code> used together with <a href="#Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>boundary_condition_linear_x_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_linear_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_y(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A linear function of <code>x[1]</code> used together with <a href="#Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>boundary_condition_linear_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_linear_z-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_linear_z-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_linear_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_z(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A linear function of <code>x[3]</code> used together with <a href="#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}"><code>boundary_condition_linear_z</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_3d.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.initial_condition_poisson_nonperiodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_poisson_nonperiodic(x, t, equations::HyperbolicDiffusionEquations1D)</code></pre><p>A non-priodic smooth initial condition. Can be used for convergence tests in combination with <a href="#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_poisson_nonperiodic</code></a> and <a href="#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>boundary_condition_poisson_nonperiodic</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The solution is periodic but the initial guess is not.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_1d.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A sine wave in the conserved variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A sine wave in the conserved variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_3d.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_sin_sin-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_sin_sin-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_sin_sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sin_sin(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A sine wave in the conserved variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_2d.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L152-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>A weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L135-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>A for multicomponent adapted weak blast wave adapted to multicomponent and taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_1d.jl#L186-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>A for multicomponent adapted weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_2d.jl#L201-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L86-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations3D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations3D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations3D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdMulticomponentEquations1D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L104-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L112-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, PolytropicEulerEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, PolytropicEulerEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::PolytropicEulerEquations2D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/polytropic_euler_2d.jl#L98-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, ShallowWaterEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, ShallowWaterEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::ShallowWaterEquations1D)</code></pre><p>A weak blast wave discontinuity useful for testing, e.g., total energy conservation. Note for the shallow water equations to the total energy acts as a mathematical entropy function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_1d.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, ShallowWaterEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, ShallowWaterEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::ShallowWaterEquations2D)</code></pre><p>A weak blast wave discontinuity useful for testing, e.g., total energy conservation. Note for the shallow water equations to the total energy acts as a mathematical entropy function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.integrate_via_indices-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization, Vararg{Any}}} where Func" href="#Trixi.integrate_via_indices-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization, Vararg{Any}}} where Func"><code>Trixi.integrate_via_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate_via_indices(func, u_ode, semi::AbstractSemidiscretization, args...; normalize=true)</code></pre><p>Call <code>func(u, i..., element, equations, solver, args...)</code> for all nodal indices <code>i..., element</code> and integrate the result using a quadrature associated with the semidiscretization <code>semi</code>.</p><p>If <code>normalize</code> is true, the result is divided by the total volume of the computational domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.inv_ln_mean-Tuple{Any, Any}" href="#Trixi.inv_ln_mean-Tuple{Any, Any}"><code>Trixi.inv_ln_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv_ln_mean(x, y)</code></pre><p>Compute the inverse <code>1 / ln_mean(x, y)</code> of the logarithmic mean <a href="#Trixi.ln_mean-Tuple{Any, Any}"><code>ln_mean</code></a>.</p><p>This function may be used to increase performance where the inverse of the logarithmic mean is needed, by replacing a (slow) division by a (fast) multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.jacobian_ad_forward-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.jacobian_ad_forward-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.jacobian_ad_forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian_ad_forward(semi::AbstractSemidiscretization;
                    t0=zero(real(semi)),
                    u0_ode=compute_coefficients(t0, semi))</code></pre><p>Uses the right-hand side operator of the semidiscretization <code>semi</code> and forward mode automatic differentiation to compute the Jacobian <code>J</code> of the semidiscretization <code>semi</code> at state <code>u0_ode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L229-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.jacobian_fd-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.jacobian_fd-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.jacobian_fd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian_fd(semi::AbstractSemidiscretization;
            t0=zero(real(semi)),
            u0_ode=compute_coefficients(t0, semi))</code></pre><p>Uses the right-hand side operator of the semidiscretization <code>semi</code> and simple second order finite difference to compute the Jacobian <code>J</code> of the semidiscretization <code>semi</code> at state <code>u0_ode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L182-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.lagrange_interpolating_polynomials-Tuple{Any, Any, Any}" href="#Trixi.lagrange_interpolating_polynomials-Tuple{Any, Any, Any}"><code>Trixi.lagrange_interpolating_polynomials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lagrange_interpolating_polynomials(x, nodes, wbary)</code></pre><p>Calculate Lagrange polynomials for a given node distribution with associated barycentric weights <code>wbary</code> at a given point <code>x</code> on the  reference interval <span>$[-1, 1]$</span>.</p><p>This returns all <span>$l_j(x)$</span>, i.e., the Lagrange polynomials for each node <span>$x_j$</span>. Thus, to obtain the interpolating polynomial <span>$p(x)$</span> at <span>$x$</span>, one has to  multiply the Lagrange polynomials with the nodal values <span>$u_j$</span> and sum them up: <span>$p(x) = \sum_{j=1}^{n} u_j l_j(x)$</span>.</p><p>For details, see e.g. Section 2 of </p><ul><li>Jean-Paul Berrut and Lloyd N. Trefethen (2004). Barycentric Lagrange Interpolation. <a href="https://doi.org/10.1137/S0036144502417715">DOI:10.1137/S0036144502417715</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L512-L529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.legendre_polynomial_and_derivative-Tuple{Int64, Real}" href="#Trixi.legendre_polynomial_and_derivative-Tuple{Int64, Real}"><code>Trixi.legendre_polynomial_and_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">legendre_polynomial_and_derivative(N::Int, x::Real)</code></pre><p>Computes the Legendre polynomial of degree <code>N</code> and its derivative at <code>x</code>. This implements algorithm 22 &quot;LegendrePolynomialAndDerivative&quot; from the book</p><ul><li>David A. Kopriva, (2009).  Implementing spectral methods for partial differential equations: Algorithms for scientists and engineers.  <a href="https://doi.org/10.1007/978-90-481-2261-5">DOI:10.1007/978-90-481-2261-5</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/basis_lobatto_legendre.jl#L724-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.linear_structure-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.linear_structure-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.linear_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_structure(semi::AbstractSemidiscretization;
                 t0=zero(real(semi)))</code></pre><p>Wraps the right-hand side operator of the semidiscretization <code>semi</code> at time <code>t0</code> as an affine-linear operator given by a linear operator <code>A</code> and a vector <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L149-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ln_mean-Tuple{Any, Any}" href="#Trixi.ln_mean-Tuple{Any, Any}"><code>Trixi.ln_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ln_mean(x, y)</code></pre><p>Compute the logarithmic mean</p><pre><code class="nohighlight hljs">ln_mean(x, y) = (y - x) / (log(y) - log(x)) = (y - x) / log(y / x)</code></pre><p>Problem: The formula above has a removable singularity at <code>x == y</code>. Thus, some care must be taken to implement it correctly without problems or loss of accuracy when <code>x ≈ y</code>. Here, we use the approach proposed by Ismail and Roe (2009). Set ξ = y / x. Then, we have</p><pre><code class="nohighlight hljs">(y - x) / log(y / x) = (x + y) / log(ξ) * (ξ - 1) / (ξ + 1)</code></pre><p>Set f = (ξ - 1) / (ξ + 1) = (y - x) / (x + y). Then, we use the expansion</p><pre><code class="nohighlight hljs">log(ξ) = 2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7) + O(ξ^9)</code></pre><p>Inserting the first few terms of this expansion yields</p><pre><code class="nohighlight hljs">(y - x) / log(ξ) ≈ (x + y) * f / (2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7))
                 = (x + y) / (2 + 2/3 * f^2 + 2/5 * f^4 + 2/7 * f^6)</code></pre><p>Since divisions are usually more expensive on modern hardware than multiplications (Agner Fog), we try to avoid computing two divisions. Thus, we use</p><pre><code class="nohighlight hljs">f^2 = (y - x)^2 / (x + y)^2
    = (x * (x - 2 * y) + y * y) / (x * (x + 2 * y) + y * y)</code></pre><p>Given ε = 1.0e-4, we use the following algorithm.</p><pre><code class="nohighlight hljs">if f^2 &lt; ε
  # use the expansion above
else
  # use the direct formula (y - x) / log(y / x)
end</code></pre><p><strong>References</strong></p><ul><li>Ismail, Roe (2009). Affordable, entropy-consistent Euler flux functions II: Entropy production at shocks. <a href="https://doi.org/10.1016/j.jcp.2009.04.021">DOI: 10.1016/j.jcp.2009.04.021</a></li><li>Agner Fog. Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD, and VIA CPUs. <a href="https://www.agner.org/optimize/instruction_tables.pdf">https://www.agner.org/optimize/instruction_tables.pdf</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L105-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.load_adaptive_time_integrator!-Tuple{Any, AbstractString}" href="#Trixi.load_adaptive_time_integrator!-Tuple{Any, AbstractString}"><code>Trixi.load_adaptive_time_integrator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_adaptive_time_integrator!(integrator, restart_file::AbstractString)</code></pre><p>Load the context information for time integrators with error-based step size control saved in a <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/save_restart.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.load_dt-Tuple{AbstractString}" href="#Trixi.load_dt-Tuple{AbstractString}"><code>Trixi.load_dt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_dt(restart_file::AbstractString)</code></pre><p>Load the time step size (<code>dt</code> in OrdinaryDiffEq.jl) saved in a <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/save_restart.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.load_mesh-Tuple{AbstractString}" href="#Trixi.load_mesh-Tuple{AbstractString}"><code>Trixi.load_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_mesh(restart_file::AbstractString; n_cells_max)</code></pre><p>Load the mesh from the <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/mesh_io.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.load_time-Tuple{AbstractString}" href="#Trixi.load_time-Tuple{AbstractString}"><code>Trixi.load_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_time(restart_file::AbstractString)</code></pre><p>Load the time saved in a <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/save_restart.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.load_timestep!-Tuple{Any, AbstractString}" href="#Trixi.load_timestep!-Tuple{Any, AbstractString}"><code>Trixi.load_timestep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_timestep!(integrator, restart_file::AbstractString)</code></pre><p>Load the time step number saved in a <code>restart_file</code> and assign it to both the time step number and and the number of accepted steps (<code>iter</code> and <code>stats.naccept</code> in OrdinaryDiffEq.jl, respectively) in <code>integrator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/save_restart.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.load_timestep-Tuple{AbstractString}" href="#Trixi.load_timestep-Tuple{AbstractString}"><code>Trixi.load_timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_timestep(restart_file::AbstractString)</code></pre><p>Load the time step number (<code>iter</code> in OrdinaryDiffEq.jl) saved in a <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/save_restart.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.max-Tuple" href="#Trixi.max-Tuple"><code>Trixi.max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max(x, y, ...)</code></pre><p>Return the maximum of the arguments. See also the <code>maximum</code> function to take the maximum element from a collection.</p><p>This version in Trixi.jl is semantically equivalent to <code>Base.max</code> but may be implemented differently. In particular, it may avoid potentially expensive checks necessary in the presence of <code>NaN</code>s (or signed zeros).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; max(2, 5, 1)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L254-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.max_abs_speed_naive" href="#Trixi.max_abs_speed_naive"><code>Trixi.max_abs_speed_naive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_abs_speed_naive(u_ll, u_rr, orientation::Integer,   equations)
max_abs_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)</code></pre><p>Simple and fast estimate of the maximal wave speed of the Riemann problem with left and right states <code>u_ll, u_rr</code>, based only on the local wave speeds associated to <code>u_ll</code> and <code>u_rr</code>.</p><p>For non-integer arguments <code>normal_direction</code> in one dimension, <code>max_abs_speed_naive</code> returns <code>abs(normal_direction[1]) * max_abs_speed_naive(u_ll, u_rr, 1, equations)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L182-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min-Tuple" href="#Trixi.min-Tuple"><code>Trixi.min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min(x, y, ...)</code></pre><p>Return the minimum of the arguments. See also the <code>minimum</code> function to take the minimum element from a collection.</p><p>This version in Trixi.jl is semantically equivalent to <code>Base.min</code> but may be implemented differently. In particular, it may avoid potentially expensive checks necessary in the presence of <code>NaN</code>s (or signed zeros).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; min(2, 5, 1)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L273-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_davis" href="#Trixi.min_max_speed_davis"><code>Trixi.min_max_speed_davis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_davis(u_ll, u_rr, orientation::Integer, equations)
min_max_speed_davis(u_ll, u_rr, normal_direction::AbstractVector, equations)</code></pre><p>Simple and fast estimates of the minimal and maximal wave speed of the Riemann problem with left and right states <code>u_ll, u_rr</code>, usually based only on the local wave speeds associated to <code>u_ll</code> and <code>u_rr</code>.</p><ul><li>S.F. Davis (1988) Simplified Second-Order Godunov-Type Methods <a href="https://doi.org/10.1137/0909030">DOI: 10.1137/0909030</a></li></ul><p>See eq. (10.38) from</p><ul><li>Eleuterio F. Toro (2009) Riemann Solvers and Numerical Methods for Fluid Dynamics: A Practical Introduction <a href="https://doi.org/10.1007/b79761">DOI: 10.1007/b79761</a></li></ul><p>See also <a href="#Trixi.FluxHLL"><code>FluxHLL</code></a>, <a href="#Trixi.min_max_speed_naive"><code>min_max_speed_naive</code></a>, <a href="#Trixi.min_max_speed_einfeldt"><code>min_max_speed_einfeldt</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L263-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt" href="#Trixi.min_max_speed_einfeldt"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, orientation::Integer, equations)
min_max_speed_einfeldt(u_ll, u_rr, normal_direction::AbstractVector, equations)</code></pre><p>More advanced mininmal and maximal wave speed computation based on</p><ul><li>Bernd Einfeldt (1988) On Godunov-type methods for gas dynamics. <a href="https://doi.org/10.1137/0725021">DOI: 10.1137/0725021</a></li><li>Bernd Einfeldt, Claus-Dieter Munz, Philip L. Roe and Björn Sjögreen (1991) On Godunov-type methods near low densities. <a href="https://doi.org/10.1016/0021-9991(91)90211-3">DOI: 10.1016/0021-9991(91)90211-3</a></li></ul><p>originally developed for the compressible Euler equations. A compact representation can be found in <a href="https://metaphor.ethz.ch/x/2019/hs/401-4671-00L/literature/mishra_hyperbolic_pdes.pdf">this lecture notes, eq. (9.28)</a>.</p><p>See also <a href="#Trixi.FluxHLL"><code>FluxHLL</code></a>, <a href="#Trixi.min_max_speed_naive"><code>min_max_speed_naive</code></a>, <a href="#Trixi.min_max_speed_davis"><code>min_max_speed_davis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L283-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, AbstractVector, CompressibleEulerEquations2D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, AbstractVector, CompressibleEulerEquations2D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, normal_direction, equations::CompressibleEulerEquations2D)</code></pre><p>Computes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.</p><ul><li>Bernd Einfeldt (1988) On Godunov-type methods for gas dynamics. <a href="https://doi.org/10.1137/0725021">DOI: 10.1137/0725021</a></li><li>Bernd Einfeldt, Claus-Dieter Munz, Philip L. Roe and Björn Sjögreen (1991) On Godunov-type methods near low densities. <a href="https://doi.org/10.1016/0021-9991(91)90211-3">DOI: 10.1016/0021-9991(91)90211-3</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L1794-L1808">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, AbstractVector, CompressibleEulerEquations3D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, AbstractVector, CompressibleEulerEquations3D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, normal_direction, equations::CompressibleEulerEquations3D)</code></pre><p>Computes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.</p><ul><li>Bernd Einfeldt (1988) On Godunov-type methods for gas dynamics. <a href="https://doi.org/10.1137/0725021">DOI: 10.1137/0725021</a></li><li>Bernd Einfeldt, Claus-Dieter Munz, Philip L. Roe and Björn Sjögreen (1991) On Godunov-type methods near low densities. <a href="https://doi.org/10.1016/0021-9991(91)90211-3">DOI: 10.1016/0021-9991(91)90211-3</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L1525-L1539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Computes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.</p><p>Original publication:</p><ul><li>Bernd Einfeldt (1988) On Godunov-type methods for gas dynamics. <a href="https://doi.org/10.1137/0725021">DOI: 10.1137/0725021</a></li></ul><p>Compactly summarized:</p><ul><li>Siddhartha Mishra, Ulrik Skre Fjordholm and Rémi Abgrall Numerical methods for conservation laws and related equations. <a href="https://metaphor.ethz.ch/x/2019/hs/401-4671-00L/literature/mishra_hyperbolic_pdes.pdf">Link</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L815-L832">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)</code></pre><p>Computes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.</p><ul><li>Bernd Einfeldt (1988) On Godunov-type methods for gas dynamics. <a href="https://doi.org/10.1137/0725021">DOI: 10.1137/0725021</a></li><li>Bernd Einfeldt, Claus-Dieter Munz, Philip L. Roe and Björn Sjögreen (1991) On Godunov-type methods near low densities. <a href="https://doi.org/10.1016/0021-9991(91)90211-3">DOI: 10.1016/0021-9991(91)90211-3</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L1737-L1751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)</code></pre><p>Computes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.</p><ul><li>Bernd Einfeldt (1988) On Godunov-type methods for gas dynamics. <a href="https://doi.org/10.1137/0725021">DOI: 10.1137/0725021</a></li><li>Bernd Einfeldt, Claus-Dieter Munz, Philip L. Roe and Björn Sjögreen (1991) On Godunov-type methods near low densities. <a href="https://doi.org/10.1016/0021-9991(91)90211-3">DOI: 10.1016/0021-9991(91)90211-3</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L1464-L1478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, orientation::Integer, equations::IdealGlmMhdEquations1D)</code></pre><p>Calculate minimum and maximum wave speeds for HLL-type fluxes as in</p><ul><li>Li (2005) An HLLC Riemann solver for magneto-hydrodynamics <a href="https://doi.org/10.1016/j.jcp.2004.08.020">DOI: 10.1016/j.jcp.2004.08.020</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_1d.jl#L462-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, orientation::Integer, equations::IdealGlmMhdEquations2D)</code></pre><p>Calculate minimum and maximum wave speeds for HLL-type fluxes as in</p><ul><li>Li (2005) An HLLC Riemann solver for magneto-hydrodynamics <a href="https://doi.org/10.1016/j.jcp.2004.08.020">DOI: 10.1016/j.jcp.2004.08.020</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_2d.jl#L885-L892">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.min_max_speed_einfeldt-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.min_max_speed_einfeldt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_einfeldt(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations3D)</code></pre><p>Calculate minimum and maximum wave speeds for HLL-type fluxes as in</p><ul><li>Li (2005) An HLLC Riemann solver for magneto-hydrodynamics <a href="https://doi.org/10.1016/j.jcp.2004.08.020">DOI: 10.1016/j.jcp.2004.08.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/ideal_glm_mhd_3d.jl#L802-L809">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.min_max_speed_naive" href="#Trixi.min_max_speed_naive"><code>Trixi.min_max_speed_naive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_naive(u_ll, u_rr, orientation::Integer, equations)
min_max_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)</code></pre><p>Simple and fast estimate(!) of the minimal and maximal wave speed of the Riemann problem with left and right states <code>u_ll, u_rr</code>, usually based only on the local wave speeds associated to <code>u_ll</code> and <code>u_rr</code>. Slightly more diffusive than <a href="#Trixi.min_max_speed_davis"><code>min_max_speed_davis</code></a>.</p><ul><li>Amiram Harten, Peter D. Lax, Bram van Leer (1983) On Upstream Differencing and Godunov-Type Schemes for Hyperbolic Conservation Laws <a href="https://doi.org/10.1137/1025002">DOI: 10.1137/1025002</a></li></ul><p>See eq. (10.37) from</p><ul><li>Eleuterio F. Toro (2009) Riemann Solvers and Numerical Methods for Fluid Dynamics: A Practical Introduction <a href="https://doi.org/10.1007/b79761">DOI: 10.1007/b79761</a></li></ul><p>See also <a href="#Trixi.FluxHLL"><code>FluxHLL</code></a>, <a href="#Trixi.min_max_speed_davis"><code>min_max_speed_davis</code></a>, <a href="#Trixi.min_max_speed_einfeldt"><code>min_max_speed_einfeldt</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/numerical_fluxes.jl#L242-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.modify_dt_for_tstops!-Tuple{Trixi.SimpleIntegratorSSP}" href="#Trixi.modify_dt_for_tstops!-Tuple{Trixi.SimpleIntegratorSSP}"><code>Trixi.modify_dt_for_tstops!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modify_dt_for_tstops!(integrator::SimpleIntegratorSSP)</code></pre><p>Modify the time-step size to match the time stops specified in integrator.opts.tstops. To avoid adding OrdinaryDiffEq to Trixi&#39;s dependencies, this routine is a copy of https://github.com/SciML/OrdinaryDiffEq.jl/blob/d76335281c540ee5a6d1bd8bb634713e004f62ee/src/integrators/integrator_utils.jl#L38-L54</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_SSP.jl#L269-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.multiply_dimensionwise-Tuple{AbstractMatrix, AbstractMatrix}" href="#Trixi.multiply_dimensionwise-Tuple{AbstractMatrix, AbstractMatrix}"><code>Trixi.multiply_dimensionwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiply_dimensionwise(matrix::AbstractMatrix, data_in::AbstractArray{&lt;:Any, NDIMS+1})</code></pre><p>Multiply the array <code>data_in</code> by <code>matrix</code> in each coordinate direction, where <code>data_in</code> is assumed to have the first coordinate for the number of variables and the remaining coordinates are multiplied by <code>matrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/solvers/dgsem/interpolation.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.n_nonconservative_terms" href="#Trixi.n_nonconservative_terms"><code>Trixi.n_nonconservative_terms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">n_nonconservative_terms(equations)</code></pre><p>Number of nonconservative terms in the form local * symmetric for a particular equation. This function needs to be specialized only if equations with nonconservative terms are combined with certain solvers (e.g., subcell limiting).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L253-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ndofs-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.ndofs-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.ndofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndofs(semi::AbstractSemidiscretization)</code></pre><p>Return the number of degrees of freedom associated with each scalar variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/semidiscretization/semidiscretization.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.negative_part-Tuple{Any}" href="#Trixi.negative_part-Tuple{Any}"><code>Trixi.negative_part</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negative_part(x)</code></pre><p>Return <code>x</code> if <code>x</code> is negative, else zero. In other words, return <code>(x - abs(x)) / 2</code> for real numbers <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L302-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ode_default_options-Tuple{}" href="#Trixi.ode_default_options-Tuple{}"><code>Trixi.ode_default_options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ode_default_options()</code></pre><p>Return the default options for OrdinaryDiffEq&#39;s <code>solve</code>. Pass <code>ode_default_options()...</code> to <code>solve</code> to only return the solution at the final time and enable <strong>MPI aware</strong> error-based step size control, whenever MPI is used. For example, use <code>solve(ode, alg; ode_default_options()...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L152-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ode_norm-Tuple{Number, Any}" href="#Trixi.ode_norm-Tuple{Number, Any}"><code>Trixi.ode_norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ode_norm(u, t)</code></pre><p>Implementation of the weighted L2 norm of Hairer and Wanner used for error-based step size control in OrdinaryDiffEq.jl. This function is aware of MPI and uses global MPI communication when running in parallel.</p><p>You must pass this function as a keyword argument <code>internalnorm=ode_norm</code> to OrdinaryDiffEq.jl&#39;s <code>solve</code> when using error-based step size control with MPI parallel execution of Trixi.jl.</p><p>See the &quot;Advanced Adaptive Stepsize Control&quot; section of the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/">documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/mpi.jl#L63-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.ode_unstable_check-NTuple{4, Any}" href="#Trixi.ode_unstable_check-NTuple{4, Any}"><code>Trixi.ode_unstable_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ode_unstable_check(dt, u, semi, t)</code></pre><p>Implementation of the basic check for instability used in OrdinaryDiffEq.jl. Instead of checking something like <code>any(isnan, u)</code>, this function just checks <code>isnan(dt)</code>. This helps when using MPI parallelization, since no additional global communication is required and all ranks will return the same result.</p><p>You should pass this function as a keyword argument <code>unstable_check=ode_unstable_check</code> to OrdinaryDiffEq.jl&#39;s  <code>solve</code> when using error-based step size control with MPI parallel execution of Trixi.jl.</p><p>See the &quot;Miscellaneous&quot; section of the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/">documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/mpi.jl#L115-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.partition!-Tuple{T8codeMesh}" href="#Trixi.partition!-Tuple{T8codeMesh}"><code>Trixi.partition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Trixi.partition!(mesh::T8codeMesh)</code></pre><p>Partition a <code>T8codeMesh</code> in order to redistribute elements evenly among MPI ranks.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::T8codeMesh</code>: Initialized mesh object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/t8code_mesh.jl#L764-L771">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.partition!-Tuple{TreeMesh{NDIMS, &lt;:Trixi.ParallelTree{NDIMS}} where NDIMS}" href="#Trixi.partition!-Tuple{TreeMesh{NDIMS, &lt;:Trixi.ParallelTree{NDIMS}} where NDIMS}"><code>Trixi.partition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition!(mesh::ParallelTreeMesh, allow_coarsening=true)</code></pre><p>Partition <code>mesh</code> using a static domain decomposition algorithm based on leaf cell count and tree structure. If <code>allow_coarsening</code> is <code>true</code>, the algorithm will keep leaf cells together on one rank when needed for local coarsening (i.e. when all children of a cell are leaves).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/meshes/parallel_tree_mesh.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.positive_part-Tuple{Any}" href="#Trixi.positive_part-Tuple{Any}"><code>Trixi.positive_part</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">positive_part(x)</code></pre><p>Return <code>x</code> if <code>x</code> is positive, else zero. In other words, return <code>(x + abs(x)) / 2</code> for real numbers <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L292-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations2D}" href="#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations2D}"><code>Trixi.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure(rho::Real, equations::LatticeBoltzmannEquations2D)
pressure(u, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic pressure from the density <code>rho</code> or the  particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L298-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations3D}" href="#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations3D}"><code>Trixi.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure(rho::Real, equations::LatticeBoltzmannEquations3D)
pressure(u, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic pressure from the density <code>rho</code> or the  particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L291-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.prim2cons" href="#Trixi.prim2cons"><code>Trixi.prim2cons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prim2cons(u, equations)</code></pre><p>Convert the primitive variables <code>u</code> to the conserved variables for a given set of <code>equations</code>. <code>u</code> is a vector type of the correct length <code>nvariables(equations)</code>. Notice the function doesn&#39;t include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by <a href="#Trixi.cons2prim"><code>cons2prim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L299-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}" href="#Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}"><code>Trixi.residual_steady_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_steady_state(du, ::AbstractHyperbolicDiffusionEquations)</code></pre><p>Used to determine the termination criterion of a <a href="#Trixi.SteadyStateCallback"><code>SteadyStateCallback</code></a>. For hyperbolic diffusion, this checks convergence of the potential <span>$\phi$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_3d.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.rotate_from_x" href="#Trixi.rotate_from_x"><code>Trixi.rotate_from_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate_from_x(u, normal, equations)</code></pre><p>Apply the rotation that maps the x-axis onto <code>normal</code> to the convservative variables <code>u</code>. This is used by <a href="#Trixi.FluxRotated"><code>FluxRotated</code></a> to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.</p><p>See also: <a href="#Trixi.rotate_to_x"><code>rotate_to_x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.rotate_to_x" href="#Trixi.rotate_to_x"><code>Trixi.rotate_to_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate_to_x(u, normal, equations)</code></pre><p>Apply the rotation that maps <code>normal</code> onto the x-axis to the convservative variables <code>u</code>. This is used by <a href="#Trixi.FluxRotated"><code>FluxRotated</code></a> to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.</p><p>See also: <a href="#Trixi.rotate_from_x"><code>rotate_from_x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.save_plot-Tuple{Any, Any}" href="#Trixi.save_plot-Tuple{Any, Any}"><code>Trixi.save_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_plot(plot_data, variable_names;
          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),
          time=nothing, timestep=nothing)</code></pre><p>Visualize the plot data object provided in <code>plot_data</code> and save result as a PNG file in the <code>out</code> directory, plotting only the variables in <code>variable_names</code> and, optionally, the mesh (if <code>show_mesh</code> is <code>true</code>).  Additionally, <code>plot_arguments</code> will be unpacked and passed as keyword arguments to the <code>Plots.plot</code> command.</p><p>The <code>timestep</code> is used in the filename. <code>time</code> is currently unused by this function.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p>See also: <a href="#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a>, <a href="#Trixi.show_plot-Tuple{Any, Any}"><code>show_plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/visualization.jl#L221-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.set_log_type-Tuple{Any}" href="#Trixi.set_log_type-Tuple{Any}"><code>Trixi.set_log_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Trixi.set_log_type(type; force = true)</code></pre><p>Set the <code>type</code> of the (natural) <code>log</code> function to be used in Trixi.jl. The default is <code>&quot;sqrt_Trixi_NaN&quot;</code> which returns <code>NaN</code> for negative arguments instead of throwing an error. Alternatively, you can set <code>type</code> to <code>&quot;sqrt_Base&quot;</code> to use the Julia built-in <code>sqrt</code> function  which provides a stack-trace of the error which might come in handy when debugging code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.set_sqrt_type-Tuple{Any}" href="#Trixi.set_sqrt_type-Tuple{Any}"><code>Trixi.set_sqrt_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Trixi.set_sqrt_type(type; force = true)</code></pre><p>Set the <code>type</code> of the square root function to be used in Trixi.jl. The default is <code>&quot;sqrt_Trixi_NaN&quot;</code> which returns <code>NaN</code> for negative arguments instead of throwing an error. Alternatively, you can set <code>type</code> to <code>&quot;sqrt_Base&quot;</code> to use the Julia built-in <code>sqrt</code> function  which provides a stack-trace of the error which might come in handy when debugging code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.show_plot-Tuple{Any, Any}" href="#Trixi.show_plot-Tuple{Any, Any}"><code>Trixi.show_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_plot(plot_data, variable_names;
          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),
          time=nothing, timestep=nothing)</code></pre><p>Visualize the plot data object provided in <code>plot_data</code> and display result, plotting only the variables in <code>variable_names</code> and, optionally, the mesh (if <code>show_mesh</code> is <code>true</code>).  Additionally, <code>plot_arguments</code> will be unpacked and passed as keyword arguments to the <code>Plots.plot</code> command.</p><p>This function is the default <code>plot_creator</code> argument for the <a href="#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a>. <code>time</code> and <code>timestep</code> are currently unused by this function.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p>See also: <a href="#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a>, <a href="#Trixi.save_plot-Tuple{Any, Any}"><code>save_plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/visualization.jl#L169-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.solve" href="#Trixi.solve"><code>Trixi.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve(ode, alg; dt, callbacks, kwargs...)</code></pre><p>The following structures and methods provide the infrastructure for SSP Runge-Kutta methods of type <code>SimpleAlgorithmSSP</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/time_integration/methods_SSP.jl#L131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/acoustic_perturbation_2d.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquationsQuasi1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquationsQuasi1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquationsQuasi1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p><p>This manufactured solution source term is specifically designed for the mozzle width &#39;a(x) = 1.5 - 0.5 * cos(x[1] * pi)&#39; as defined in <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_quasi_1d.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_1d.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_2d.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, InviscidBurgersEquation1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, InviscidBurgersEquation1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::InviscidBurgersEquation1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/inviscid_burgers_1d.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, PolytropicEulerEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, PolytropicEulerEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::PolytropicEulerEquations2D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/polytropic_euler_2d.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, ShallowWaterEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, ShallowWaterEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::ShallowWaterEquations2D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p><p>This manufactured solution source term is specifically designed for the bottom topography function <code>b(x,y) = 2 + 0.5 * sin(sqrt(2)*pi*x) + 0.5 * sin(sqrt(2)*pi*y)</code> as defined in <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_2d.jl#L93-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, ShallowWaterEquationsQuasi1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, ShallowWaterEquationsQuasi1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::ShallowWaterEquationsQuasi1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p><p>This manufactured solution source term is specifically designed for the bottom topography function <code>b(x) = 0.2 - 0.05 * sin(sqrt(2) * pi *x[1])</code> and channel width &#39;a(x)= 1 + 0.1 * cos(sqrt(2) * pi * x[1])&#39; as defined in <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/shallow_water_quasi_1d.jl#L83-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, TrafficFlowLWREquations1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, TrafficFlowLWREquations1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::TrafficFlowLWREquations1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/traffic_flow_lwr_1d.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.source_terms_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.source_terms_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.source_terms_eoc_test_euler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L239-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.source_terms_eoc_test_euler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is to be used for testing pure Euler simulations with analytic self-gravity. If you intend to do coupled Euler-gravity simulations, you need to use <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> instead.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L228-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.source_terms_harmonic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations1D)</code></pre><p>Source term that only includes the forcing from the hyperbolic diffusion system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_1d.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations2D}" href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations2D}"><code>Trixi.source_terms_harmonic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations2D)</code></pre><p>Source term that only includes the forcing from the hyperbolic diffusion system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_2d.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations3D}" href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations3D}"><code>Trixi.source_terms_harmonic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations3D)</code></pre><p>Source term that only includes the forcing from the hyperbolic diffusion system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_3d.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.source_terms_poisson_nonperiodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_poisson_nonperiodic(u, x, t,
                                 equations::HyperbolicDiffusionEquations1D)</code></pre><p>Source terms that include the forcing function <code>f(x)</code> and right hand side for the hyperbolic diffusion system that is used with <a href="#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>initial_condition_poisson_nonperiodic</code></a> and <a href="#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>boundary_condition_poisson_nonperiodic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/hyperbolic_diffusion_1d.jl#L67-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_coirier_vanleer-Tuple{Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.splitting_coirier_vanleer-Tuple{Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.splitting_coirier_vanleer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_coirier_vanleer(u, orientation::Integer,
                          equations::CompressibleEulerEquations1D)
splitting_coirier_vanleer(u, which::Union{Val{:minus}, Val{:plus}}
                          orientation::Integer,
                          equations::CompressibleEulerEquations1D)</code></pre><p>Splitting of the compressible Euler flux from Coirier and van Leer. The splitting has correction terms in the pressure splitting as well as the mass and energy flux components. The motivation for these corrections are to handle flows at the low Mach number limit.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>William Coirier and Bram van Leer (1991) Numerical flux formulas for the Euler and Navier-Stokes equations. II - Progress in flux-vector splitting <a href="https://doi.org/10.2514/6.1991-1566">DOI: 10.2514/6.1991-1566</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L599-L625">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_drikakis_tsangaris-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.splitting_drikakis_tsangaris-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.splitting_drikakis_tsangaris</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_drikakis_tsangaris(u, orientation_or_normal_direction,
                             equations::CompressibleEulerEquations2D)
splitting_drikakis_tsangaris(u, which::Union{Val{:minus}, Val{:plus}}
                             orientation_or_normal_direction,
                             equations::CompressibleEulerEquations2D)</code></pre><p>Improved variant of the Steger-Warming flux vector splitting <a href="#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations1D}"><code>splitting_steger_warming</code></a> for generalized coordinates. This splitting also reformulates the energy flux as in Hänel et al. to obtain conservation of the total temperature for inviscid flows.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>D. Drikakis and S. Tsangaris (1993) On the solution of the compressible Navier-Stokes equations using improved flux vector splitting methods <a href="https://doi.org/10.1016/0307-904X(93)90054-K">DOI: 10.1016/0307-904X(93)90054-K</a></li><li>D. Hänel, R. Schwane and G. Seider (1987) On the accuracy of upwind schemes for the solution of the Navier-Stokes equations <a href="https://doi.org/10.2514/6.1987-1105">DOI: 10.2514/6.1987-1105</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L846-L876">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_lax_friedrichs-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.splitting_lax_friedrichs-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.splitting_lax_friedrichs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_lax_friedrichs(u, orientation_or_normal_direction,
                         equations::CompressibleEulerEquations2D)
splitting_lax_friedrichs(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation_or_normal_direction,
                         equations::CompressibleEulerEquations2D)</code></pre><p>Naive local Lax-Friedrichs style flux splitting of the form <code>f⁺ = 0.5 (f + λ u)</code> and <code>f⁻ = 0.5 (f - λ u)</code> similar to a flux splitting one would apply, e.g., to Burgers&#39; equation.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L1259-L1277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_lax_friedrichs-Tuple{Any, Integer, InviscidBurgersEquation1D}" href="#Trixi.splitting_lax_friedrichs-Tuple{Any, Integer, InviscidBurgersEquation1D}"><code>Trixi.splitting_lax_friedrichs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_lax_friedrichs(u, orientation::Integer,
                         equations::InviscidBurgersEquation1D)
splitting_lax_friedrichs(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation::Integer,
                         equations::InviscidBurgersEquation1D)</code></pre><p>Naive local Lax-Friedrichs style flux splitting of the form <code>f⁺ = 0.5 (f + λ u)</code> and <code>f⁻ = 0.5 (f - λ u)</code> where <code>λ = abs(u)</code>.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/inviscid_burgers_1d.jl#L127-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_lax_friedrichs-Tuple{Any, Integer, LinearScalarAdvectionEquation1D}" href="#Trixi.splitting_lax_friedrichs-Tuple{Any, Integer, LinearScalarAdvectionEquation1D}"><code>Trixi.splitting_lax_friedrichs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_lax_friedrichs(u, orientation::Integer,
                         equations::LinearScalarAdvectionEquation1D)
splitting_lax_friedrichs(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation::Integer,
                         equations::LinearScalarAdvectionEquation1D)</code></pre><p>Naive local Lax-Friedrichs style flux splitting of the form <code>f⁺ = 0.5 (f + λ u)</code> and <code>f⁻ = 0.5 (f - λ u)</code> where <code>λ</code> is the absolute value of the advection velocity.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/linear_scalar_advection_1d.jl#L175-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.splitting_steger_warming</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_steger_warming(u, orientation::Integer,
                         equations::CompressibleEulerEquations1D)
splitting_steger_warming(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation::Integer,
                         equations::CompressibleEulerEquations1D)</code></pre><p>Splitting of the compressible Euler flux of Steger and Warming.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>Joseph L. Steger and R. F. Warming (1979) Flux Vector Splitting of the Inviscid Gasdynamic Equations With Application to Finite Difference Methods <a href="https://ntrs.nasa.gov/api/citations/19790020779/downloads/19790020779.pdf">NASA Technical Memorandum</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L421-L444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.splitting_steger_warming</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_steger_warming(u, orientation::Integer,
                         equations::CompressibleEulerEquations2D)
splitting_steger_warming(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation::Integer,
                         equations::CompressibleEulerEquations2D)</code></pre><p>Splitting of the compressible Euler flux of Steger and Warming. For curvilinear coordinates use the improved Steger-Warming-type splitting <a href="#Trixi.splitting_drikakis_tsangaris-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>splitting_drikakis_tsangaris</code></a>.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>Joseph L. Steger and R. F. Warming (1979) Flux Vector Splitting of the Inviscid Gasdynamic Equations With Application to Finite Difference Methods <a href="https://ntrs.nasa.gov/api/citations/19790020779/downloads/19790020779.pdf">NASA Technical Memorandum</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L717-L742">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.splitting_steger_warming</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_steger_warming(u, orientation::Integer,
                         equations::CompressibleEulerEquations3D)
splitting_steger_warming(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation::Integer,
                         equations::CompressibleEulerEquations3D)</code></pre><p>Splitting of the compressible Euler flux of Steger and Warming.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>Joseph L. Steger and R. F. Warming (1979) Flux Vector Splitting of the Inviscid Gasdynamic Equations With Application to Finite Difference Methods <a href="https://ntrs.nasa.gov/api/citations/19790020779/downloads/19790020779.pdf">NASA Technical Memorandum</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_3d.jl#L799-L822">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_vanleer_haenel-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.splitting_vanleer_haenel-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.splitting_vanleer_haenel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_vanleer_haenel(u, orientation_or_normal_direction,
                         equations::CompressibleEulerEquations2D)
splitting_vanleer_haenel(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation_or_normal_direction,
                         equations::CompressibleEulerEquations2D)</code></pre><p>Splitting of the compressible Euler flux from van Leer. This splitting further contains a reformulation due to Hänel et al. where the energy flux uses the enthalpy. The pressure splitting is independent from the splitting of the convective terms. As such there are many pressure splittings suggested across the literature. We implement the &#39;p4&#39; variant suggested by Liou and Steffen as it proved the most robust in practice. For details on the curvilinear variant of this flux vector splitting see Anderson et al.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>Bram van Leer (1982) Flux-Vector Splitting for the Euler Equation <a href="https://doi.org/10.1007/978-3-642-60543-7_5">DOI: 10.1007/978-3-642-60543-7_5</a></li><li>D. Hänel, R. Schwane and G. Seider (1987) On the accuracy of upwind schemes for the solution of the Navier-Stokes equations <a href="https://doi.org/10.2514/6.1987-1105">DOI: 10.2514/6.1987-1105</a></li><li>Meng-Sing Liou and Chris J. Steffen, Jr. (1991) High-Order Polynomial Expansions (HOPE) for Flux-Vector Splitting <a href="https://ntrs.nasa.gov/citations/19910016425">NASA Technical Memorandum</a></li><li>W. Kyle Anderson, James L. Thomas, and Bram van Leer (1986) Comparison of Finite Volume Flux Vector Splittings for the Euler Equations <a href="https://doi.org/10.2514/3.9465">DOI: 10.2514/3.9465</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_2d.jl#L1106-L1143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.splitting_vanleer_haenel-Tuple{Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.splitting_vanleer_haenel-Tuple{Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.splitting_vanleer_haenel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitting_vanleer_haenel(u, orientation::Integer,
                         equations::CompressibleEulerEquations1D)
splitting_vanleer_haenel(u, which::Union{Val{:minus}, Val{:plus}}
                         orientation::Integer,
                         equations::CompressibleEulerEquations1D)</code></pre><p>Splitting of the compressible Euler flux from van Leer. This splitting further contains a reformulation due to Hänel et al. where the energy flux uses the enthalpy. The pressure splitting is independent from the splitting of the convective terms. As such there are many pressure splittings suggested across the literature. We implement the &#39;p4&#39; variant suggested by Liou and Steffen as it proved the most robust in practice.</p><p>Returns a tuple of the fluxes &quot;minus&quot; (associated with waves going into the negative axis direction) and &quot;plus&quot; (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument <code>which</code> set to <code>Val{:minus}()</code> or <code>Val{:plus}()</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation (upwind SBP)</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p><strong>References</strong></p><ul><li>Bram van Leer (1982) Flux-Vector Splitting for the Euler Equation <a href="https://doi.org/10.1007/978-3-642-60543-7_5">DOI: 10.1007/978-3-642-60543-7_5</a></li><li>D. Hänel, R. Schwane and G. Seider (1987) On the accuracy of upwind schemes for the solution of the Navier-Stokes equations <a href="https://doi.org/10.2514/6.1987-1105">DOI: 10.2514/6.1987-1105</a></li><li>Meng-Sing Liou and Chris J. Steffen, Jr. (1991) High-Order Polynomial Expansions (HOPE) for Flux-Vector Splitting <a href="https://ntrs.nasa.gov/citations/19910016425">NASA Technical Memorandum</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_1d.jl#L504-L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.stolarsky_mean-Tuple{Any, Any, Any}" href="#Trixi.stolarsky_mean-Tuple{Any, Any, Any}"><code>Trixi.stolarsky_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stolarsky_mean(x, y, gamma)</code></pre><p>Compute an instance of a weighted Stolarsky mean of the form</p><pre><code class="nohighlight hljs">stolarsky_mean(x, y, gamma) = (gamma - 1)/gamma * (y^gamma - x^gamma) / (y^(gamma-1) - x^(gamma-1))</code></pre><p>where <code>gamma &gt; 1</code>.</p><p>Problem: The formula above has a removable singularity at <code>x == y</code>. Thus, some care must be taken to implement it correctly without problems or loss of accuracy when <code>x ≈ y</code>. Here, we use the approach proposed by Winters et al. (2020). Set f = (y - x) / (y + x) and g = gamma (for compact notation). Then, we use the expansions</p><pre><code class="nohighlight hljs">((1+f)^g - (1-f)^g) / g = 2*f + (g-1)(g-2)/3 * f^3 + (g-1)(g-2)(g-3)(g-4)/60 * f^5 + O(f^7)</code></pre><p>and</p><pre><code class="nohighlight hljs">((1+f)^(g-1) - (1-f)^(g-1)) / (g-1) = 2*f + (g-2)(g-3)/3 * f^3 + (g-2)(g-3)(g-4)(g-5)/60 * f^5 + O(f^7)</code></pre><p>Inserting the first few terms of these expansions and performing polynomial long division we find that</p><pre><code class="nohighlight hljs">stolarsky_mean(x, y, gamma) ≈ (y + x) / 2 * (1 + (g-2)/3 * f^2 - (g+1)(g-2)(g-3)/45 * f^4 + (g+1)(g-2)(g-3)(2g(g-2)-9)/945 * f^6)</code></pre><p>Since divisions are usually more expensive on modern hardware than multiplications (Agner Fog), we try to avoid computing two divisions. Thus, we use</p><pre><code class="nohighlight hljs">f^2 = (y - x)^2 / (x + y)^2
    = (x * (x - 2 * y) + y * y) / (x * (x + 2 * y) + y * y)</code></pre><p>Given ε = 1.0e-4, we use the following algorithm.</p><pre><code class="nohighlight hljs">if f^2 &lt; ε
  # use the expansion above
else
  # use the direct formula (gamma - 1)/gamma * (y^gamma - x^gamma) / (y^(gamma-1) - x^(gamma-1))
end</code></pre><p><strong>References</strong></p><ul><li>Andrew R. Winters, Christof Czernik, Moritz B. Schily &amp; Gregor J. Gassner (2020) Entropy stable numerical approximations for the isothermal and polytropic Euler equations <a href="https://doi.org/10.1007/s10543-019-00789-w">DOI: 10.1007/s10543-019-00789-w</a></li><li>Agner Fog. Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD, and VIA CPUs. <a href="https://www.agner.org/optimize/instruction_tables.pdf">https://www.agner.org/optimize/instruction_tables.pdf</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/math.jl#L312-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.totalgamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">totalgamma(u, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Function that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_1d.jl#L564-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.totalgamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">totalgamma(u, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Function that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/compressible_euler_multicomponent_2d.jl#L771-L776">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.uses_amr-Tuple{Any}" href="#Trixi.uses_amr-Tuple{Any}"><code>Trixi.uses_amr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uses_amr(callback)</code></pre><p>Checks whether the provided callback or <code>CallbackSet</code> is an <a href="#Trixi.AMRCallback"><code>AMRCallback</code></a> or contains one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/callbacks_step/amr.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.varnames" href="#Trixi.varnames"><code>Trixi.varnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">varnames(conversion_function, equations)</code></pre><p>Return the list of variable names when applying <code>conversion_function</code> to the conserved variables associated to <code>equations</code>. This function is mainly used internally to determine output to screen and for IO, e.g., for the <a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> and the <a href="#Trixi.SaveSolutionCallback"><code>SaveSolutionCallback</code></a>. Common choices of the <code>conversion_function</code> are <a href="#Trixi.cons2cons-Tuple{Any, Trixi.AbstractEquations}"><code>cons2cons</code></a> and <a href="#Trixi.cons2prim"><code>cons2prim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/equations.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations2D}" href="#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations2D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, orientation, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic velocity for the given <code>orientation</code> (1 -&gt; x, 2 -&gt; y) from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations3D}" href="#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations3D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, orientation, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic velocity for the given <code>orientation</code> (1 -&gt; x, 2 -&gt; y, 3 -&gt; z) from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations2D}" href="#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations2D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic velocity vector from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_2d.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations3D}" href="#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations3D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic velocity vector from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/equations/lattice_boltzmann_3d.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.@autoinfiltrate" href="#Trixi.@autoinfiltrate"><code>Trixi.@autoinfiltrate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@autoinfiltrate
@autoinfiltrate condition::Bool</code></pre><p>Invoke the <code>@infiltrate</code> macro of the package Infiltrator.jl to create a breakpoint for ad-hoc interactive debugging in the REPL. If the optional argument <code>condition</code> is given, the breakpoint is only enabled if <code>condition</code> evaluates to <code>true</code>.</p><p>As opposed to using <code>Infiltrator.@infiltrate</code> directly, this macro does not require Infiltrator.jl to be added as a dependency to Trixi.jl. As a bonus, the macro will also attempt to load the Infiltrator module if it has not yet been loaded manually.</p><p>Note: For this macro to work, the Infiltrator.jl package needs to be installed in your current Julia environment stack.</p><p>See also: <a href="https://github.com/JuliaDebug/Infiltrator.jl">Infiltrator.jl</a></p><div class="admonition is-warning"><header class="admonition-header">Internal use only</header><div class="admonition-body"><p>Please note that this macro is intended for internal use only. It is <em>not</em> part of the public API of Trixi.jl, and it thus can altered (or be removed) at any time without it being considered a breaking change.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L279-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Trixi.@threaded-Tuple{Any}" href="#Trixi.@threaded-Tuple{Any}"><code>Trixi.@threaded</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@threaded for ... end</code></pre><p>Semantically the same as <code>Threads.@threads</code> when iterating over a <code>AbstractUnitRange</code> but without guarantee that the underlying implementation uses <code>Threads.@threads</code> or works for more general <code>for</code> loops. In particular, there may be an additional check whether only one thread is used to reduce the overhead of serial execution or the underlying threading capabilities might be provided by other packages such as <a href="https://github.com/JuliaSIMD/Polyester.jl">Polyester.jl</a>.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>This macro does not necessarily work for general <code>for</code> loops. For example, it does not necessarily support general iterables such as <code>eachline(filename)</code>.</p></div></div><p>Some discussion can be found at <a href="https://discourse.julialang.org/t/overhead-of-threads-threads/53964">https://discourse.julialang.org/t/overhead-of-threads-threads/53964</a> and <a href="https://discourse.julialang.org/t/threads-threads-with-one-thread-how-to-remove-the-overhead/58435">https://discourse.julialang.org/t/threads-threads-with-one-thread-how-to-remove-the-overhead/58435</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/cb4563c365a99b5f7e1f4b12a4ba53efef1fb7c4/src/auxiliary/auxiliary.jl#L202-L218">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../troubleshooting/">« Troubleshooting and FAQ</a><a class="docs-footer-nextpage" href="../reference-trixibase/">TrixiBase.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 10 May 2024 11:41">Friday 10 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
