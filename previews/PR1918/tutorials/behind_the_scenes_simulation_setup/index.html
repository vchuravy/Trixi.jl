<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2 Behind the scenes of a simulation setup · Trixi.jl</title><meta name="title" content="2 Behind the scenes of a simulation setup · Trixi.jl"/><meta property="og:title" content="2 Behind the scenes of a simulation setup · Trixi.jl"/><meta property="twitter:title" content="2 Behind the scenes of a simulation setup · Trixi.jl"/><meta name="description" content="Documentation for Trixi.jl."/><meta property="og:description" content="Documentation for Trixi.jl."/><meta property="twitter:description" content="Documentation for Trixi.jl."/><meta property="og:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/behind_the_scenes_simulation_setup/"/><meta property="twitter:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/behind_the_scenes_simulation_setup/"/><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/behind_the_scenes_simulation_setup/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Trixi.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><a class="tocitem" href="../../restart/">Restart simulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">1 First steps in Trixi.jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../first_steps/getting_started/">1.1 Getting started</a></li><li><a class="tocitem" href="../first_steps/create_first_setup/">1.2 Create your first setup</a></li><li><a class="tocitem" href="../first_steps/changing_trixi/">1.3 Changing Trixi.jl itself</a></li></ul></li><li class="is-active"><a class="tocitem" href>2 Behind the scenes of a simulation setup</a><ul class="internal"><li><a class="tocitem" href="#Basic-setup"><span>Basic setup</span></a></li><li><a class="tocitem" href="#Overview-of-the-[SemidiscretizationHyperbolic](@ref)-type"><span>Overview of the <code>SemidiscretizationHyperbolic</code> type</span></a></li><li><a class="tocitem" href="#Overview-of-the-[semidiscretize](@ref)-function"><span>Overview of the <code>semidiscretize</code> function</span></a></li><li><a class="tocitem" href="#Functions-solve-and-rhs!"><span>Functions <code>solve</code> and <code>rhs!</code></span></a></li></ul></li><li><a class="tocitem" href="../scalar_linear_advection_1d/">3 Introduction to DG methods</a></li><li><a class="tocitem" href="../DGSEM_FluxDiff/">4 DGSEM with flux differencing</a></li><li><a class="tocitem" href="../shock_capturing/">5 Shock capturing with flux differencing and stage limiter</a></li><li><a class="tocitem" href="../subcell_shock_capturing/">6 Subcell limiting with the IDP Limiter</a></li><li><a class="tocitem" href="../non_periodic_boundaries/">7 Non-periodic boundaries</a></li><li><a class="tocitem" href="../DGMulti_1/">8 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../DGMulti_2/">9 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../upwind_fdsbp/">10 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="../adding_new_scalar_equations/">11 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="../adding_nonconservative_equation/">12 Adding a non-conservative equation</a></li><li><a class="tocitem" href="../parabolic_terms/">13 Parabolic terms</a></li><li><a class="tocitem" href="../adding_new_parabolic_terms/">14 Adding new parabolic terms</a></li><li><a class="tocitem" href="../adaptive_mesh_refinement/">15 Adaptive mesh refinement</a></li><li><a class="tocitem" href="../structured_mesh_mapping/">16 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="../hohqmesh_tutorial/">17 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="../p4est_from_gmsh/">18 P4est mesh from gmsh</a></li><li><a class="tocitem" href="../time_stepping/">19 Explicit time stepping</a></li><li><a class="tocitem" href="../differentiable_programming/">20 Differentiable programming</a></li><li><a class="tocitem" href="../custom_semidiscretization/">21 Custom semidiscretizations</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../meshes/tree_mesh/">Tree mesh</a></li><li><a class="tocitem" href="../../meshes/structured_mesh/">Structured mesh</a></li><li><a class="tocitem" href="../../meshes/unstructured_quad_mesh/">Unstructured mesh</a></li><li><a class="tocitem" href="../../meshes/p4est_mesh/">P4est-based mesh</a></li><li><a class="tocitem" href="../../meshes/dgmulti_mesh/">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="../../time_integration/">Time integration</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../multi-physics_coupling/">Coupling</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><a class="tocitem" href="../../development/">Development</a></li><li><a class="tocitem" href="../../github-git/">GitHub &amp; Git</a></li><li><a class="tocitem" href="../../styleguide/">Style guide</a></li><li><a class="tocitem" href="../../testing/">Testing</a></li><li><a class="tocitem" href="../../performance/">Performance</a></li><li><a class="tocitem" href="../../parallelization/">Parallelization</a></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference-trixi/">Trixi.jl</a></li><li><a class="tocitem" href="../../reference-trixibase/">TrixiBase.jl</a></li><li><a class="tocitem" href="../../reference-trixi2vtk/">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>2 Behind the scenes of a simulation setup</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>2 Behind the scenes of a simulation setup</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl/blob/main/docs/literate/src/files/behind_the_scenes_simulation_setup.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="behind_the_scenes_simulation_setup"><a class="docs-heading-anchor" href="#behind_the_scenes_simulation_setup">2: Behind the scenes of a simulation setup</a><a id="behind_the_scenes_simulation_setup-1"></a><a class="docs-heading-anchor-permalink" href="#behind_the_scenes_simulation_setup" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/trixi-framework/Trixi.jl/tutorial_notebooks?filepath=tutorials/notebooks/behind_the_scenes_simulation_setup.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/trixi-framework/Trixi.jl/blob/tutorial_notebooks/tutorials/notebooks/behind_the_scenes_simulation_setup.ipynb"><img src="https://img.shields.io/badge/render-nbviewer-f37726" alt/></a> <a href="https://raw.githubusercontent.com/trixi-framework/Trixi.jl/tutorial_notebooks/tutorials/notebooks/behind_the_scenes_simulation_setup.ipynb"><img src="https://img.shields.io/badge/raw-notebook-4cc61e" alt/></a></p><p>This tutorial will guide you through a simple Trixi.jl setup (&quot;elixir&quot;), giving an overview of what happens in the background during the initialization of a simulation. While the setup described herein does not cover all details, it involves relatively stable parts of Trixi.jl that are unlikely to undergo significant changes in the near future. The goal is to clarify some of the more fundamental, <em>technical</em> concepts that are applicable to a variety of (also more complex) configurations.</p><p>Trixi.jl follows the <a href="http://www.scholarpedia.org/article/Method_of_lines">method of lines</a> concept for solving partial differential equations (PDEs). Firstly, the PDEs are reduced to a (potentially huge) system of ordinary differential equations (ODEs) by discretizing the spatial derivatives. Subsequently, these generated ODEs may be solved with methods available in OrdinaryDiffEq.jl or those specifically implemented in Trixi.jl. The following steps elucidate the process of transitioning from PDEs to ODEs within the framework of Trixi.jl.</p><h2 id="Basic-setup"><a class="docs-heading-anchor" href="#Basic-setup">Basic setup</a><a id="Basic-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-setup" title="Permalink"></a></h2><p>Import essential libraries and specify an equation.</p><pre><code class="language-julia hljs">using Trixi, OrdinaryDiffEq
equations = LinearScalarAdvectionEquation2D((-0.2, 0.7))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ LinearScalarAdvectionEquation2D                                                                  │
│ ═══════════════════════════════                                                                  │
│ #variables: ………………………………………………… 1                                                                │
│ │ variable 1: …………………………………………… scalar                                                           │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Generate a spatial discretization using a <a href="../../reference-trixi/#Trixi.TreeMesh"><code>TreeMesh</code></a> with a pre-coarsened set of cells.</p><pre><code class="language-julia hljs">coordinates_min = (-2.0, -2.0)
coordinates_max = (2.0, 2.0)

coarsening_patches = ((type = &quot;box&quot;, coordinates_min = [0.0, -2.0],
                       coordinates_max = [2.0, 0.0]),)

mesh = TreeMesh(coordinates_min, coordinates_max, initial_refinement_level = 2,
                n_cells_max = 30_000,
                coarsening_patches = coarsening_patches)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ TreeMesh{2, Trixi.SerialTree{2}}                                                                 │
│ ════════════════════════════════                                                                 │
│ center: …………………………………………………………… [0.0, 0.0]                                                       │
│ length: …………………………………………………………… 4.0                                                              │
│ periodicity: ……………………………………………… (true, true)                                                     │
│ current #cells: ……………………………………… 17                                                               │
│ #leaf-cells: ……………………………………………… 13                                                               │
│ maximum #cells: ……………………………………… 30000                                                            │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>The created <code>TreeMesh</code> looks like the following:</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/d5ef76ee-8246-4730-a692-b472c06063a3" alt="TreeMesh_example"/></p><p>Instantiate a <a href="../../reference-trixi/#Trixi.DGSEM"><code>DGSEM</code></a> solver with a user-specified polynomial degree. The solver will define <code>polydeg + 1</code> <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss%E2%80%93Lobatto_rules">Gauss-Lobatto nodes</a> and their associated weights within the reference interval <span>$[-1, 1]$</span> in each spatial direction. These nodes will be subsequently used to approximate solutions on each leaf cell of the <code>TreeMesh</code>.</p><pre><code class="language-julia hljs">solver = DGSEM(polydeg = 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ DG{Float64}                                                                                      │
│ ═══════════                                                                                      │
│ basis: ……………………………………………………………… LobattoLegendreBasis{Float64}(polydeg=3)                         │
│ mortar: …………………………………………………………… LobattoLegendreMortarL2{Float64}(polydeg=3)                      │
│ surface integral: ………………………………… SurfaceIntegralWeakForm                                          │
│ │ surface flux: ……………………………………… flux_central                                                     │
│ volume integral: …………………………………… VolumeIntegralWeakForm                                           │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Gauss-Lobatto nodes with <code>polydeg = 3</code>:</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/1d894611-801e-4f75-bff0-d77ca1c672e5" alt="Gauss-Lobatto_nodes_example"/></p><h2 id="Overview-of-the-[SemidiscretizationHyperbolic](@ref)-type"><a class="docs-heading-anchor" href="#Overview-of-the-[SemidiscretizationHyperbolic](@ref)-type">Overview of the <a href="../../reference-trixi/#Trixi.SemidiscretizationHyperbolic"><code>SemidiscretizationHyperbolic</code></a> type</a><a id="Overview-of-the-[SemidiscretizationHyperbolic](@ref)-type-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-the-[SemidiscretizationHyperbolic](@ref)-type" title="Permalink"></a></h2><p>At this stage, all necessary components for configuring the spatial discretization are in place. The remaining task is to combine these components into a single structure that will be used throughout the entire simulation process. This is where <a href="../../reference-trixi/#Trixi.SemidiscretizationHyperbolic"><code>SemidiscretizationHyperbolic</code></a> comes into play.</p><pre><code class="language-julia hljs">semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test,
                                    solver)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ SemidiscretizationHyperbolic                                                                     │
│ ════════════════════════════                                                                     │
│ #spatial dimensions: ………………………… 2                                                                │
│ mesh: ………………………………………………………………… TreeMesh{2, Trixi.SerialTree{2}} with length 17                  │
│ equations: …………………………………………………… LinearScalarAdvectionEquation2D                                  │
│ initial condition: ……………………………… initial_condition_convergence_test                               │
│ boundary conditions: ………………………… Trixi.BoundaryConditionPeriodic                                  │
│ source terms: …………………………………………… nothing                                                          │
│ solver: …………………………………………………………… DG                                                               │
│ total #DOFs per field: …………………… 208                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>The constructor for the <code>SemidiscretizationHyperbolic</code> object calls numerous sub-functions to perform the necessary initialization steps. A brief description of the key sub-functions is provided below.</p><ul><li><p><code>init_elements(leaf_cell_ids, mesh, equations, dg.basis, RealT, uEltype)</code></p><p>The fundamental elements for approximating the solution are the leaf cells. The solution is constructed as a polynomial of the degree specified in the <code>DGSEM</code> solver in each spatial direction on each leaf cell. This polynomial approximation is evaluated at the Gauss-Lobatto nodes mentioned earlier. The <code>init_elements</code> function extracts these leaf cells from the <code>TreeMesh</code>, assigns them the label &quot;elements&quot;, records their coordinates, and maps the Gauss-Lobatto nodes from the 1D interval <span>$[-1, 1]$</span> onto each coordinate axis of every element.</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/9f486670-b579-4e42-8697-439540c8bbb4" alt="elements_example"/></p><p>The visualization of elements with nodes shown here includes spaces between elements, which do not exist in reality. This spacing is included only for illustrative purposes to underscore the separation of elements and the independent projection of nodes onto each element.</p></li><li><p><code>init_interfaces(leaf_cell_ids, mesh, elements)</code></p><p>At this point, the elements with nodes have been defined; however, they lack the necessary communication functionality. This is crucial because the local solution polynomials on the elements are not independent of each other. Furthermore, nodes on the boundary of adjacent elements share the same spatial location, which requires a method to combine this into a meaningful solution. Here <a href="https://en.wikipedia.org/wiki/Riemann_solver#Approximate_solvers">Riemann solvers</a> come into play which can handle the principal ambiguity of a multi-valued solution at the same spatial location.</p><p>As demonstrated earlier, the elements can have varying sizes. Let us initially consider neighbors with equal size. For these elements, the <code>init_interfaces</code> function generates interfaces that store information about adjacent elements, their relative positions, and allocate containers for sharing solution data between neighbors during the solution process.</p><p>In our visualization, these interfaces would conceptually resemble tubes connecting the corresponding elements.</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/bc3b6b02-afbc-4371-aaf7-c7bdc5a6c540" alt="interfaces_example"/></p></li><li><p><code>init_mortars(leaf_cell_ids, mesh, elements, dg.mortar)</code></p><p>Returning to the consideration of different sizes among adjacent elements, within the <code>TreeMesh</code>, adjacent leaf cells can vary in side length by a maximum factor of two. This implies that a large element has one neighbor of equal size with a connection through an interface, or two neighbors at half the size, requiring a connection through so called &quot;mortars&quot;. In 3D, a large element would have four small neighbor elements.</p><p>Mortars store information about the connected elements, their relative positions, and allocate containers for storing the solutions along the boundaries between these elements.</p><p>Due to the differing sizes of adjacent elements, it is not feasible to directly map boundary nodes of adjacent elements. Therefore, the concept of mortars employs a mass-conserving interpolation function to map boundary nodes from a larger element to a smaller one.</p><p>In our visualization, mortars are represented as branched tubes.</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/43a95a60-3a31-4b1f-8724-14049e7a0481" alt="mortars_example"/></p></li><li><p><code>init_boundaries(leaf_cell_ids, mesh, elements)</code></p><p>In order to apply boundary conditions, it is necessary to identify the locations of the boundaries. Therefore, we initialize a &quot;boundaries&quot; object, which records the elements that contain boundaries, specifies which side of an element is a boundary, stores the coordinates of boundary nodes, and allocates containers for managing solutions at these boundaries.</p><p>In our visualization, boundaries and their corresponding nodes are highlighted with green, semi-transparent lines.</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/21996b20-4a22-4dfb-b16a-e2c22c2f29fe" alt="boundaries_example"/></p></li></ul><p>All the structures mentioned earlier are collected as a cache of type <code>NamedTuple</code>. Subsequently, an object of type <code>SemidiscretizationHyperbolic</code> is initialized using this cache, initial and boundary conditions, equations, mesh and solver.</p><p>In conclusion, the primary purpose of a <code>SemidiscretizationHyperbolic</code> is to collect equations, the geometric representation of the domain, and approximation instructions, creating specialized structures to interconnect these components in a manner that enables their utilization for the numerical solution of partial differential equations (PDEs).</p><p>As evident from the earlier description of <code>SemidiscretizationHyperbolic</code>, it comprises numerous functions called subsequently. Without delving into details, the structure of the primary calls are illustrated as follows:</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/8bf59422-0537-4d7a-9f13-d9b2253c19d7" alt="SemidiscretizationHyperbolic_structure"/></p><h2 id="Overview-of-the-[semidiscretize](@ref)-function"><a class="docs-heading-anchor" href="#Overview-of-the-[semidiscretize](@ref)-function">Overview of the <a href="../../reference-trixi/#SummationByPartsOperators.semidiscretize-Tuple{SemidiscretizationHyperbolicParabolic, Any}"><code>semidiscretize</code></a> function</a><a id="Overview-of-the-[semidiscretize](@ref)-function-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-the-[semidiscretize](@ref)-function" title="Permalink"></a></h2><p>At this stage, we have defined the equations and configured the domain&#39;s discretization. The final step before solving is to select a suitable time span and apply the corresponding initial conditions, which are already stored in the initialized <code>SemidiscretizationHyperbolic</code> object.</p><p>The purpose of the <a href="../../reference-trixi/#SummationByPartsOperators.semidiscretize-Tuple{SemidiscretizationHyperbolicParabolic, Any}"><code>semidiscretize</code></a> function is to wrap the semidiscretization as an <code>ODEProblem</code> within the specified time interval. During this procedure the approximate solution  is created at the given initial time via the specified <code>initial_condition</code> function from the  <code>SemidiscretizationHyperbolic</code> object. This <code>ODEProblem</code> can be subsequently passed to the <code>solve</code> function from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package or to <a href="../../reference-trixi/#Trixi.solve"><code>Trixi.solve</code></a>.</p><pre><code class="language-julia hljs">ode = semidiscretize(semi, (0.0, 1.0));</code></pre><p>The <code>semidiscretize</code> function involves a deep tree of subsequent calls, with the primary ones explained below.</p><ul><li><p><code>allocate_coefficients(mesh, equations, solver, cache)</code></p><p>To apply initial conditions, a data structure (&quot;container&quot;) needs to be generated to store the initial values of the target variables for each node within each element.</p><p>Since only one-dimensional <code>Array</code>s are <code>resize!</code>able in Julia, we use <code>Vector</code>s as an internal storage for the target variables and <code>resize!</code> them whenever needed, e.g. to change the number of elements. Then, during the solving process the same memory is reused by <code>unsafe_wrap</code>ping multi-dimensional <code>Array</code>s around the internal storage.</p></li><li><p><code>wrap_array(u_ode, semi)</code></p><p>As previously noted, <code>u_ode</code> is constructed as a 1D vector to ensure compatibility with OrdinaryDiffEq.jl. However, for internal use within Trixi.jl, identifying which part of the vector relates to specific variables, elements, or nodes can be challenging.</p><p>This is why the <code>u_ode</code> vector is wrapped by the <code>wrap_array</code> function using <code>unsafe_wrap</code> to form a multidimensional array <code>u</code>. In this array, the first dimension corresponds to variables, followed by N dimensions corresponding to nodes for each of N space dimensions. The last dimension corresponds to the elements. Consequently, navigation within this multidimensional array becomes noticeably easier.</p><p>&quot;Wrapping&quot; in this context involves the creation of a reference to the same storage location but with an alternative structural representation. This approach enables the use of both instances <code>u</code> and <code>u_ode</code> as needed, so that changes are simultaneously reflected in both. This is possible because, from a storage perspective, they share the same stored data, while access to this data is provided in different ways.</p></li><li><p><code>compute_coefficients!(u, initial_conditions, t, mesh::DG, equations, solver, cache)</code></p><p>Now the variable <code>u</code>, intended to store solutions, has been allocated and wrapped, it is time to apply the initial conditions. The <code>compute_coefficients!</code> function calculates the initial conditions for each variable at every node within each element and properly stores them in the <code>u</code> array.</p></li></ul><p>At this stage, the <code>semidiscretize</code> function has all the necessary components to initialize and return an <code>ODEProblem</code> object, which will be used by the <code>solve</code> function to compute the solution.</p><p>In summary, the internal workings of <code>semidiscretize</code> with brief descriptions can be presented as follows.</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/491eddc4-aadb-4e29-8c76-a7c821d0674e" alt="semidiscretize_structure"/></p><h2 id="Functions-solve-and-rhs!"><a class="docs-heading-anchor" href="#Functions-solve-and-rhs!">Functions <code>solve</code> and <code>rhs!</code></a><a id="Functions-solve-and-rhs!-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-solve-and-rhs!" title="Permalink"></a></h2><p>Once the <code>ODEProblem</code> object is initialized, the <code>solve</code> function and one of the ODE solvers from the OrdinaryDiffEq.jl package can be utilized to compute an approximated solution using the instructions contained in the <code>ODEProblem</code> object.</p><pre><code class="language-julia hljs">sol = solve(ode, CarpenterKennedy2N54(williamson_condition = false), dt = 0.01,
            save_everystep = false);</code></pre><p>Since the <code>solve</code> function and the ODE solver have no knowledge of a particular spatial discretization, it is necessary to define a &quot;right-hand-side function&quot;, <code>rhs!</code>, within Trixi.jl.</p><p>Trixi.jl includes a set of <code>rhs!</code> functions designed to compute <code>du</code>, i.e., <span>$\frac{\partial u}{\partial t}$</span> according to the structure of the setup. These <code>rhs!</code> functions calculate interface, mortars, and boundary fluxes, in addition to surface and volume integrals, in order to construct the <code>du</code> vector. This <code>du</code> vector is then used by the time integration method to obtain the solution at the subsequent time step. The <code>rhs!</code> function is called by time integration methods in each iteration of the solve loop within OrdinaryDiffEq.jl, with arguments <code>du</code>, <code>u</code>, <code>semidiscretization</code>, and the current time.</p><p>Trixi.jl uses a two-levels approach for <code>rhs!</code> functions. The first level is limited to a single function for each <code>semidiscretization</code> type, and its role is to redirect data to the target <code>rhs!</code> for specific solver and mesh types. This target <code>rhs!</code> function is responsible for calculating <code>du</code>.</p><p>Path from the <code>solve</code> function call to the appropriate <code>rhs!</code> function call:</p><p><img src="https://github.com/trixi-framework/Trixi.jl/assets/119304909/dbea9a0e-25a4-4afa-855e-01f1ad619982" alt="rhs_structure"/></p><p>Computed solution:</p><pre><code class="language-julia hljs">using Plots
plot(sol)
pd = PlotData2D(sol)
plot!(getmesh(pd))</code></pre><img src="765a7f63.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../first_steps/changing_trixi/">« 1.3 Changing Trixi.jl itself</a><a class="docs-footer-nextpage" href="../scalar_linear_advection_1d/">3 Introduction to DG methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 25 July 2024 13:00">Thursday 25 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
