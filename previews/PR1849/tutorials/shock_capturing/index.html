<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>5 Shock capturing with flux differencing and stage limiter · Trixi.jl</title><meta name="title" content="5 Shock capturing with flux differencing and stage limiter · Trixi.jl"/><meta property="og:title" content="5 Shock capturing with flux differencing and stage limiter · Trixi.jl"/><meta property="twitter:title" content="5 Shock capturing with flux differencing and stage limiter · Trixi.jl"/><meta name="description" content="Documentation for Trixi.jl."/><meta property="og:description" content="Documentation for Trixi.jl."/><meta property="twitter:description" content="Documentation for Trixi.jl."/><meta property="og:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/shock_capturing/"/><meta property="twitter:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/shock_capturing/"/><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/shock_capturing/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Trixi.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><a class="tocitem" href="../../restart/">Restart simulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">1 First steps in Trixi.jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../first_steps/getting_started/">1.1 Getting started</a></li><li><a class="tocitem" href="../first_steps/create_first_setup/">1.2 Create first setup</a></li><li><a class="tocitem" href="../first_steps/changing_trixi/">1.3 Changing Trixi.jl itself</a></li></ul></li><li><a class="tocitem" href="../behind_the_scenes_simulation_setup/">2 Behind the scenes of a simulation setup</a></li><li><a class="tocitem" href="../scalar_linear_advection_1d/">3 Introduction to DG methods</a></li><li><a class="tocitem" href="../DGSEM_FluxDiff/">4 DGSEM with flux differencing</a></li><li class="is-active"><a class="tocitem" href>5 Shock capturing with flux differencing and stage limiter</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Shock-capturing-with-flux-differencing"><span>Shock capturing with flux differencing</span></a></li><li class="toplevel"><a class="tocitem" href="#Positivity-preserving-limiter"><span>Positivity preserving limiter</span></a></li><li class="toplevel"><a class="tocitem" href="#Simulation-with-shock-capturing-and-positivity-preserving"><span>Simulation with shock capturing and positivity preserving</span></a></li><li><a class="tocitem" href="#Package-versions"><span>Package versions</span></a></li></ul></li><li><a class="tocitem" href="../non_periodic_boundaries/">6 Non-periodic boundaries</a></li><li><a class="tocitem" href="../DGMulti_1/">7 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../DGMulti_2/">8 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../upwind_fdsbp/">9 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="../adding_new_scalar_equations/">10 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="../adding_nonconservative_equation/">11 Adding a non-conservative equation</a></li><li><a class="tocitem" href="../parabolic_terms/">12 Parabolic terms</a></li><li><a class="tocitem" href="../adding_new_parabolic_terms/">13 Adding new parabolic terms</a></li><li><a class="tocitem" href="../adaptive_mesh_refinement/">14 Adaptive mesh refinement</a></li><li><a class="tocitem" href="../structured_mesh_mapping/">15 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="../hohqmesh_tutorial/">16 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="../p4est_from_gmsh/">17 P4est mesh from gmsh</a></li><li><a class="tocitem" href="../time_stepping/">18 Explicit time stepping</a></li><li><a class="tocitem" href="../differentiable_programming/">19 Differentiable programming</a></li><li><a class="tocitem" href="../custom_semidiscretization/">20 Custom semidiscretizations</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../meshes/tree_mesh/">Tree mesh</a></li><li><a class="tocitem" href="../../meshes/structured_mesh/">Structured mesh</a></li><li><a class="tocitem" href="../../meshes/unstructured_quad_mesh/">Unstructured mesh</a></li><li><a class="tocitem" href="../../meshes/p4est_mesh/">P4est-based mesh</a></li><li><a class="tocitem" href="../../meshes/dgmulti_mesh/">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="../../time_integration/">Time integration</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../multi-physics_coupling/">Coupling</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><a class="tocitem" href="../../development/">Development</a></li><li><a class="tocitem" href="../../github-git/">GitHub &amp; Git</a></li><li><a class="tocitem" href="../../styleguide/">Style guide</a></li><li><a class="tocitem" href="../../testing/">Testing</a></li><li><a class="tocitem" href="../../performance/">Performance</a></li><li><a class="tocitem" href="../../parallelization/">Parallelization</a></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference-trixi/">Trixi.jl</a></li><li><a class="tocitem" href="../../reference-trixibase/">TrixiBase.jl</a></li><li><a class="tocitem" href="../../reference-trixi2vtk/">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>5 Shock capturing with flux differencing and stage limiter</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>5 Shock capturing with flux differencing and stage limiter</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl/blob/main/docs/literate/src/files/shock_capturing.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="shock_capturing"><a class="docs-heading-anchor" href="#shock_capturing">5: Shock capturing with flux differencing and stage limiter</a><a id="shock_capturing-1"></a><a class="docs-heading-anchor-permalink" href="#shock_capturing" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/trixi-framework/Trixi.jl/tutorial_notebooks?filepath=tutorials/notebooks/shock_capturing.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/trixi-framework/Trixi.jl/blob/tutorial_notebooks/tutorials/notebooks/shock_capturing.ipynb"><img src="https://img.shields.io/badge/render-nbviewer-f37726" alt/></a> <a href="https://raw.githubusercontent.com/trixi-framework/Trixi.jl/tutorial_notebooks/tutorials/notebooks/shock_capturing.ipynb"><img src="https://img.shields.io/badge/raw-notebook-4cc61e" alt/></a></p><p>This tutorial contains a short summary of the idea of shock capturing for DGSEM with flux differencing and its implementation in <a href="https://github.com/trixi-framework/Trixi.jl">Trixi.jl</a>. In the second part, an implementation of a positivity preserving limiter is added to the simulation.</p><h1 id="Shock-capturing-with-flux-differencing"><a class="docs-heading-anchor" href="#Shock-capturing-with-flux-differencing">Shock capturing with flux differencing</a><a id="Shock-capturing-with-flux-differencing-1"></a><a class="docs-heading-anchor-permalink" href="#Shock-capturing-with-flux-differencing" title="Permalink"></a></h1><p>The following rough explanation is on a very basic level. More information about an entropy stable shock-capturing strategy for DGSEM discretizations of advection dominated problems, such as the compressible Euler equations or the compressible Navier-Stokes equations, can be found in <a href="https://doi.org/10.1016/j.jcp.2020.109935">Hennemann et al. (2021)</a>. In <a href="https://doi.org/10.1016/j.jcp.2021.110580">Rueda-Ramírez et al. (2021)</a> you find the extension to the systems with non-conservative terms, such as the compressible magnetohydrodynamics (MHD) equations.</p><p>The strategy for a shock-capturing method presented by Hennemann et al. is based on a hybrid blending of a high-order DG method with a low-order variant. The low-order subcell finite volume (FV) method is created directly with the Legendre-Gauss-Lobatto (LGL) nodes already used for the high-order DGSEM. Then, the final method is a convex combination with regulating indicator <span>$\alpha$</span> of these two methods.</p><p>Since the surface integral is equal for both the DG and the subcell FV method, only the volume integral divides between the two methods.</p><p>This strategy for the volume integral is implemented in Trixi.jl under the name of <a href="../../reference-trixi/#Trixi.VolumeIntegralShockCapturingHG"><code>VolumeIntegralShockCapturingHG</code></a> with the three parameters of the indicator and the volume fluxes for the DG and the subcell FV method.</p><p>Note, that the DG method is based on the flux differencing formulation. Hence, you have to use a two-point flux, such as <a href="../../reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a>, <a href="../../reference-trixi/#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_shima_etal</code></a>, <a href="../../reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_chandrashekar</code></a> or <a href="../../reference-trixi/#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_kennedy_gruber</code></a>, for the DG volume flux. We would recommend to use the entropy conserving flux <code>flux_ranocha</code> by <a href="https://cuvillier.de/en/shop/publications/7743">Ranocha (2018)</a> for the compressible Euler equations.</p><pre><code class="language-julia hljs">volume_integral = VolumeIntegralShockCapturingHG(indicator_sc;
                                                 volume_flux_dg=volume_flux_dg,
                                                 volume_flux_fv=volume_flux_fv)</code></pre><p>We now focus on a choice of the shock capturing indicator <code>indicator_sc</code>. A possible indicator is <span>$\alpha_{HG}$</span> presented by Hennemann et al. (p.10), which depends on the current approximation with modal coefficients <span>$\{m_j\}_{j=0}^N$</span> of a given <code>variable</code>.</p><p>The indicator is calculated for every DG element by itself. First, we calculate a smooth <span>$\alpha$</span> by</p><p class="math-container">\[\alpha = \frac{1}{1+\exp(-\frac{-s}{\mathbb{T}}(\mathbb{E}-\mathbb{T}))}\]</p><p>with the total energy <span>$\mathbb{E}=\max\big(\frac{m_N^2}{\sum_{j=0}^N m_j^2}, \frac{m_{N-1}^2}{\sum_{j=0}^{N-1} m_j^2}\big)$</span>, threshold <span>$\mathbb{T}= 0.5 * 10^{-1.8*(N+1)^{1/4}}$</span> and parameter <span>$s=ln\big(\frac{1-0.0001}{0.0001}\big)\approx 9.21024$</span>.</p><p>For computational efficiency, <span>$\alpha_{min}$</span> is introduced and used for</p><p class="math-container">\[\tilde{\alpha} = \begin{cases}
0, &amp; \text{if } \alpha&lt;\alpha_{min}\\
\alpha, &amp; \text{if } \alpha_{min}\leq \alpha \leq 1- \alpha_{min}\\
1, &amp; \text{if } 1-\alpha_{min}&lt;\alpha.
\end{cases}\]</p><p>Moreover, the parameter <span>$\alpha_{max}$</span> sets a maximal value for <span>$\alpha$</span> by</p><p class="math-container">\[\alpha = \min\{\tilde{\alpha}, \alpha_{max}\}.\]</p><p>This allows to control the maximal dissipation.</p><p>To remove numerical artifact the final indicator is smoothed with all the neighboring elements&#39; indicators. This is activated with <code>alpha_smooth=true</code>.</p><p class="math-container">\[\alpha_{HG} = \max_E \{ \alpha, 0.5 * \alpha_E\},\]</p><p>where <span>$E$</span> are all elements sharing a face with the current element.</p><p>Furthermore, you can specify the variable used for the calculation. For instance you can choose <code>density</code>, <code>pressure</code> or both with <code>density_pressure</code> for the compressible Euler equations. For every equation there is also the option to use the first conservation variable with <code>first</code>.</p><p>This indicator is implemented in Trixi.jl and called <a href="../../reference-trixi/#Trixi.IndicatorHennemannGassner"><code>IndicatorHennemannGassner</code></a> with the parameters <code>equations</code>, <code>basis</code>, <code>alpha_max</code>, <code>alpha_min</code>, <code>alpha_smooth</code> and <code>variable</code>.</p><pre><code class="language-julia hljs">indicator_sc = IndicatorHennemannGassner(equations, basis,
                                         alpha_max=0.5,
                                         alpha_min=0.001,
                                         alpha_smooth=true,
                                         variable=variable)</code></pre><h1 id="Positivity-preserving-limiter"><a class="docs-heading-anchor" href="#Positivity-preserving-limiter">Positivity preserving limiter</a><a id="Positivity-preserving-limiter-1"></a><a class="docs-heading-anchor-permalink" href="#Positivity-preserving-limiter" title="Permalink"></a></h1><p>Some numerical solutions are physically meaningless, for instance negative values of pressure or density for the compressible Euler equations. This often results in crashed simulations since the calculation of numerical fluxes or stable time steps uses mathematical operations like roots or logarithms. One option to avoid these cases are a-posteriori positivity preserving limiters. Trixi.jl provides the fully-discrete positivity-preserving limiter of <a href="https://doi.org/10.1098/rspa.2011.0153">Zhang, Shu (2011)</a>.</p><p>It works the following way. For every passed (scalar) variable and for every DG element we calculate the minimal value <span>$value_{min}$</span>. If this value falls below the given threshold <span>$\varepsilon$</span>, the approximation is slightly adapted such that the minimal value of the relevant variable lies now above the threshold.</p><p class="math-container">\[\underline{u}^{new} = \theta * \underline{u} + (1-\theta) * u_{mean}\]</p><p>where <span>$\underline{u}$</span> are the collected pointwise evaluation coefficients in element <span>$e$</span> and <span>$u_{mean}$</span> the integral mean of the quantity in <span>$e$</span>. The new coefficients are a convex combination of these two values with factor</p><p class="math-container">\[\theta = \frac{value_{mean} - \varepsilon}{value_{mean} - value_{min}},\]</p><p>where <span>$value_{mean}$</span> is the relevant variable evaluated for the mean value <span>$u_{mean}$</span>.</p><p>The adapted approximation keeps the exact same mean value, but the relevant variable is now greater or equal the threshold <span>$\varepsilon$</span> at every node in every element.</p><p>We specify the variables the way we did before for the shock capturing variables. For the compressible Euler equations <code>density</code>, <code>pressure</code> or the combined variable <code>density_pressure</code> are a reasonable choice.</p><p>You can implement the limiter in Trixi.jl using <a href="../../reference-trixi/#Trixi.PositivityPreservingLimiterZhangShu"><code>PositivityPreservingLimiterZhangShu</code></a> with parameters <code>threshold</code> and <code>variables</code>.</p><pre><code class="language-julia hljs">stage_limiter! = PositivityPreservingLimiterZhangShu(thresholds=thresholds,
                                                     variables=variables)</code></pre><p>Then, the limiter is added to the time integration method in the <code>solve</code> function. For instance, like</p><pre><code class="language-julia hljs">CarpenterKennedy2N54(stage_limiter!, williamson_condition=false)</code></pre><p>or</p><pre><code class="language-julia hljs">SSPRK43(stage_limiter!).</code></pre><h1 id="Simulation-with-shock-capturing-and-positivity-preserving"><a class="docs-heading-anchor" href="#Simulation-with-shock-capturing-and-positivity-preserving">Simulation with shock capturing and positivity preserving</a><a id="Simulation-with-shock-capturing-and-positivity-preserving-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-with-shock-capturing-and-positivity-preserving" title="Permalink"></a></h1><p>Now, we can run a simulation using the described methods of shock capturing and positivity preserving limiters. We want to give an example for the 2D compressible Euler equations.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, Trixi

equations = CompressibleEulerEquations2D(1.4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ CompressibleEulerEquations2D                                                                     │
│ ════════════════════════════                                                                     │
│ #variables: ………………………………………………… 4                                                                │
│ │ variable 1: …………………………………………… rho                                                              │
│ │ variable 2: …………………………………………… rho_v1                                                           │
│ │ variable 3: …………………………………………… rho_v2                                                           │
│ │ variable 4: …………………………………………… rho_e                                                            │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>As our initial condition we use the Sedov blast wave setup.</p><pre><code class="language-julia hljs">function initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations2D)
  # Set up polar coordinates
  inicenter = SVector(0.0, 0.0)
  x_norm = x[1] - inicenter[1]
  y_norm = x[2] - inicenter[2]
  r = sqrt(x_norm^2 + y_norm^2)

  r0 = 0.21875 # = 3.5 * smallest dx (for domain length=4 and max-ref=6)
  # r0 = 0.5 # = more reasonable setup
  E = 1.0
  p0_inner = 3 * (equations.gamma - 1) * E / (3 * pi * r0^2)
  p0_outer = 1.0e-5 # = true Sedov setup
  # p0_outer = 1.0e-3 # = more reasonable setup

  # Calculate primitive variables
  rho = 1.0
  v1  = 0.0
  v2  = 0.0
  p   = r &gt; r0 ? p0_outer : p0_inner

  return prim2cons(SVector(rho, v1, v2, p), equations)
end
initial_condition = initial_condition_sedov_blast_wave</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">initial_condition_sedov_blast_wave (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">basis = LobattoLegendreBasis(3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LobattoLegendreBasis{Float64} with polynomials of degree 3</code></pre><p>We set the numerical fluxes and divide between the surface flux and the two volume fluxes for the DG and FV method. Here, we are using <a href="../../reference-trixi/#Trixi.flux_lax_friedrichs"><code>flux_lax_friedrichs</code></a> and <a href="../../reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a>.</p><pre><code class="language-julia hljs">surface_flux = flux_lax_friedrichs
volume_flux  = flux_ranocha</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">flux_ranocha (generic function with 9 methods)</code></pre><p>Now, we specify the shock capturing indicator <span>$\alpha$</span>.</p><p>We implement the described indicator of Hennemann, Gassner as explained above with parameters <code>equations</code>, <code>basis</code>, <code>alpha_max</code>, <code>alpha_min</code>, <code>alpha_smooth</code> and <code>variable</code>. Since density and pressure are the critical variables in this example, we use <code>density_pressure = density * pressure = rho * p</code> as indicator variable.</p><pre><code class="language-julia hljs">indicator_sc = IndicatorHennemannGassner(equations, basis,
                                         alpha_max=0.5,
                                         alpha_min=0.001,
                                         alpha_smooth=true,
                                         variable=density_pressure)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ IndicatorHennemannGassner                                                                        │
│ ═════════════════════════                                                                        │
│ indicator variable: …………………………… density_pressure                                                 │
│ max. α: …………………………………………………………… 0.5                                                              │
│ min. α: …………………………………………………………… 0.001                                                            │
│ smooth α: ……………………………………………………… yes                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Now, we can use the defined fluxes and the indicator to implement the volume integral using shock capturing.</p><pre><code class="language-julia hljs">volume_integral = VolumeIntegralShockCapturingHG(indicator_sc;
                                                 volume_flux_dg=volume_flux,
                                                 volume_flux_fv=surface_flux)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ VolumeIntegralShockCapturingHG                                                                   │
│ ══════════════════════════════                                                                   │
│ volume flux DG: ……………………………………… flux_ranocha                                                     │
│ volume flux FV: ……………………………………… FluxLaxFriedrichs(max_abs_speed_naive)                           │
│ indicator: …………………………………………………… IndicatorHennemannGassner                                        │
│ │ indicator variable: ……………………… density_pressure                                                 │
│ │ max. α: ……………………………………………………… 0.5                                                              │
│ │ min. α: ……………………………………………………… 0.001                                                            │
│ │ smooth α: ………………………………………………… yes                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We finalize the discretization by implementing Trixi.jl&#39;s <code>solver</code>, <code>mesh</code>, <code>semi</code> and <code>ode</code>, while <code>solver</code> now has the extra parameter <code>volume_integral</code>.</p><pre><code class="language-julia hljs">solver = DGSEM(basis, surface_flux, volume_integral)

coordinates_min = (-2.0, -2.0)
coordinates_max = ( 2.0,  2.0)
mesh = TreeMesh(coordinates_min, coordinates_max,
                initial_refinement_level=6,
                n_cells_max=10_000)

semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver)

tspan = (0.0, 1.0)
ode = semidiscretize(semi, tspan);</code></pre><p>We add some callbacks to get an solution analysis and use a CFL-based time step size calculation.</p><pre><code class="language-julia hljs">analysis_callback = AnalysisCallback(semi, interval=100)

stepsize_callback = StepsizeCallback(cfl=0.8)

callbacks = CallbackSet(analysis_callback, stepsize_callback);</code></pre><p>We now run the simulation using the positivity preserving limiter of Zhang and Shu for the variables density and pressure.</p><pre><code class="language-julia hljs">stage_limiter! = PositivityPreservingLimiterZhangShu(thresholds=(5.0e-6, 5.0e-6),
                                                     variables=(Trixi.density, pressure))

sol = solve(ode, CarpenterKennedy2N54(stage_limiter!, williamson_condition=false),
            dt=1.0, # solve needs some value here but it will be overwritten by the stepsize_callback
            save_everystep=false, callback=callbacks);

using Plots
plot(sol)</code></pre><img src="a38a4de2.svg" alt="Example block output"/><h2 id="Package-versions"><a class="docs-heading-anchor" href="#Package-versions">Package versions</a><a id="Package-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Package-versions" title="Permalink"></a></h2><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;Trixi&quot;, &quot;OrdinaryDiffEq&quot;, &quot;Plots&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.9.4
Commit 8e5136fa297 (2023-11-14 08:46 UTC)
Build Info:
  Official https://julialang.org/ release
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 4 × AMD EPYC 7763 64-Core Processor
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-14.0.6 (ORCJIT, znver3)
  Threads: 1 on 4 virtual cores
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
<span class="sgr32"><span class="sgr1">Status</span></span> `~/work/Trixi.jl/Trixi.jl/docs/Manifest.toml`
<span class="sgr33">⌅</span> <span class="sgr90">[1dea7af3] </span>OrdinaryDiffEq v6.66.0
<span class="sgr33">⌅</span> <span class="sgr90">[91a5bcdd] </span>Plots v1.39.0
  <span class="sgr90">[a7f1ee26] </span>Trixi v0.6.10-pre `~/work/Trixi.jl/Trixi.jl`
<span class="sgr36"><span class="sgr1">Info</span></span> Packages marked with <span class="sgr33">⌅</span> have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DGSEM_FluxDiff/">« 4 DGSEM with flux differencing</a><a class="docs-footer-nextpage" href="../non_periodic_boundaries/">6 Non-periodic boundaries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 22 February 2024 13:13">Thursday 22 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
