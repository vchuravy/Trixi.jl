<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4 DGSEM with flux differencing · Trixi.jl</title><meta name="title" content="4 DGSEM with flux differencing · Trixi.jl"/><meta property="og:title" content="4 DGSEM with flux differencing · Trixi.jl"/><meta property="twitter:title" content="4 DGSEM with flux differencing · Trixi.jl"/><meta name="description" content="Documentation for Trixi.jl."/><meta property="og:description" content="Documentation for Trixi.jl."/><meta property="twitter:description" content="Documentation for Trixi.jl."/><meta property="og:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/DGSEM_FluxDiff/"/><meta property="twitter:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/DGSEM_FluxDiff/"/><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/DGSEM_FluxDiff/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Trixi.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><a class="tocitem" href="../../restart/">Restart simulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">1 First steps in Trixi.jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../first_steps/getting_started/">1.1 Getting started</a></li><li><a class="tocitem" href="../first_steps/create_first_setup/">1.2 Create your first setup</a></li><li><a class="tocitem" href="../first_steps/changing_trixi/">1.3 Changing Trixi.jl itself</a></li></ul></li><li><a class="tocitem" href="../behind_the_scenes_simulation_setup/">2 Behind the scenes of a simulation setup</a></li><li><a class="tocitem" href="../scalar_linear_advection_1d/">3 Introduction to DG methods</a></li><li class="is-active"><a class="tocitem" href>4 DGSEM with flux differencing</a><ul class="internal"><li><a class="tocitem" href="#The-weak-form-of-the-DGSEM"><span>The weak form of the DGSEM</span></a></li><li><a class="tocitem" href="#DGSEM-with-flux-differencing"><span>DGSEM with flux differencing</span></a></li><li><a class="tocitem" href="#fluxDiffExample"><span>Implementation in Trixi.jl</span></a></li><li><a class="tocitem" href="#Package-versions"><span>Package versions</span></a></li></ul></li><li><a class="tocitem" href="../shock_capturing/">5 Shock capturing with flux differencing and stage limiter</a></li><li><a class="tocitem" href="../subcell_shock_capturing/">6 Subcell limiting with the IDP Limiter</a></li><li><a class="tocitem" href="../non_periodic_boundaries/">7 Non-periodic boundaries</a></li><li><a class="tocitem" href="../DGMulti_1/">8 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../DGMulti_2/">9 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../upwind_fdsbp/">10 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="../adding_new_scalar_equations/">11 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="../adding_nonconservative_equation/">12 Adding a non-conservative equation</a></li><li><a class="tocitem" href="../parabolic_terms/">13 Parabolic terms</a></li><li><a class="tocitem" href="../adding_new_parabolic_terms/">14 Adding new parabolic terms</a></li><li><a class="tocitem" href="../adaptive_mesh_refinement/">15 Adaptive mesh refinement</a></li><li><a class="tocitem" href="../structured_mesh_mapping/">16 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="../hohqmesh_tutorial/">17 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="../p4est_from_gmsh/">18 P4est mesh from gmsh</a></li><li><a class="tocitem" href="../time_stepping/">19 Explicit time stepping</a></li><li><a class="tocitem" href="../differentiable_programming/">20 Differentiable programming</a></li><li><a class="tocitem" href="../custom_semidiscretization/">21 Custom semidiscretizations</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../meshes/tree_mesh/">Tree mesh</a></li><li><a class="tocitem" href="../../meshes/structured_mesh/">Structured mesh</a></li><li><a class="tocitem" href="../../meshes/unstructured_quad_mesh/">Unstructured mesh</a></li><li><a class="tocitem" href="../../meshes/p4est_mesh/">P4est-based mesh</a></li><li><a class="tocitem" href="../../meshes/dgmulti_mesh/">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="../../time_integration/">Time integration</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../multi-physics_coupling/">Coupling</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><a class="tocitem" href="../../development/">Development</a></li><li><a class="tocitem" href="../../github-git/">GitHub &amp; Git</a></li><li><a class="tocitem" href="../../styleguide/">Style guide</a></li><li><a class="tocitem" href="../../testing/">Testing</a></li><li><a class="tocitem" href="../../performance/">Performance</a></li><li><a class="tocitem" href="../../parallelization/">Parallelization</a></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference-trixi/">Trixi.jl</a></li><li><a class="tocitem" href="../../reference-trixibase/">TrixiBase.jl</a></li><li><a class="tocitem" href="../../reference-trixi2vtk/">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>4 DGSEM with flux differencing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>4 DGSEM with flux differencing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl/blob/main/docs/literate/src/files/DGSEM_FluxDiff.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DGSEM_FluxDiff"><a class="docs-heading-anchor" href="#DGSEM_FluxDiff">4: DGSEM with flux differencing</a><a id="DGSEM_FluxDiff-1"></a><a class="docs-heading-anchor-permalink" href="#DGSEM_FluxDiff" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/trixi-framework/Trixi.jl/tutorial_notebooks?filepath=tutorials/notebooks/DGSEM_FluxDiff.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/trixi-framework/Trixi.jl/blob/tutorial_notebooks/tutorials/notebooks/DGSEM_FluxDiff.ipynb"><img src="https://img.shields.io/badge/render-nbviewer-f37726" alt/></a> <a href="https://raw.githubusercontent.com/trixi-framework/Trixi.jl/tutorial_notebooks/tutorials/notebooks/DGSEM_FluxDiff.ipynb"><img src="https://img.shields.io/badge/raw-notebook-4cc61e" alt/></a></p><p>This tutorial starts with a presentation of the weak formulation of the discontinuous Galerkin spectral element method (DGSEM) in order to fix the notation of the used operators. Then, the DGSEM formulation with flux differencing (split form DGSEM) and its implementation in <a href="https://github.com/trixi-framework/Trixi.jl">Trixi.jl</a> is shown.</p><p>We start with the one-dimensional conservation law</p><p class="math-container">\[u_t + f(u)_x = 0, \qquad t\in \mathbb{R}^+, x\in\Omega\]</p><p>with the physical flux <span>$f$</span>.</p><p>We split the domain <span>$\Omega$</span> into elements <span>$K$</span> with center <span>$x_K$</span> and size <span>$\Delta x$</span>. With the transformation mapping <span>$x(\xi)=x_K + \frac{\Delta x}{2} \xi$</span> we can transform the reference element <span>$[-1,1]$</span> to every physical element. So, the equation can be restricted to the reference element using the determinant of the Jacobian matrix of the transformation mapping <span>$J=\frac{\partial x}{\partial \xi}=\frac{\Delta x}{2}$</span>.</p><p class="math-container">\[J u_t + f(u)_{\xi} = 0, \qquad t\in \mathbb{R}^+, \xi\in [-1,1]\]</p><h2 id="The-weak-form-of-the-DGSEM"><a class="docs-heading-anchor" href="#The-weak-form-of-the-DGSEM">The weak form of the DGSEM</a><a id="The-weak-form-of-the-DGSEM-1"></a><a class="docs-heading-anchor-permalink" href="#The-weak-form-of-the-DGSEM" title="Permalink"></a></h2><p>We consider the so-called discontinuous Galerkin spectral element method (DGSEM) with collocation. It results from choosing a nodal DG ansatz using <span>$N+1$</span> Gauss-Lobatto nodes <span>$\xi_i$</span> in <span>$[-1,1]$</span> with matching interpolation weights <span>$w_i$</span>, which are used for numerical integration and interpolation with the Lagrange polynomial basis <span>$l_i$</span> of degree <span>$N$</span>. The Lagrange functions are created with those nodes and hence fulfil a Kronecker property at the GL nodes. The weak formulation of the DGSEM for one element is</p><p class="math-container">\[J \underline{\dot{u}}(t) = - M^{-1} B \underline{f}^* + M^{-1} D^T M \underline{f}\]</p><p>where <span>$\underline{u}=(u_0, u_1, \dots, u_N)^T\in\mathbb{R}^{N+1}$</span> is the collected pointwise evaluation of <span>$u$</span> at the discretization nodes and <span>$\dot{u} = \partial u / \partial t = u_t$</span> is the temporal derivative. The nodal values of the flux function <span>$f$</span> results with collocation in <span>$\underline{f}$</span>, since <span>$\underline{f}_j=f(\underline{u}_j)$</span>. Moreover, we got the numerical flux <span>$f^*=f^*(u^-, u^+)$</span>.</p><p>We will now have a short overview over the operators we used.</p><p>The <strong>derivative matrix</strong> <span>$D\in\mathbb{R}^{(N+1)\times (N+1)}$</span> mimics a spatial derivation on a discrete level with <span>$\underline{f}_x \approx D \underline{f}$</span>. It is defined by <span>$D_{ij} = l_j&#39;(\xi_i)$</span>.</p><p>The diagonal <strong>mass matrix</strong> <span>$M$</span> is defined by <span>$M_{ij}=\langle l_j, l_i\rangle_N$</span> with the numerical scalar product <span>$\langle \cdot, \cdot\rangle_N$</span> defined for functions <span>$f$</span> and <span>$g$</span> by</p><p class="math-container">\[\langle f, g\rangle_N := \int_{-1, N}^1 f(\xi) g(\xi) d\xi := \sum_{k=0}^N f(\xi_k) g(\xi_k) w_k.\]</p><p>The multiplication by <span>$M$</span> matches a discrete integration</p><p class="math-container">\[  \int_{-1}^1 f(\xi) \underline{l}(\xi) d\xi \approx M \underline{f},\]</p><p>The <strong>boundary matrix</strong> <span>$B=\text{diag}([-1, 0,..., 0, 1])$</span> represents an evaluation of a function at the boundaries <span>$\xi_0=-1$</span> and <span>$\xi_N=1$</span>.</p><p>For these operators the following property holds:</p><p class="math-container">\[  M D + (M D)^T = B.\]</p><p>This is called the summation-by-parts (SBP) property since it mimics integration by parts on a discrete level (<a href="https://doi.org/10.1137/120890144">Gassner (2013)</a>).</p><p>The explicit definitions of the operators and the construction of the 1D algorithm can be found for instance in the tutorial <a href="../scalar_linear_advection_1d/#scalar_linear_advection_1d">introduction to DG methods</a> or in more detail in <a href="https://link.springer.com/book/10.1007/978-90-481-2261-5">Kopriva (2009)</a>.</p><p>This property shows the equivalence between the weak form and the following strong formulation of the DGSEM.</p><p class="math-container">\[\begin{align*}
J \underline{\dot{u}}(t)
&amp;= - M^{-1} B \underline{f}^* + M^{-1} D^T M \underline{f}\\[5pt]
&amp;= - M^{-1} B \underline{f}^* + M^{-1} (B - MD) \underline{f}\\[5pt]
&amp;= - M^{-1} B (\underline{f}^* - \underline{f}) - D \underline{f}
\end{align*}\]</p><p>More information about the equivalence you can find in <a href="https://doi.org/10.1007/s10915-010-9372-3">Kopriva, Gassner (2010)</a>.</p><h2 id="DGSEM-with-flux-differencing"><a class="docs-heading-anchor" href="#DGSEM-with-flux-differencing">DGSEM with flux differencing</a><a id="DGSEM-with-flux-differencing-1"></a><a class="docs-heading-anchor-permalink" href="#DGSEM-with-flux-differencing" title="Permalink"></a></h2><p>When using the diagonal SBP property it is possible to rewrite the application of the derivative operator <span>$D$</span> in the calculation of the volume integral into a subcell based finite volume type differencing formulation (<a href="https://doi.org/10.1016/j.jcp.2013.06.014">Fisher, Carpenter (2013)</a>). Generalizing</p><p class="math-container">\[(D \underline{f})_i = \sum_j D_{i,j} \underline{f}_j
= 2\sum_j \frac{1}{2} D_{i,j} (\underline{f}_j + \underline{f}_i)
\eqqcolon 2\sum_j  D_{i,j} f_\text{central}(u_i, u_j),\]</p><p>we replace <span>$D \underline{f}$</span> in the strong form by <span>$2D \underline{f}_{vol}(u^-, u^+)$</span> with the consistent two-point volume flux <span>$f_{vol}$</span> and receive the DGSEM formulation with flux differencing (split form DGSEM) (<a href="https://doi.org/10.1016/j.jcp.2016.09.013">Gassner, Winters, Kopriva (2016)</a>).</p><p class="math-container">\[\begin{align*}
J \underline{\dot{u}}(t) &amp;= - M^{-1} B (\underline{f}^* - \underline{f}) - 2D \underline{f}_{vol}(u^-, u^+)\\[5pt]
&amp;= - M^{-1} B (\underline{f}^* - \underline{f}_{vol}(\underline{u}, \underline{u})) - 2D \underline{f}_{vol}(u^-, u^+)\\[5pt]
&amp;= - M^{-1} B \underline{f}_{surface}^* - (2D - M^{-1} B) \underline{f}_{vol}\\[5pt]
&amp;= - M^{-1} B \underline{f}_{surface}^* - D_{split} \underline{f}_{vol}
\end{align*}\]</p><p>This formulation is in a weak form type formulation and can be implemented by using the derivative split matrix <span>$D_{split}=(2D-M^{-1}B)$</span> and two different fluxes. We divide between the surface flux <span>$f=f_{surface}$</span> used for the numerical flux <span>$f_{surface}^*$</span> and the already mentioned volume flux <span>$f_{vol}$</span> especially for this formulation.</p><p>This formulation creates a more stable version of DGSEM, because it fulfils entropy stability. Moreover it allows the construction of entropy conserving discretizations without relying on exact integration. This is achieved when using a two-point entropy conserving flux function as volume flux in the volume flux differencing formulation. Then, the numerical surface flux can be used to control the dissipation of the discretization and to guarantee decreasing entropy, i.e. entropy stability.</p><h2 id="fluxDiffExample"><a class="docs-heading-anchor" href="#fluxDiffExample">Implementation in Trixi.jl</a><a id="fluxDiffExample-1"></a><a class="docs-heading-anchor-permalink" href="#fluxDiffExample" title="Permalink"></a></h2><p>Now, we have a look at the implementation of DGSEM with flux differencing with <a href="https://github.com/trixi-framework/Trixi.jl">Trixi.jl</a>.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, Trixi</code></pre><p>We implement a simulation for the compressible Euler equations in 2D</p><p class="math-container">\[\partial_t \begin{pmatrix} \rho \\ \rho v_1 \\ \rho v_2 \\ \rho e \end{pmatrix}
+ \partial_x \begin{pmatrix} \rho v_1 \\ \rho v_1^2 + p \\ \rho v_1 v_2 \\ (\rho e +p) v_1 \end{pmatrix}
+ \partial_y \begin{pmatrix} \rho v_2 \\ \rho v_1 v_2 \\ \rho v_2^2 + p \\ (\rho e +p) v_2 \end{pmatrix}
= \begin{pmatrix} 0 \\ 0 \\ 0 \\ 0 \end{pmatrix}\]</p><p>for an ideal gas with ratio of specific heats <span>$\gamma=1.4$</span>. Here, <span>$\rho$</span> is the density, <span>$v_1$</span>, <span>$v_2$</span> the velocities, <span>$e$</span> the specific total energy and</p><p class="math-container">\[p = (\gamma - 1) \left( \rho e - \frac{1}{2} \rho (v_1^2+v_2^2) \right)\]</p><p>the pressure.</p><pre><code class="language-julia hljs">gamma = 1.4
equations = CompressibleEulerEquations2D(gamma)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ CompressibleEulerEquations2D                                                                     │
│ ════════════════════════════                                                                     │
│ #variables: ………………………………………………… 4                                                                │
│ │ variable 1: …………………………………………… rho                                                              │
│ │ variable 2: …………………………………………… rho_v1                                                           │
│ │ variable 3: …………………………………………… rho_v2                                                           │
│ │ variable 4: …………………………………………… rho_e                                                            │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>As our initial condition we will use a weak blast wave from <a href="https://arxiv.org/abs/2008.12044">Hennemann, Gassner (2020)</a>. The primitive variables are defined by</p><p class="math-container">\[\begin{pmatrix} \rho \\ v_1 \\ v_2 \\ p \end{pmatrix}
= \begin{pmatrix} 1.0 \\ 0.0 \\ 0.0 \\ 1.0 \end{pmatrix} \text{if } \|x\|_2 &gt; 0.5,\;
\text{and } \begin{pmatrix} \rho \\ v_1 \\ v_2 \\ p \end{pmatrix}
= \begin{pmatrix} 1.1691 \\ 0.1882 * \cos(\phi) \\ 0.1882 * \sin(\phi) \\ 1.245 \end{pmatrix} \text{else}\]</p><p>with <span>$\phi = \tan^{-1}(\frac{x_2}{x_1})$</span>.</p><p>This initial condition is implemented in Trixi.jl under the name <a href="../../reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_weak_blast_wave</code></a>.</p><pre><code class="language-julia hljs">initial_condition = initial_condition_weak_blast_wave</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">initial_condition_weak_blast_wave (generic function with 13 methods)</code></pre><p>In Trixi.jl, flux differencing for the volume integral can be implemented with <a href="../../reference-trixi/#Trixi.VolumeIntegralFluxDifferencing"><code>VolumeIntegralFluxDifferencing</code></a> using symmetric two-point volume fluxes. First, we set up a simulation with the entropy conserving and kinetic energy preserving flux <a href="../../reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> by <a href="https://cuvillier.de/en/shop/publications/7743">Hendrik Ranocha (2018)</a> as surface and volume flux.</p><p>We will confirm the entropy conservation property numerically.</p><pre><code class="language-julia hljs">volume_flux = flux_ranocha # = f_vol
solver = DGSEM(polydeg=3, surface_flux=volume_flux,
               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ DG{Float64}                                                                                      │
│ ═══════════                                                                                      │
│ basis: ……………………………………………………………… LobattoLegendreBasis{Float64}(polydeg=3)                         │
│ mortar: …………………………………………………………… LobattoLegendreMortarL2{Float64}(polydeg=3)                      │
│ surface integral: ………………………………… SurfaceIntegralWeakForm                                          │
│ │ surface flux: ……………………………………… flux_ranocha                                                     │
│ volume integral: …………………………………… VolumeIntegralFluxDifferencing                                   │
│ │ volume flux: ………………………………………… flux_ranocha                                                     │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Now, we implement Trixi.jl&#39;s <code>mesh</code>, <code>semi</code> and <code>ode</code> in a simple framework. For more information please have a look at the documentation, the basic tutorial <a href="../scalar_linear_advection_1d/#scalar_linear_advection_1d">introduction to DG methods</a> or some basic elixirs.</p><pre><code class="language-julia hljs">coordinates_min = (-2.0, -2.0)
coordinates_max = ( 2.0,  2.0)
mesh = TreeMesh(coordinates_min, coordinates_max,
                initial_refinement_level=5,
                n_cells_max=10_000,
                periodicity=true)

semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,
                                    boundary_conditions=boundary_condition_periodic)

# ODE solvers
tspan = (0.0, 0.4)
ode = semidiscretize(semi, tspan);</code></pre><p>To analyse the entropy conservation of the approximation, we will use the analysis calllback implemented in Trixi. It provides some information about the approximation including the entropy change.</p><pre><code class="language-julia hljs">analysis_callback = AnalysisCallback(semi, interval=100);</code></pre><p>We now run the simulation using <code>flux_ranocha</code> for both surface and volume flux.</p><pre><code class="language-julia hljs">sol = solve(ode, RDPK3SpFSAL49(); abstol=1.0e-6, reltol=1.0e-6,
            ode_default_options()..., callback=analysis_callback);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
────────────────────────────────────────────────────────────────────────────────────────────────────
 Simulation running &#39;CompressibleEulerEquations2D&#39; with DGSEM(polydeg=3)
────────────────────────────────────────────────────────────────────────────────────────────────────
 #timesteps:                  0                run time:       4.81000000e-07 s
 Δt:             0.00000000e+00                └── GC time:    0.00000000e+00 s (0.000%)
 sim. time:      0.00000000e+00 (0.000%)       time/DOF/rhs!:         NaN s
                                               PID:                   Inf s
 #DOFs per field:         16384                alloc&#39;d memory:       1090.329 MiB
 #elements:                1024

 Variable:       rho              rho_v1           rho_v2           rho_e
 L2 error:       6.25621384e-03   5.88786362e-03   5.81457821e-03   2.34267393e-02
 Linf error:     1.06470791e-01   2.46283676e-01   1.37585923e-01   3.98685775e-01
 ∑∂S/∂U ⋅ Uₜ :  -6.42679631e-18
────────────────────────────────────────────────────────────────────────────────────────────────────


────────────────────────────────────────────────────────────────────────────────────────────────────
 Simulation running &#39;CompressibleEulerEquations2D&#39; with DGSEM(polydeg=3)
────────────────────────────────────────────────────────────────────────────────────────────────────
 #timesteps:                 61                run time:       8.46150148e-01 s
 Δt:             2.65388338e-06                └── GC time:    0.00000000e+00 s (0.000%)
 sim. time:      4.00000000e-01 (100.000%)     time/DOF/rhs!:  8.71971545e-08 s
                                               PID:            9.30707009e-08 s
 #DOFs per field:         16384                alloc&#39;d memory:       1096.416 MiB
 #elements:                1024

 Variable:       rho              rho_v1           rho_v2           rho_e
 L2 error:       6.17814257e-02   5.02178088e-02   5.02253900e-02   2.25981851e-01
 Linf error:     2.91149630e-01   3.21787795e-01   3.22040740e-01   1.04645370e+00
 ∑∂S/∂U ⋅ Uₜ :  -5.22953111e-18
────────────────────────────────────────────────────────────────────────────────────────────────────</code></pre><p>A look at the change in entropy <span>$\sum \partial S/\partial U \cdot U_t$</span> in the analysis callback confirms that the flux is entropy conserving since the change is about machine precision.</p><p>We can plot the approximated solution at the time <code>t=0.4</code>.</p><pre><code class="language-julia hljs">using Plots
plot(sol)</code></pre><img src="32473f32.svg" alt="Example block output"/><p>Now, we can use for instance the dissipative flux <a href="../../reference-trixi/#Trixi.flux_lax_friedrichs"><code>flux_lax_friedrichs</code></a> as surface flux to get an entropy stable method.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, Trixi

gamma = 1.4
equations = CompressibleEulerEquations2D(gamma)

initial_condition = initial_condition_weak_blast_wave

volume_flux = flux_ranocha # = f_vol
solver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs,
               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))

coordinates_min = (-2.0, -2.0)
coordinates_max = ( 2.0,  2.0)
mesh = TreeMesh(coordinates_min, coordinates_max,
                initial_refinement_level=5,
                n_cells_max=10_000,
                periodicity=true)

semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,
                                    boundary_conditions=boundary_condition_periodic)

# ODE solvers
tspan = (0.0, 0.4)
ode = semidiscretize(semi, tspan);

analysis_callback = AnalysisCallback(semi, interval=100);</code></pre><p>We now run the simulation using the volume flux <code>flux_ranocha</code> and surface flux <code>flux_lax_friedrichs</code>.</p><pre><code class="language-julia hljs">sol = solve(ode, RDPK3SpFSAL49(); abstol=1.0e-6, reltol=1.0e-6,
            ode_default_options()..., callback=analysis_callback);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
────────────────────────────────────────────────────────────────────────────────────────────────────
 Simulation running &#39;CompressibleEulerEquations2D&#39; with DGSEM(polydeg=3)
────────────────────────────────────────────────────────────────────────────────────────────────────
 #timesteps:                  0                run time:       6.11000000e-07 s
 Δt:             0.00000000e+00                └── GC time:    0.00000000e+00 s (0.000%)
 sim. time:      0.00000000e+00 (0.000%)       time/DOF/rhs!:         NaN s
                                               PID:                   Inf s
 #DOFs per field:         16384                alloc&#39;d memory:       1007.992 MiB
 #elements:                1024

 Variable:       rho              rho_v1           rho_v2           rho_e
 L2 error:       6.25621384e-03   5.88786362e-03   5.81457821e-03   2.34267393e-02
 Linf error:     1.06470791e-01   2.46283676e-01   1.37585923e-01   3.98685775e-01
 ∑∂S/∂U ⋅ Uₜ :  -6.33192862e-18
────────────────────────────────────────────────────────────────────────────────────────────────────


────────────────────────────────────────────────────────────────────────────────────────────────────
 Simulation running &#39;CompressibleEulerEquations2D&#39; with DGSEM(polydeg=3)
────────────────────────────────────────────────────────────────────────────────────────────────────
 #timesteps:                 37                run time:       4.85718918e-01 s
 Δt:             9.70561500e-03                └── GC time:    0.00000000e+00 s (0.000%)
 sim. time:      4.00000000e-01 (100.000%)     time/DOF/rhs!:  8.16076854e-08 s
                                               PID:            8.74125839e-08 s
 #DOFs per field:         16384                alloc&#39;d memory:       1014.078 MiB
 #elements:                1024

 Variable:       rho              rho_v1           rho_v2           rho_e
 L2 error:       6.13073745e-02   4.96545958e-02   4.96554717e-02   2.24251907e-01
 Linf error:     2.61815838e-01   2.48816692e-01   2.48316760e-01   9.30972696e-01
 ∑∂S/∂U ⋅ Uₜ :  -1.40306972e-04
────────────────────────────────────────────────────────────────────────────────────────────────────</code></pre><p>The change in entropy confirms the expected entropy stability.</p><pre><code class="language-julia hljs">using Plots
plot(sol)</code></pre><img src="294ab090.svg" alt="Example block output"/><p>Of course, you can use more than these two fluxes in Trixi. Here, we will give a short list of possible fluxes for the compressible Euler equations. For the volume flux Trixi.jl provides for example <a href="../../reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a>, <a href="../../reference-trixi/#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_shima_etal</code></a>, <a href="../../reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_chandrashekar</code></a>, <a href="../../reference-trixi/#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_kennedy_gruber</code></a>. As surface flux you can use all volume fluxes and additionally for instance <a href="../../reference-trixi/#Trixi.flux_lax_friedrichs"><code>flux_lax_friedrichs</code></a>, <a href="../../reference-trixi/#Trixi.flux_hll"><code>flux_hll</code></a>, <a href="../../reference-trixi/#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_hllc</code></a>.</p><h2 id="Package-versions"><a class="docs-heading-anchor" href="#Package-versions">Package versions</a><a id="Package-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Package-versions" title="Permalink"></a></h2><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;Trixi&quot;, &quot;OrdinaryDiffEq&quot;, &quot;Plots&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.10.3
Commit 0b4590a5507 (2024-04-30 10:59 UTC)
Build Info:
  Official https://julialang.org/ release
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 4 × AMD EPYC 7763 64-Core Processor
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-15.0.7 (ORCJIT, znver3)
Threads: 1 default, 0 interactive, 1 GC (on 4 virtual cores)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
<span class="sgr32"><span class="sgr1">Status</span></span> `~/work/Trixi.jl/Trixi.jl/docs/Manifest.toml`
<span class="sgr32">⌃</span> <span class="sgr90">[1dea7af3] </span>OrdinaryDiffEq v6.66.0
  <span class="sgr90">[91a5bcdd] </span>Plots v1.40.4
  <span class="sgr90">[a7f1ee26] </span>Trixi v0.7.13 `~/work/Trixi.jl/Trixi.jl`
<span class="sgr36"><span class="sgr1">Info</span></span> Packages marked with <span class="sgr32">⌃</span> have new versions available and may be upgradable.</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scalar_linear_advection_1d/">« 3 Introduction to DG methods</a><a class="docs-footer-nextpage" href="../shock_capturing/">5 Shock capturing with flux differencing and stage limiter »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 16 May 2024 07:00">Thursday 16 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
